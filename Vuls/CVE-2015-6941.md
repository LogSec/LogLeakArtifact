## Summary:  
Software: salt  
## Fix:  
Commit: https://github.com/saltstack/salt/pull/27074/commits/fdd35374562658f4a20767a3703fab93d92f9ca9  
Author: Shane Lee  
Fix Time (of the Last Commit): 2015-09-12  
  
Fix Pattern: Sanitization -> Redaction -> Introduction -> KeywordBasedFiltration -> NoRedactionFunctionDefined  
  
Fixing-commits Count: 2  
Total Change Size: +128 -45  
  
========  
PR: https://github.com/saltstack/salt/pull/27074 | PR: https://github.com/saltstack/salt/pull/27336  
  
Commit: https://github.com/saltstack/salt/pull/27336/commits/7956b360766c1fb9cca884d4a355c37123f77de4  
Change Size: +122 -41  
Commit: https://github.com/saltstack/salt/pull/27074/commits/fdd35374562658f4a20767a3703fab93d92f9ca9  
Change Size: +6 -4  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> password information  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Logging Statements -> Variable Names（password）|String Literals（password，finally outputed to logs）  
#### Sink 2:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/utils/cloud.py#L735） -> Variable Names（password）  
#### Sink 3:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/utils/cloud.py#L735） -> Variable Names（password）  
#### Sink 4:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Same Methods & Cross Statements（https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/utils/cloud.py#L1738） -> String Literals（sudo_password，finally outputed to logs）  
#### Sink 5:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Same Methods & Cross Statements（https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/utils/cloud.py#L1738） -> String Literals（sudo_password，finally outputed to logs）  
#### Sink 6:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Logging Statements -> Variable Names（password_data，Logging Variables）  
#### Sink 7:  
Logging call Function:  User-defined（format_log）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/states/user.py#L515） -> Variable Names（password）|String Literals（password，finally outputed to logs）  
Programming Language:Python  
```Python  
# https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/utils/cloud.py#L954-L1429  
def deploy_script(host,  
                  port=22,  
                  timeout=900,  
                  username='root',  
                  password=None,  
                  key_filename=None,  
                  script=None,  
                  name=None,  
                  sock_dir=None,  
                  provider=None,  
                  conf_file=None,  
                  start_action=None,  
                  make_master=False,  
                  master_pub=None,  
                  master_pem=None,  
                  master_conf=None,  
                  minion_pub=None,  
                  minion_pem=None,  
                  minion_conf=None,  
                  keep_tmp=False,  
                  script_args=None,  
                  script_env=None,  
                  ssh_timeout=15,  
                  maxtries=15,  
                  make_syndic=False,  
                  make_minion=True,  
                  display_ssh_output=True,  
                  preseed_minion_keys=None,  
                  parallel=False,  
                  sudo_password=None,  
                  sudo=False,  
                  tty=None,  
                  deploy_command='/tmp/.saltcloud/deploy.sh',  
                  opts=None,  
                  tmp_dir='/tmp/.saltcloud',  
                  file_map=None,  
                  master_sign_pub_file=None,  
                  **kwargs):  
    '''  
    Copy a deploy script to a remote server, execute it, and remove it  
    '''  
# OMIT FOR SIMPLICITY  
            if key_filename:  
                log.debug('Using {0} as the key_filename'.format(key_filename))  
                ssh_kwargs['key_filename'] = key_filename  
            elif password and kwargs.get('has_ssh_agent', False) is False:  
                log.debug('Using {0} as the password'.format(password)) # HERE IS THE SINK 1  
                ssh_kwargs['password'] = password  
              
            if root_cmd('test -e \'{0}\''.format(tmp_dir), tty, sudo,  
                        allow_failure=True, **ssh_kwargs):  
                ret = root_cmd(('sh -c "( mkdir -p \'{0}\' &&'  
                                ' chmod 700 \'{0}\' )"').format(tmp_dir),  
                               tty, sudo, **ssh_kwargs)  
                if ret:  
                    raise SaltCloudSystemExit(  
                        'Cant create temporary '  
                        'directory in {0} !'.format(tmp_dir)  
                    )  
# OMIT FOR SIMPLICITY  
  
# https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/utils/cloud.py#L728-L740  
  
def validate_windows_cred(host, username='Administrator', password=None, retries=10,  
                          retry_delay=1):  
    '''  
    Check if the windows credentials are valid  
    '''  
    for i in xrange(retries):  
        retcode = win_cmd("winexe -U '{0}%{1}' //{2} \"hostname\"".format(  
            username, password, host  
        )) # HERE IS THE FLOW  
        if retcode == 0:  
            break  
        time.sleep(retry_delay)  
    return retcode == 0  
  
# https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/utils/cloud.py#L1699-L1727  
def win_cmd(command, **kwargs):  
    '''  
    Wrapper for commands to be run against Windows boxes  
    '''  
    try:  
        proc = NonBlockingPopen(  
            command,  
            shell=True,  
            stderr=subprocess.PIPE,  
            stdout=subprocess.PIPE,  
            stream_stds=kwargs.get('display_ssh_output', True),  
        )  
        log.debug(  
            'Executing command(PID {0}): {1!r}'.format(  
                proc.pid, command  
            )  
        ) # HERE IS THE SINK 2  
        proc.poll_and_read_until_finish()  
        proc.communicate()  
        return proc.returncode  
    except Exception as err:  
        log.error(  
            'Failed to execute command {0!r}: {1}\n'.format(  
                command, err  
            ),  
            exc_info=True  
        ) # HERE IS THE SINK 3  
    # Signal an error  
    return 1  
  
  
# https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/utils/cloud.py#L1730-L1822  
def root_cmd(command, tty, sudo, allow_failure=False, **kwargs):  
    '''  
    Wrapper for commands to be run as root  
    '''  
    if sudo:  
        if 'sudo_password' in kwargs and kwargs['sudo_password'] is not None:  
            command = 'echo "{1}" | sudo -S {0}'.format(  
                command,  
                kwargs['sudo_password'],  
            )  
        else:  
            command = 'sudo {0}'.format(command)  
        log.debug('Using sudo to run command {0}'.format(command)) # HERE IS THE SINK 4  
  
# OMIT FOR SIMPLICITY  
  
    cmd = 'ssh {0} {1[username]}@{1[hostname]} {2}'.format(  
        ' '.join(ssh_args), kwargs, pipes.quote(command)  
    )  
    log.debug('SSH command: {0!r}'.format(cmd)) # HERE IS THE SINK 5  
    retcode = _exec_ssh_cmd(cmd, allow_failure=allow_failure, **kwargs)  
    return retcode        
  
  
# https://github.com/rallytime/salt/blob/421f1fde1e0639c8dd0b33fae8d9b1729e99bb06/salt/cloud/clouds/ec2.py#L1931-L2099  
  
def wait_for_instance(  
        vm_=None,  
        data=None,  
        ip_address=None,  
        display_ssh_output=True,  
        call=None,  
    ):  
    '''  
    Wait for an instance upon creation from the EC2 API, to become available  
    '''  
# OMIT FOR SIMPLICITY  
        if win_passwd and win_passwd == 'auto':  
            log.debug('Waiting for auto-generated Windows EC2 password')  
            while True:  
                password_data = get_password_data(  
                    name=vm_['name'],  
                    kwargs={  
                        'key_file': vm_['private_key'],  
                    },  
                    call='action',  
                )  
                log.debug(password_data) # HERE IS THE SINK 6  
                win_passwd = password_data.get('password', None)  
                if win_passwd is None:  
                    # This wait is so high, because the password is unlikely to  
                    # be generated for at least 4 minutes  
                    time.sleep(60)  
                else:  
                    vm_['win_password'] = win_passwd  
                    break  
# OMIT FOR SIMPLICITY  
  
  
# https://github.com/saltstack/salt/blob/4f3cb36955d84c6793efcbeabf53963067922d90/salt/cloud/clouds/ec2.py#L4861-L4932  
def get_password_data(  
    name=None, kwargs=None, instance_id=None, call=None,  
):  
    """  
    Return password data for a Windows instance.  
    By default only the encrypted password data will be returned. However, if a  
    key_file is passed in, then a decrypted password will also be returned.  
    Note that the key_file references the private key that was used to generate  
    the keypair associated with this instance. This private key will _not_ be  
    transmitted to Amazon; it is only used internally inside of Salt Cloud to  
    decrypt data _after_ it has been received from Amazon.  
    CLI Examples:  
    .. code-block:: bash  
        salt-cloud -a get_password_data mymachine  
        salt-cloud -a get_password_data mymachine key_file=/root/ec2key.pem  
    Note: PKCS1_v1_5 was added in PyCrypto 2.5  
    """  
    # OMIT FOR SIMPLICITY  
        params = {"Action": "GetPasswordData", "InstanceId": instance_id}  
  
    ret = {}  
    data = aws.query(  
        params,  
        return_root=True,  
        location=get_location(),  
        provider=get_provider(),  
        opts=__opts__,  
        sigver="4",  
    )  
  
    for item in data:  
        ret[next(iter(item.keys()))] = next(iter(item.values()))  
# OMIT FOR SIMPLICITY  
    return ret  
          
  
# https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/states/user.py#L510-L515  
  
                    if spost['passwd'] != password:  
                        ret['comment'] = 'User {0} created but failed to set' \  
                                         ' password to' \  
                                         ' {1}'.format(name, password)  
                        ret['result'] = False  
                    ret['changes']['password'] = password  
  
# https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/state.py#L1470-L1611  
  
def call(self, low, chunks=None, running=None):  
    '''  
    Call a state directly with the low data structure, verify data  
    before processing.  
    '''  
    start_time = datetime.datetime.now()  
    log.info('Running state [{0}] at time {1}'.format(low['name'], start_time.time().isoformat()))  
    errors = self.verify_data(low)  
    if errors:  
        ret = {  
            'result': False,  
            'name': low['name'],  
            'changes': {},  
            'comment': '',  
            }  
        for err in errors:  
            ret['comment'] += '{0}\n'.format(err)  
        ret['__run_num__'] = self.__run_num  
        self.__run_num += 1  
        format_log(ret)  
        self.check_refresh(low, ret)  
        return ret  
    else:  
        ret = {'result': False, 'name': low['name'], 'changes': {}}  
  
    if not low.get('__prereq__'):  
        log.info(  
                'Executing state {0[state]}.{0[fun]} for {0[name]}'.format(  
                    low  
                    )  
                )  
  
    if 'provider' in low:  
        self.load_modules(low)  
  
    state_func_name = '{0[state]}.{0[fun]}'.format(low)  
    cdata = salt.utils.format_call(  
        self.states[state_func_name],  
        low,  
        initial_ret={'full': state_func_name},  
        expected_extra_kws=STATE_INTERNAL_KEYWORDS  
    )  
  
    inject_globals = {  
        # Pass a copy of the running dictionary, the low state chunks and  
        # the current state dictionaries.  
        # We pass deep copies here because we don't want any misbehaving  
        # state module to change these at runtime.  
        '__low__': immutabletypes.freeze(low),  
        '__running__': immutabletypes.freeze(running) if running else {},  
        '__instance_id__': self.instance_id,  
        '__lowstate__': immutabletypes.freeze(chunks) if chunks else {}  
    }  
  
    if low.get('__prereq__'):  
        test = sys.modules[self.states[cdata['full']].__module__].__opts__['test']  
        sys.modules[self.states[cdata['full']].__module__].__opts__['test'] = True  
    try:  
        # Let's get a reference to the salt environment to use within this  
        # state call.  
        #  
        # If the state function accepts an 'env' keyword argument, it  
        # allows the state to be overridden(we look for that in cdata). If  
        # that's not found in cdata, we look for what we're being passed in  
        # the original data, namely, the special dunder __env__. If that's  
        # not found we default to 'base'  
        if ('unless' in low and '{0[state]}.mod_run_check'.format(low) not in self.states) or \  
                ('onlyif' in low and '{0[state]}.mod_run_check'.format(low) not in self.states):  
            ret.update(self._run_check(low))  
  
        if 'saltenv' in low:  
            inject_globals['__env__'] = str(low['saltenv'])  
        elif isinstance(cdata['kwargs'].get('env', None), string_types):  
            # User is using a deprecated env setting which was parsed by  
            # format_call.  
            # We check for a string type since module functions which  
            # allow setting the OS environ also make use of the "env"  
            # keyword argument, which is not a string  
            inject_globals['__env__'] = str(cdata['kwargs']['env'])  
        elif '__env__' in low:  
            # The user is passing an alternative environment using __env__  
            # which is also not the appropriate choice, still, handle it  
            inject_globals['__env__'] = str(low['__env__'])  
        else:  
            # Let's use the default environment  
            inject_globals['__env__'] = 'base'  
  
        if 'result' not in ret or ret['result'] is False:  
            with context.func_globals_inject(self.states[cdata['full']],  
                                                **inject_globals):  
                ret = self.states[cdata['full']](*cdata['args'],  
                                                    **cdata['kwargs']) # HERE IS THE FLOW  
        if 'check_cmd' in low and '{0[state]}.mod_run_check_cmd'.format(low) not in self.states:  
            ret.update(self._run_check_cmd(low))  
        self.verify_ret(ret)  
    except Exception:  
        trb = traceback.format_exc()  
        # There are a number of possibilities to not have the cdata  
        # populated with what we might have expected, so just be smart  
        # enough to not raise another KeyError as the name is easily  
        # guessable and fallback in all cases to present the real  
        # exception to the user  
        if len(cdata['args']) > 0:  
            name = cdata['args'][0]  
        elif 'name' in cdata['kwargs']:  
            name = cdata['kwargs']['name']  
        else:  
            name = low.get('name', low.get('__id__'))  
        ret = {  
            'result': False,  
            'name': name,  
            'changes': {},  
            'comment': 'An exception occurred in this state: {0}'.format(  
                trb)  
        }  # HERE IS THE FLOW  
    finally:  
        if low.get('__prereq__'):  
            sys.modules[self.states[cdata['full']].__module__].__opts__[  
                'test'] = test  
  
    # If format_call got any warnings, let's show them to the user  
    if 'warnings' in cdata:  
        ret.setdefault('warnings', []).extend(cdata['warnings'])  
  
    if 'provider' in low:  
        self.load_modules()  
  
    if low.get('__prereq__'):  
        low['__prereq__'] = False  
        return ret  
  
    ret['__run_num__'] = self.__run_num  
    self.__run_num += 1  
    format_log(ret) # HERE IS THE SINK 7  
    self.check_refresh(low, ret)  
    finish_time = datetime.datetime.now()  
    ret['start_time'] = start_time.time().isoformat()  
    delta = (finish_time - start_time)  
    # duration in milliseconds.microseconds  
    ret['duration'] = (delta.seconds * 1000000 + delta.microseconds)/1000.0  
    log.info('Completed state [{0}] at time {1}'.format(low['name'], finish_time.time().isoformat()))  
    return ret  
  
# https://github.com/saltstack/salt/blob/e430e97f6c06919b6c5ce7a11e90403e8d14260d/salt/state.py#L181-L218  
  
def format_log(ret):  
    '''  
    Format the state into a log message  
    '''  
    msg = ''  
    if isinstance(ret, dict):  
        # Looks like the ret may be a valid state return  
        if 'changes' in ret:  
            # Yep, looks like a valid state return  
            chg = ret['changes']  
            if not chg:  
                if ret['comment']:  
                    msg = ret['comment']  
                else:  
                    msg = 'No changes made for {0[name]}'.format(ret)  
            elif isinstance(chg, dict):  
                if 'diff' in chg:  
                    if isinstance(chg['diff'], string_types):  
                        msg = 'File changed:\n{0}'.format(chg['diff'])  
                if all([isinstance(x, dict) for x in chg.values()]):  
                    if all([('old' in x and 'new' in x)  
                            for x in chg.values()]):  
                        # This is the return data from a package install  
                        msg = 'Installed Packages:\n'  
                        for pkg in chg:  
                            old = chg[pkg]['old'] or 'absent'  
                            new = chg[pkg]['new'] or 'absent'  
                            msg += '{0!r} changed from {1!r} to ' \  
                                   '{2!r}\n'.format(pkg, old, new)  
            if not msg:  
                msg = str(ret['changes'])  
            if ret['result'] is True or ret['result'] is None:  
                log.info(msg)  
            else:  
                log.error(msg)  
    else:  
        # catch unhandled data  
        log.info(str(ret))  
  
```  
