## Summary:  
Software: traefik  
## Fix:  
Commit: https://github.com/dtomcej/traefik/commit/141d3ba1ead92efbcd965ff40817b1874504f8fc  
Author: Daniel Tomcej  
Fix Time (of the Last Commit): 2020-02-06  
Fix Pattern: Sanitization -> Redaction -> Enhancement (Corrective Change) -> Tag/TypeBasedFiltration -> NoRedactionFunctionDefined  
  
  
Fixing-commits Count: 3  
Total Change Size: +9 -7  
  
==========  
PR: https://github.com/containous/traefik/pull/6281  
Commit: https://github.com/dtomcej/traefik/commit/141d3ba1ead92efbcd965ff40817b1874504f8fc  
Change Size: +4 -2  
Comment: main logic  
Commit: https://github.com/dtomcej/traefik/commit/7ece5bd22de815975d88ac3c6826673fc40173d9  
Change Size: +3 -3  
Comment: misc  
Commit: https://github.com/dtomcej/traefik/commit/94367213b6e0de6c2a264bc55163a5fa09a94a4a  
Change Size: +2 -2  
Comment: misc  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> certificate contents  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（sirupsen/logrus）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/dtomcej/traefik/blob/94367213b6e0de6c2a264bc55163a5fa09a94a4a/pkg/tls/tls.go#L31） -> Variable Names(DefaultCertificate )  
Programming Language:Go  
```go  
// https://github.com/dtomcej/traefik/blob/94367213b6e0de6c2a264bc55163a5fa09a94a4a/pkg/server/configurationwatcher.go#L145-L190  
  
func (c *ConfigurationWatcher) preLoadConfiguration(configMsg dynamic.Message) {  
	currentConfigurations := c.currentConfigurations.Get().(dynamic.Configurations)  
  
	logger := log.WithoutContext().WithField(log.ProviderName, configMsg.ProviderName)  
	if log.GetLevel() == logrus.DebugLevel {  
		copyConf := configMsg.Configuration.DeepCopy()  
		if copyConf.TLS != nil {  
			copyConf.TLS.Certificates = nil  
  
			for k := range copyConf.TLS.Stores {  
				st := copyConf.TLS.Stores[k]  
				st.DefaultCertificate = nil  
				copyConf.TLS.Stores[k] = st  
			}  
		}  
  
		jsonConf, err := json.Marshal(copyConf)  
		if err != nil {  
			logger.Errorf("Could not marshal dynamic configuration: %v", err)  
			logger.Debugf("Configuration received from provider %s: [struct] %#v", configMsg.ProviderName, copyConf) // HERE IS THE SINK 1  
		} else {  
			logger.Debugf("Configuration received from provider %s: %s", configMsg.ProviderName, string(jsonConf)) // 这里不是SINK，因为根据TLS的定义，Marshal会进行脱敏  
		}  
	}  
  
	if isEmptyConfiguration(configMsg.Configuration) {  
		logger.Infof("Skipping empty Configuration for provider %s", configMsg.ProviderName)  
		return  
	}  
  
	if reflect.DeepEqual(currentConfigurations[configMsg.ProviderName], configMsg.Configuration) {  
		logger.Infof("Skipping same configuration for provider %s", configMsg.ProviderName)  
		return  
	}  
  
	providerConfigUpdateCh, ok := c.providerConfigUpdateMap[configMsg.ProviderName]  
	if !ok {  
		providerConfigUpdateCh = make(chan dynamic.Message)  
		c.providerConfigUpdateMap[configMsg.ProviderName] = providerConfigUpdateCh  
		c.routinesPool.GoCtx(func(ctxPool context.Context) {  
			c.throttleProviderConfigReload(ctxPool, c.providersThrottleDuration, c.configurationValidatedChan, providerConfigUpdateCh)  
		})  
	}  
  
	providerConfigUpdateCh <- configMsg  
}  
  
```  
