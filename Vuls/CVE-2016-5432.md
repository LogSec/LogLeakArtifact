## Summary:  
Software: ovirt/ovirt_engine  
## Fix:  
Commit: https://github.com/oVirt/ovirt-engine/commit/4d93bb11cb3c644b232aa7bdf6aa465d40b3427c  
Change Size: +136 -36  
Review: https://gerrit.ovirt.org/c/ovirt-engine/+/62849  
Author: Yedidyah Bar David  
Fix Time (of the Last Commit): 2016-08-26  
Fix Pattern: Sanitization -> Redaction -> Reuse -> Tag/TypeBasedFiltration -> RedactionFunctionDefined  
  
Fixing-commits Count: 1  
Total Change Size: +136 -36  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> sensitive database provisioning information  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（dumpEnvironment）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/oVirt/ovirt-engine/blob/4d93bb11cb3c644b232aa7bdf6aa465d40b3427c/packaging/setup/ovirt_engine_setup/provisiondb/constants.py#L63） -> Variable Names（ProvDBEnv.PASSWORD）|String Literals（OVESETUP_PROVISION_DB/password，finally outputed to logs）  
Programming Language:Python  
```Python  
  
# https://github.com/oVirt/otopi/blob/c5a194cd3b57161f0c10907536a27e489f2175e7/src/otopi/context.py#L722-L767  
  
    def runSequence(self):  
        """Run sequence."""  
        for self._currentStage in sorted(self._sequence.keys()):  
            if_no_error = plugin.Stages.DATABASE[  
                self._currentStage  
            ]['if-success']  
  
            if (  
                not if_no_error or  
                not self.environment[constants.BaseEnv.ERROR]  
            ):  
                self.logger.info(  
                    _("Stage: {stage}").format(  
                        stage=plugin.Stages.stage_str(self._currentStage),  
                    )  
                )  
                self.logger.debug(  
                    "STAGE %s" % plugin.Stages.stage_id(self._currentStage)  
                )  
                for methodinfo in self._sequence[self._currentStage]:  
                    if (  
                        not if_no_error or  
                        not self.environment[constants.BaseEnv.ERROR]  
                    ):  
                        oldEnvironment = dict(  
                            (k, common.toStr(v))  
                            for k, v in self.environment.items()  
                        )  
                        self._executeMethod(self._currentStage, methodinfo)  
                        self.dumpEnvironment(old=oldEnvironment) # HERE IS THE SINK 1  
  
        if self.environment[constants.BaseEnv.ERROR]:  
            infos = self.environment[  
                constants.BaseEnv.EXCEPTION_INFO  
            ]  
            for exception_info in infos:  
                self.logger.debug(  
                    'Exception: %s' % (  
                        traceback.format_tb(exception_info[2])  
                    )  
                )  
  
            if infos:  
                util.raiseExceptionInformation(infos[0])  
            else:  
                raise RuntimeError(_('Error during sequence'))  
  
  
# https://github.com/oVirt/otopi/blob/c5a194cd3b57161f0c10907536a27e489f2175e7/src/otopi/context.py#L810-L837  
  
  
    def dumpEnvironment(self, old=None):  
        """Dump environment."""  
        diff = False  
        for key in sorted(self.environment.keys()):  
            value = common.toStr(self.environment[key])  
  
            if (  
                old is None or  
                key not in old or  # Dump if added, even if None  
                value != common.toStr(old.get(key))  
            ):  
                if not diff:  
                    diff = True  
                    self.logger.debug('ENVIRONMENT DUMP - BEGIN')  
  
                if key in self.environment[  
                    constants.BaseEnv.SUPPRESS_ENVIRONMENT_KEYS  
                ]:  
                    value = '***'  
                self.logger.debug(  
                    "ENV %s=%s:'%s'",  
                    key,  
                    type(self.environment[key]).__name__,  
                    value,  
                ) # HERE IS THE INNER SINK  
  
        if diff:  
            self.logger.debug('ENVIRONMENT DUMP - END')                 
  
  
# https://github.com/oVirt/otopi/blob/c5a194cd3b57161f0c10907536a27e489f2175e7/src/otopi/base.py#L16-L33  
  
class Base(object):  
    """Base class for all objects."""  
  
    _LOG_PREFIX = 'otopi.'  
  
    @property  
    def logger(self):  
        """Logger."""  
        return self._logger  
  
    def __init__(self):  
        """Contructor."""  
  
        prefix = ''  
        if not self.__module__.startswith(self._LOG_PREFIX):  
            prefix = self._LOG_PREFIX  
  
        self._logger = logging.getLogger(prefix + self.__module__)  
  
# https://github.com/oVirt/otopi/blob/dc4d66f6cf9a1872a98c6abbb9c318d2c2875b7e/src/plugins/otopi/core/log.py#L38-L166  
  
class Plugin(plugin.PluginBase):  
    """Log provier.  
    Log is based on standard python logging.  
    Environment:  
        CoreEnv.LOG_FILE_HANDLE -- opened handle.  
        CoreEnv.LOG_DIR -- log directory.  
        CoreEnv.LOG_FILE_NAME_REFIX -- file name prefix.  
        CoreEnv.LOG_FILE_NAME -- file name.  
        CoreEnv.LOG_FILTER -- list of strings to flter out.  
        CoreEnv.LOG_REMOVE_AT_EXIT -- True if to remove log.  
    OS Environment:  
        SystemEnvironment.LOG_FILE -- log file name, default self genmerate.  
        SystemEnvironment.LOG_DIR -- log directory, default is tempdir.  
    """  
    class _MyLoggerFilter(object):  
        """List wrapper to not expose content by str()"""  
  
        def __init__(self):  
            self._list = []  
  
        def append(self, string):  
            self._list.append(string)  
  
        def __str__(self):  
            return 'filter'  
  
    class _MyFormatter(logging.Formatter):  
        """Filter strings from log entries."""  
  
        @property  
        def environment(self):  
            return self._environment  
  
        def __init__(  
            self,  
            fmt=None,  
            datefmt=None,  
            environment=None,  
        ):  
            logging.Formatter.__init__(self, fmt=fmt, datefmt=datefmt)  
            self._environment = environment  
  
        def format(self, record):  
            msg = logging.Formatter.format(self, record)  
  
            for f in (  
                self.environment[constants.CoreEnv.LOG_FILTER]._list +  
                [  
                    self.environment[k] for k in  
                    self.environment[constants.CoreEnv.LOG_FILTER_KEYS]  
                ]  
            ):  
                if f not in (None, ''):  
                    msg = msg.replace(f, '**FILTERED**')  
  
            return msg  
  
    def __init__(self, context):  
        super(Plugin, self).__init__(context=context)  
        self._handler = None  
  
    def _setupLogging(self):  
        self.environment[constants.CoreEnv.LOG_FILE_HANDLE] = None  
        self.environment[constants.CoreEnv.LOG_FILTER] = self._MyLoggerFilter()  
        self.environment[constants.CoreEnv.LOG_FILTER_KEYS] = []  
        self.environment.setdefault(  
            constants.CoreEnv.LOG_FILE_NAME_PREFIX,  
            constants.Defaults.LOG_FILE_PREFIX  
        )  
  
        #  
        # Allow system environment to override both  
        # the log dir and the log file  
        #  
        self.environment[constants.CoreEnv.LOG_DIR] = os.environ.get(  
            constants.SystemEnvironment.LOG_DIR,  
            self.environment.get(  
                constants.CoreEnv.LOG_DIR,  
                tempfile.gettempdir(),  
            ),  
        )  
        logFileName = self.environment[  
            constants.CoreEnv.LOG_FILE_NAME  
        ] = os.environ.get(  
            constants.SystemEnvironment.LOG_FILE,  
            self.environment.get(  
                constants.CoreEnv.LOG_FILE_NAME,  
                os.path.join(  
                    self.environment[constants.CoreEnv.LOG_DIR],  
                    "%s-%s.log" % (  
                        self.environment[  
                            constants.CoreEnv.LOG_FILE_NAME_PREFIX  
                        ],  
                        time.strftime("%Y%m%d%H%M%S"),  
                    )  
                )  
            ),  
        )  
  
        # put in our environment  
        # so when re-exec we use same log  
        os.environ[constants.SystemEnvironment.LOG_FILE] = logFileName  
  
        self.environment[constants.CoreEnv.LOG_FILE_HANDLE] = open(  
            self.resolveFile(logFileName),  
            mode='a',  
            buffering=1  
        )  
        self._handler = logging.StreamHandler(  
            self.environment[constants.CoreEnv.LOG_FILE_HANDLE]  
        )  
        self._handler.setLevel(logging.DEBUG)  
        self._handler.setFormatter(  
            self._MyFormatter(  
                fmt=(  
                    '%(asctime)s %(levelname)s %(name)s '  
                    '%(module)s.%(funcName)s:%(lineno)d '  
                    '%(message)s'  
                ),  
                datefmt='%Y-%m-%d %H:%M:%S',  
                environment=self.environment,  
            )  
        )  
        l = logging.getLogger("otopi")  
        l.addHandler(self._handler)  
  
# https://github.com/oVirt/otopi/blob/dc4d66f6cf9a1872a98c6abbb9c318d2c2875b7e/src/plugins/otopi/core/log.py#L203-L216  
  
    @plugin.event(  
        name=constants.Stages.CORE_LOG_INIT,  
        stage=plugin.Stages.STAGE_BOOT,  
        priority=plugin.Stages.PRIORITY_HIGH,  
    )  
    def _init(self):  
        self._setupLogging()  
        self.environment[constants.BaseEnv.LOG] = True  
        self.environment.setdefault(  
            constants.CoreEnv.LOG_REMOVE_AT_EXIT,  
            False  
        )  
  
        self.context.registerNotification(self._notification)  
  
```  
