## Summary:  
Software: zypper  
## Fix:  
Commit: https://github.com/openSUSE/libzypp/commit/293076786541019222c2267b616bec7f5bd110db  
Author: Michael Andres  
Fix Time (of the Last Commit): 2020-11-23  
Fix Pattern: Sanitization -> Redaction -> Introduction  
  
Fixing-commits Count: 3  
Total Change Size: +113 -13  
  
========  
PR: https://github.com/openSUSE/libzypp/pull/261  
Commit: https://github.com/openSUSE/libzypp/commit/09e3a2fc293d2b4fcb50ba69d5150925ac34c953  
Change Size: +2 -1  
Time: 2020-11-23  
Commit: https://github.com/openSUSE/libzypp/commit/293076786541019222c2267b616bec7f5bd110db  
Change Size: +80 -6  
Time: 2020-11-23  
Commit: https://github.com/openSUSE/libzypp/commit/c6128a30354fa193bc6c5ffaef84bf619c65addd  
Change Size: +31 -6  
Time: 2020-11-23  
## Sample logs: Yes  
```  
Download (curl) error for 'http://download.opensuse.org/distribution/leap/42.3/repo/oss/content?proxy=XXX&proxyport=YYYY&proxyuser=ZZZ&proxypass=WWW':  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> HTTP proxy credentials  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（DBG）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/openSUSE/libzypp/blob/bab85ec205a91dc36167476fa6fc0db173e06e56/zypp/media/CurlHelper.cc#L226） -> String Literals（proxypass，finally outputed to logs）  
Programming Language:C/C++  
```C++  
  
// https://github.com/openSUSE/libzypp/blob/bab85ec205a91dc36167476fa6fc0db173e06e56/zypp/media/MediaCurl.cc#L831-L848  
  
bool MediaCurl::doGetDoesFileExist( const Pathname & filename ) const  
{  
  DBG << filename.asString() << endl;  
  
  if(!_url.isValid())  
    ZYPP_THROW(MediaBadUrlException(_url));  
  
  if(_url.getHost().empty())  
    ZYPP_THROW(MediaBadUrlEmptyHostException(_url));  
  
  Url url(getFileUrl(filename));  
  
  DBG << "URL: " << url.asString() << endl; // HERE IS THE SINK 1  
    // Use URL without options and without username and passwd  
    // (some proxies dislike them in the URL).  
    // Curl seems to need the just scheme, hostname and a path;  
    // the rest was already passed as curl options (in attachTo).  
  Url curlUrl( clearQueryString(url) );  
  
// https://github.com/openSUSE/libzypp/blob/bab85ec205a91dc36167476fa6fc0db173e06e56/zypp/url/UrlBase.cc#L437-L575  
  
    std::string  
    UrlBase::asString() const  
    {  
      return asString(getViewOptions());  
    }  
  
  
    // ---------------------------------------------------------------  
    std::string  
    UrlBase::asString(const zypp::url::ViewOptions &opts) const  
    {  
      std::string   url;  
      UrlBaseData   tmp;  
  
      if( opts.has(ViewOptions::WITH_SCHEME))  
      {  
        tmp.scheme = getScheme();  
        if( !tmp.scheme.empty())  
        {  
          url += tmp.scheme + ":";  
  
          if( opts.has(ViewOptions::WITH_HOST))  
          {  
            tmp.host = getHost(zypp::url::E_ENCODED);  
            if( !tmp.host.empty())  
            {  
              url += "//";  
  
              if( opts.has(ViewOptions::WITH_USERNAME))  
              {  
                tmp.user = getUsername(zypp::url::E_ENCODED);  
                if( !tmp.user.empty())  
                {  
                  url += tmp.user;  
  
                  if( opts.has(ViewOptions::WITH_PASSWORD))  
                  {  
                    tmp.pass = getPassword(zypp::url::E_ENCODED);  
                    if( !tmp.pass.empty())  
                    {  
                      url += ":" + tmp.pass;  
                    }  
                  }  
                  url += "@";  
                }  
              }  
  
              url += tmp.host;  
  
              if( opts.has(ViewOptions::WITH_PORT))  
              {  
                tmp.port = getPort();  
                if( !tmp.port.empty())  
                {  
                  url += ":" + tmp.port;  
                }  
              }  
            }  
            else if( opts.has(ViewOptions::EMPTY_AUTHORITY))  
            {  
              url += "//";  
            }  
          }  
          else if( opts.has(ViewOptions::EMPTY_AUTHORITY))  
          {  
            url += "//";  
          }  
        }  
      }  
  
      if( opts.has(ViewOptions::WITH_PATH_NAME))  
      {  
        tmp.pathname = getPathName(zypp::url::E_ENCODED);  
        if( !tmp.pathname.empty())  
        {  
          if(url.find("/") != std::string::npos)  
          {  
            // Url contains authority (that may be empty),  
            // we may need a rewrite of the encoded path.  
            tmp.pathname = cleanupPathName(tmp.pathname, true);  
            if(tmp.pathname.at(0) != '/')  
            {  
              url += "/";  
            }  
          }  
          url += tmp.pathname;  
  
          if( opts.has(ViewOptions::WITH_PATH_PARAMS))  
          {  
            tmp.pathparams = getPathParams();  
            if( !tmp.pathparams.empty())  
            {  
              url += ";" + tmp.pathparams;  
            }  
            else if( opts.has(ViewOptions::EMPTY_PATH_PARAMS))  
            {  
              url += ";";  
            }  
          }  
        }  
        else if( opts.has(ViewOptions::EMPTY_PATH_NAME)  
                 && url.find("/") != std::string::npos)  
        {  
          url += "/";  
          if( opts.has(ViewOptions::EMPTY_PATH_PARAMS))  
          {  
            url += ";";  
          }  
        }  
      }  
  
      if( opts.has(ViewOptions::WITH_QUERY_STR))  
      {  
        tmp.querystr = getQueryString();  
        if( !tmp.querystr.empty())  
        {  
          url += "?" + tmp.querystr;  
        }  
        else if( opts.has(ViewOptions::EMPTY_QUERY_STR))  
        {  
          url += "?";  
        }  
      }  
  
      if( opts.has(ViewOptions::WITH_FRAGMENT))  
      {  
        tmp.fragment = getFragment(zypp::url::E_ENCODED);  
        if( !tmp.fragment.empty())  
        {  
          url += "#" + tmp.fragment;  
        }  
        else if( opts.has(ViewOptions::EMPTY_FRAGMENT))  
        {  
          url += "#";  
        }  
      }  
  
      return url;  
    }  
  
  
// https://github.com/openSUSE/libzypp/blob/master/zypp/url/UrlBase.cc#L114-L173  
  
    /// \brief Hide passwords embedded in a querystr,  
    ///  
    /// Stores the full querystring and maintains a safe version with  
    /// password field stripped. Url::asString will print the passwords  
    /// on demand only.  
    ///  
    /// \see bsc#1050625: VUL-1: CVE-2017-9271: zypper: proxy credentials written to log files  
    class SafeQuerystr  
    {  
    public:  
      SafeQuerystr()  
      {}  
  
      SafeQuerystr( std::string rhs )  
      { _assign( std::move(rhs) ); }  
  
      SafeQuerystr & operator=( std::string rhs )  
      { _assign( std::move(rhs) ); return *this; }  
  
  
      operator const std::string &() const  
      { return str(); }  
  
      const std::string & str() const  
      { return fullStr(); }  
  
      const std::string & str( const ViewOptions & viewopts_r ) const  
      { return (viewopts_r.has( ViewOptions::WITH_PASSWORD ) || viewopts_r.has( ViewOptions::hotfix1050625 )) ? fullStr() : safeStr(); }  
  
      const std::string & fullStr() const  
      { return _fullQuerytsr; }  
  
      const std::string & safeStr() const  
      { return _safeQuerytsr ? _safeQuerytsr.value() : _fullQuerytsr; }  
  
    private:  
      void _assign( std::string && rhs )  
      {  
	_fullQuerytsr = std::move(rhs);  
  
	static constexpr std::string_view tag { "proxypass=" };  
	if ( _fullQuerytsr.find( tag ) != std::string::npos )  
	{  
	  std::string safe;  
	  strv::split( _fullQuerytsr, "&", [&safe]( std::string_view val ) {  
	    if ( val.substr( 0, tag.size()  ) != tag ) {  
	      if ( ! safe.empty() )  
		safe += "&";  
	      safe += val;  
	    }  
	  });  
	  _safeQuerytsr = std::move(safe);  
	}  
	else  
	  _safeQuerytsr = std::nullopt;  
      }  
    private:  
      std::string                _fullQuerytsr;	///<  
      std::optional<std::string> _safeQuerytsr;	///<.  
    };  
  
```  
