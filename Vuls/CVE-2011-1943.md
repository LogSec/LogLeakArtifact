## Summary:  
Software: networkmanager  
## Fix:  
Commit: https://gitlab.freedesktop.org/NetworkManager/NetworkManager/-/commit/78ce088843d59d4494965bfc40b30a2e63d065f6  
Change Size: +0 -1  
Fix Time (of the Last Commit): 2011-05-27  
Author: Dan Williams  
Fix Pattern: Remove -> Logging Calls  
Fixing-commits Count: 1  
Total Change Size: +0 -1  
## Sample logs: Yes  
```  
[   51.092532] NetworkManager[930]: keyfile: parsing bla ...  
[   51.138031] NetworkManager[930]: destroy_one_secret: destroying <group_password!>  
[   51.138042] NetworkManager[930]: destroy_one_secret: destroying <my_password!>  
[   51.138053] NetworkManager[930]: keyfile:     read connection 'bla'  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> certificate password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（Glib Logging）  
Sensitiveness-Identifiable Source:  Logging Statements -> Variable Names（secret）  
Programming Language:C/C++  
```C++  
// https://gitlab.freedesktop.org/NetworkManager/NetworkManager/-/blob/ef71c5cca1f43b09fe90e52950a176bb4cee2ab2/libnm-util/nm-setting-vpn.c#L454-473  
  
  
static void  
destroy_one_secret (gpointer data)  
{  
	char *secret = (char *) data;  
  
	/* Don't leave the secret lying around in memory */  
g_message ("%s: destroying %s", __func__, secret); // HERE IS THE SINK 1  
	memset (secret, 0, strlen (secret));  
	g_free (secret);  
}  
  
static void  
nm_setting_vpn_init (NMSettingVPN *setting)  // HERE IS THE SOURCE  
{  
	NMSettingVPNPrivate *priv = NM_SETTING_VPN_GET_PRIVATE (setting);  
  
	g_object_set (setting, NM_SETTING_NAME, NM_SETTING_VPN_SETTING_NAME, NULL);  
	priv->data = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);  
	priv->secrets = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, destroy_one_secret);  
}  
  
// https://gitlab.freedesktop.org/NetworkManager/NetworkManager/-/blob/ef71c5cca1f43b09fe90e52950a176bb4cee2ab2/libnm-util/nm-setting-vpn.c#L238-244  
  
void  
nm_setting_vpn_remove_secret (NMSettingVPN *setting, const char *key)  
{  
	g_return_if_fail (NM_IS_SETTING_VPN (setting));  
  
	g_hash_table_remove (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, key);  
}  
  
  
// https://gitlab.freedesktop.org/NetworkManager/NetworkManager/-/blob/ef71c5cca1f43b09fe90e52950a176bb4cee2ab2/libnm-util/nm-setting-vpn.c#L73-99  
  
typedef struct {  
	char *service_type;  
  
	/* username of the user requesting this connection, thus  
	 * it's really only valid for user connections, and it also  
	 * should never be saved out to persistent config.  
	 */  
	char *user_name;  
  
	/* The hash table is created at setting object  
	 * init time and should not be replaced.  It is  
	 * a char * -> char * mapping, and both the key  
	 * and value are owned by the hash table, and should  
	 * be allocated with functions whose value can be  
	 * freed with g_free().  Should not contain secrets.  
	 */  
	GHashTable *data;  
  
	/* The hash table is created at setting object  
	 * init time and should not be replaced.  It is  
	 * a char * -> char * mapping, and both the key  
	 * and value are owned by the hash table, and should  
	 * be allocated with functions whose value can be  
	 * freed with g_free().  Should contain secrets only.  
	 */  
	GHashTable *secrets;  
} NMSettingVPNPrivate;  
  
// https://github.com/GNOME/glib/blob/20cfc75d148e3be0c026cc7eff3a9cdb72bf5c56/glib/ghash.c#L1038-L1086  
  
/**  
 * g_hash_table_new_full:  
 * @hash_func: a function to create a hash value from a key  
 * @key_equal_func: a function to check two keys for equality  
 * @key_destroy_func: (nullable): a function to free the memory allocated for the key  
 *     used when removing the entry from the #GHashTable, or %NULL  
 *     if you don't want to supply such a function.  
 * @value_destroy_func: (nullable): a function to free the memory allocated for the  
 *     value used when removing the entry from the #GHashTable, or %NULL  
 *     if you don't want to supply such a function.  
 *  
 * Creates a new #GHashTable like g_hash_table_new() with a reference  
 * count of 1 and allows to specify functions to free the memory  
 * allocated for the key and value that get called when removing the  
 * entry from the #GHashTable.  
 *  
 * Since version 2.42 it is permissible for destroy notify functions to  
 * recursively remove further items from the hash table. This is only  
 * permissible if the application still holds a reference to the hash table.  
 * This means that you may need to ensure that the hash table is empty by  
 * calling g_hash_table_remove_all() before releasing the last reference using  
 * g_hash_table_unref().  
 *  
 * Returns: a new #GHashTable  
 */  
GHashTable *  
g_hash_table_new_full (GHashFunc      hash_func,  
                       GEqualFunc     key_equal_func,  
                       GDestroyNotify key_destroy_func,  
                       GDestroyNotify value_destroy_func)  
{  
  GHashTable *hash_table;  
  
  hash_table = g_slice_new (GHashTable);  
  g_atomic_ref_count_init (&hash_table->ref_count);  
  hash_table->nnodes             = 0;  
  hash_table->noccupied          = 0;  
  hash_table->hash_func          = hash_func ? hash_func : g_direct_hash;  
  hash_table->key_equal_func     = key_equal_func;  
#ifndef G_DISABLE_ASSERT  
  hash_table->version            = 0;  
#endif  
  hash_table->key_destroy_func   = key_destroy_func;  
  hash_table->value_destroy_func = value_destroy_func;  
  
  g_hash_table_setup_storage (hash_table);  
  
  return hash_table;  
}  
  
// https://github.com/GNOME/glib/blob/20cfc75d148e3be0c026cc7eff3a9cdb72bf5c56/glib/ghash.c#L519-L557  
  
/*  
 * g_hash_table_remove_node:  
 * @hash_table: our #GHashTable  
 * @node: pointer to node to remove  
 * @notify: %TRUE if the destroy notify handlers are to be called  
 *  
 * Removes a node from the hash table and updates the node count.  
 * The node is replaced by a tombstone. No table resize is performed.  
 *  
 * If @notify is %TRUE then the destroy notify functions are called  
 * for the key and value of the hash node.  
 */  
static void  
g_hash_table_remove_node (GHashTable   *hash_table,  
                          gint          i,  
                          gboolean      notify)  
{  
  gpointer key;  
  gpointer value;  
  
  key = g_hash_table_fetch_key_or_value (hash_table->keys, i, hash_table->have_big_keys);  
  value = g_hash_table_fetch_key_or_value (hash_table->values, i, hash_table->have_big_values);  
  
  /* Erect tombstone */  
  hash_table->hashes[i] = TOMBSTONE_HASH_VALUE;  
  
  /* Be GC friendly */  
  g_hash_table_assign_key_or_value (hash_table->keys, i, hash_table->have_big_keys, NULL);  
  g_hash_table_assign_key_or_value (hash_table->values, i, hash_table->have_big_values, NULL);  
  
  hash_table->nnodes--;  
  
  if (notify && hash_table->key_destroy_func)  
    hash_table->key_destroy_func (key);  
  
  if (notify && hash_table->value_destroy_func)  
    hash_table->value_destroy_func (value);  
  
}  
  
```  
