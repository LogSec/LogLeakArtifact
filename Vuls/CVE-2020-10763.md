## Summary:  
Software: heketi  
## Fix:  
Commit: https://github.com/heketi/heketi/pull/1790/commits/e2a11686655a4f0cf653a9e20933a7be4177fc57  
Author: Prasanna Kumar Kalever  
Fix Time (of the Last Commit): 2020-09-30  
Fix Pattern: Disable Logging in default   
  
  
Fixing-commits Count: 2  
Total Change Size: +34 -7  
  

========  
PR: https://github.com/heketi/heketi/pull/1790  
  
Commit: https://github.com/heketi/heketi/pull/1790/commits/e2a11686655a4f0cf653a9e20933a7be4177fc57  
Commit: https://github.com/heketi/heketi/pull/1790/commits/22f2271b49fd35ef63d7b6e61fe07749ecbdf888  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> sensitive information such as gluster-block passwords  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（Success）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/phlogistonjohn/heketi/blob/e2a11686655a4f0cf653a9e20933a7be4177fc57/executors/cmdexec/block_volume.go#L250） -> Variable Names(password)  
Programming Language:Go  
```Go  
// https://github.com/heketi/heketi/blob/e6b8c449d7551ae5d0abaad518e9ce24b2ea2554/pkg/remoteexec/ssh/ssh.go#L131-L227  
  
func (s *SshExec) ExecCommands(  
	host string, commands rex.Cmds,  
	timeoutMinutes int, useSudo bool) (rex.Results, error) {  
  
	results := make(rex.Results, len(commands))  
	cmdlog := rexlog.NewCommandLogger(s.logger)  
  
	// :TODO: Will need a timeout here in case the server does not respond  
	client, err := ssh.Dial("tcp", host, s.clientConfig)  
	if err != nil {  
		s.logger.Warning("Failed to create SSH connection to %v: %v", host, err)  
		return nil, err  
	}  
	defer client.Close()  
  
	// Execute each command  
	for index, cmd := range commands {  
		cmdlog.Before(cmd, host)  
  
		session, err := client.NewSession()  
		if err != nil {  
			s.logger.LogError("Unable to create SSH session: %v", err)  
			return nil, err  
		}  
		defer session.Close()  
  
		// Create a buffer to trap session output  
		var b bytes.Buffer  
		var berr bytes.Buffer  
		session.Stdout = &b  
		session.Stderr = &berr  
  
		command := cmd.String()  
		if useSudo {  
			command = "sudo " + command  
		}  
		// Execute command in a shell  
		command = "/bin/bash -c '" +  
			// Escape single quotes in commands (' -> '\'')  
			strings.Replace(command, `'`, `'\''`, -1) +  
			"'"  
  
		// Execute command  
		err = session.Start(command)  
		if err != nil {  
			return nil, err  
		}  
  
		// Spawn function to wait for results  
		errch := make(chan error)  
		go func() {  
			errch <- session.Wait()  
		}()  
  
		// Set the timeout  
		timeout := time.After(time.Minute * time.Duration(timeoutMinutes))  
  
		// Wait for either the command completion or timeout  
		select {  
		case err := <-errch:  
			r := rex.Result{  
				Completed: true,  
				Output:    b.String(),  
				ErrOutput: berr.String(),  
				Err:       err,  
			}  
			if err == nil {  
				cmdlog.Success(cmd, host, r.Output, r.ErrOutput) // HERE IS THE SINK 1  
			} else {  
				cmdlog.Error(cmd, err, host, r.Output, r.ErrOutput)  
				// extract the real error code if possible  
				if ee, ok := err.(*ssh.ExitError); ok {  
					r.ExitStatus = ee.ExitStatus()  
				} else {  
					r.ExitStatus = 1  
				}  
			}  
			results[index] = r  
			if r.ExitStatus != 0 {  
				// stop running commands on error  
				// TODO: make caller configurable?)  
				return results, nil  
			}  
  
		case <-timeout:  
			cmdlog.Timeout(cmd, err, host, b.String(), berr.String())  
			err := session.Signal(ssh.SIGKILL)  
			if err != nil {  
				s.logger.LogError("Unable to send kill signal to command [%v] on host [%v]: %v",  
					command, host, err)  
			}  
			return results, errors.New("SSH command timeout")  
		}  
	}  
  
	return results, nil  
}  
  
// https://github.com/heketi/heketi/blob/e6b8c449d7551ae5d0abaad518e9ce24b2ea2554/pkg/remoteexec/log/commandlog.go#L39-L49  
  
func (cl *CommandLogger) Success(c rex.Cmd, where, out, errout string) {  
	if c.Opts().Quiet {  
		cl.logger.Debug(  
			"Ran command [%v] on [%v]: Stdout filtered, Stderr filtered",  
			c.String(), where)   
		return  
	}  
	cl.logger.Debug(  
		"Ran command [%v] on [%v]: Stdout [%v]: Stderr [%v]",  
		c.String(), where, out, errout) // HERE IS THE INTERNAL SINK  
}  
\  
```  
