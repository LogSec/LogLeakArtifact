## Summary:  
Software: gluster-block  
## Fix:  
Commit: https://github.com/gluster/gluster-block/commit/299589bd21de78e7a1fbd34ad6acf81c39595585  
Author: Prasanna Kumar Kalever  
Fix Time (of the Last Commit): 2020-09-20  
Fix Pattern: Remove -> Logging Variable | Redaction -> Introduction  
  
  
Fixing-commits Count: 2  
Total Change Size: +141 -12  
  
========  
PR: https://github.com/gluster/gluster-block/pull/280  
  
Commit: https://github.com/gluster/gluster-block/commit/299589bd21de78e7a1fbd34ad6acf81c39595585  
Change Size: +81 -2  
Commit: https://github.com/gluster/gluster-block/commit/3e897f450c5549125a09360c3da8eff1aaf5846f  
Change Size: +60 -10  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> passwords  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（LOG）  
Sensitiveness-Identifiable Source:  Logging Statements -> Variable Names（passwd）|String Literals（passwd，finally outputed to logs）  
#### Sink 2:  
Logging call Function:  User-defined（LOG）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/pkalever/gluster-block/blob/12f4cf11317d0cddf54a399f565f1863ec9c13cc/rpc/block_create.c#L857） -> Variable Names（passwd）|String Literals（PASSWORD）  
#### Sink 3:  
Logging call Function:  User-defined（LOG）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/gluster/gluster-block/blob/3e897f450c5549125a09360c3da8eff1aaf5846f/rpc/block_info.c#L77） -> Variable Names（passwd）|String Literals（PASSWORD）  
#### Sink 4:  
Logging call Function:  User-defined（LOG）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/gluster/gluster-block/blob/3e897f450c5549125a09360c3da8eff1aaf5846f/rpc/block_modify.c#L373） -> Variable Names（passwd）|String Literals（PASSWORD）  
#### Sink 5:  
Logging call Function:  User-defined（LOG）  
Sensitiveness-Identifiable Source:  Logging Statements -> Variable Names（passwd）|String Literals（passwd，finally outputed to logs）  
#### Sink 6:  
Logging call Function:  User-defined（LOG）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/gluster/gluster-block/blob/d9f05ea6c3a4c82831851ed878bf2128d2dd079b/rpc/block_modify.c#L1058，https://github.com/pkalever/gluster-block/blob/12f4cf11317d0cddf54a399f565f1863ec9c13cc/rpc/block_create.c#L652） -> Variable Names(authcred)   
#### Sink 7:  
Logging call Function:  User-defined（LOG）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/gluster/gluster-block/blob/d9f05ea6c3a4c82831851ed878bf2128d2dd079b/rpc/block_modify.c#L1058，https://github.com/pkalever/gluster-block/blob/12f4cf11317d0cddf54a399f565f1863ec9c13cc/rpc/block_create.c#L652） -> Variable Names(authcred)   
Programming Language:C/C++  
```C++  
// https://github.com/pkalever/gluster-block/blob/ddf428d0d9654ede4fc77c286a095505f3440958/rpc/block_create.c#L455-L460  
  LOG("mgmt", GB_LOG_INFO,  
      "create request, volume=%s volserver=%s blockname=%s blockhosts=%s "  
      "filename=%s authmode=%d passwd=%s size=%lu control=%s "  
      "io_timeout=%lu", blk->volume, volServer?volServer:blk->ipaddr,  
      blk->block_name, blk->block_hosts, blk->gbid, blk->auth_mode,  
      blk->auth_mode?blk->passwd:"", blk->size, control?control:"", io_timeout); // HERE IS THE SINK 1  
  
// https://github.com/pkalever/gluster-block/blob/12f4cf11317d0cddf54a399f565f1863ec9c13cc/rpc/block_create.c#L1173-L1178  
  if (reply) {  
    cmdlog = gbClipoffSensitiveDetails(reply->out);  
  }  
  LOG("cmdlog", ((!!errCode) ? GB_LOG_ERROR : GB_LOG_INFO), "%s",  
      cmdlog ? cmdlog : "*Nil*"); // HERE IS THE SINK 2  
  GB_FREE(cmdlog);  
  
// https://github.com/gluster/gluster-block/blob/3e897f450c5549125a09360c3da8eff1aaf5846f/rpc/block_info.c#L274-L280  
  blockInfoCliFormatResponse(blk, errCode, errMsg, info, reply);  
  if (reply) {  
    cmdlog = gbClipoffSensitiveDetails(reply->out);  
  }  
  LOG("cmdlog", ((!!errCode) ? GB_LOG_ERROR : GB_LOG_INFO), "%s",  
      cmdlog ? cmdlog : "*Nil*"); // HERE IS THE SINK 3  
  GB_FREE(cmdlog);  
  
// https://github.com/gluster/gluster-block/blob/3e897f450c5549125a09360c3da8eff1aaf5846f/rpc/block_modify.c#L633-L640  
  blockModifyCliFormatResponse (blk, &mobj, asyncret?asyncret:errCode,  
                                errMsg, savereply, info, reply, rollback);  
  if (reply) {  
    cmdlog = gbClipoffSensitiveDetails(reply->out);  
  }  
  LOG("cmdlog", ((!!errCode) ? GB_LOG_ERROR : GB_LOG_INFO), "%s",  
      cmdlog ? cmdlog : "*Nil*"); // HERE IS THE SINK 4  
  GB_FREE(cmdlog);  
  
  // https://github.com/gluster/gluster-block/blob/d9f05ea6c3a4c82831851ed878bf2128d2dd079b/rpc/block_modify.c#L1000-L1003  
    LOG("mgmt", GB_LOG_INFO,  
      "modify request, volume=%s blockname=%s filename=%s authmode=%d passwd=%s",  
      blk->volume, blk->block_name, blk->gbid, blk->auth_mode,  
      blk->auth_mode?blk->passwd:""); // HERE IS THE SINK 5  
  
  
// https://github.com/pkalever/gluster-block/blob/12f4cf11317d0cddf54a399f565f1863ec9c13cc/utils/utils.h#L331-L383  
  
# define  GB_CMD_EXEC_AND_VALIDATE(cmd, sr, blk, vol, opt)             \  
          do {                                                         \  
            FILE *_fp_;                                                  \  
            char _tmp_[1024];                                            \  
            char *_ptr_;                                                 \  
            /* Filter password from targetcli args when writing to log */ \  
            if (gbConf->logLevel >= GB_LOG_DEBUG) {                      \  
              if (opt == CREATE_SRV || opt == MODIFY_SRV) {              \  
                _ptr_ = strdup(cmd);                                     \  
                gbClipoffSensitiveDetailsAtExec(&_ptr_);                 \  
                LOG("mgmt", GB_LOG_DEBUG, "command: %s", _ptr_?_ptr_:""); /* HERE IS THE SINK 6 */\  
                GB_FREE(_ptr_);                                          \  
              } else {                                                   \  
                LOG("mgmt", GB_LOG_DEBUG, "command: %s", cmd);           \  
              }                                                          \  
            }                                                            \  
            _fp_ = popen(cmd, "r");                                      \  
            snprintf(_tmp_, 1024, "%s/%s", vol?vol:"", blk->block_name); \  
            if (_fp_) {                                                  \  
              size_t newLen = fread(sr->out, sizeof(char), 8192, _fp_);  \  
              if (ferror( _fp_ ) != 0) {                                 \  
                LOG("mgmt", GB_LOG_ERROR,                              \  
                    "reading command %s output for %s failed(%s)", _tmp_,\  
                    cmd, strerror(errno));                             \  
                sr->out[0] = '\0';                                     \  
                sr->exit = -1;                                         \  
                pclose(_fp_);                                            \  
                break;                                                 \  
              } else {                                                 \  
                sr->out[newLen++] = '\0';                              \  
              }                                                        \  
              sr->exit = blockValidateCommandOutput(sr->out, opt,      \  
                                                    (void*)blk);       \  
              pclose(_fp_);                                              \  
            } else {                                                   \  
              LOG("mgmt", GB_LOG_ERROR,                                \  
                  "popen(): for %s executing command %s failed(%s)",   \  
                  _tmp_, cmd, strerror(errno));                          \  
            }                                                          \  
            /* Filter password from targetcli output when writing to log */ \  
            if (gbConf->logLevel >= GB_LOG_DEBUG) {                      \  
              if ((opt == CREATE_SRV || opt == MODIFY_SRV)) {            \  
                _ptr_ = strdup(sr->out);                                 \  
                gbClipoffSensitiveDetailsAtExec(&_ptr_);                 \  
                LOG("mgmt", GB_LOG_DEBUG, "raw output: %s", _ptr_?_ptr_:""); /* HERE IS THE SINK 7 */ \  
                GB_FREE(_ptr_);                                          \  
              } else {                                                   \  
                LOG("mgmt", GB_LOG_DEBUG, "raw output: %s", sr->out);    \  
              }                                                          \  
            }                                                            \  
            LOG("mgmt", GB_LOG_INFO, "command exit code, %d",          \  
                 sr->exit);                                            \  
          } while (0)  
  
// https://github.com/pkalever/gluster-block/blob/12f4cf11317d0cddf54a399f565f1863ec9c13cc/utils/utils.h#L189-L238  
# define  LOG(str, level, fmt, ...)                                    \  
          do {                                                         \  
            FILE *_fd_ = NULL;                                         \  
            char _timestamp_[GB_TIME_STRING_BUFLEN] = {0};             \  
            char *_tmp_;                                               \  
            bool _logFileExist_ = false;                               \  
            if (GB_STRDUP(_tmp_, str) < 0)                             \  
              fprintf(stderr, "No memory: %s\n", strerror(errno));     \  
            LOCK(gbConf->lock);                                        \  
            if (level <= gbConf->logLevel) {                           \  
              if (!strcmp(_tmp_, "mgmt")) {                            \  
                if (gbConf->daemonLogFile[0]) {                        \  
                    _fd_ = fopen (gbConf->daemonLogFile, "a");         \  
                    _logFileExist_ = true;                             \  
                }                                                      \  
              } else if (!strcmp(_tmp_, "cli")) {                      \  
                if (gbConf->cliLogFile[0]) {                           \  
                    _fd_ = fopen (gbConf->cliLogFile, "a");            \  
                    _logFileExist_ = true;                             \  
                }                                                      \  
              } else if (!strcmp(_tmp_, "gfapi")) {                    \  
                if (gbConf->gfapiLogFile[0]) {                         \  
                    _fd_ = fopen (gbConf->gfapiLogFile, "a");          \  
                    _logFileExist_ = true;                             \  
                }                                                      \  
              } else if (!strcmp(_tmp_, "cmdlog")) {                   \  
                if (gbConf->cmdhistoryLogFile[0]) {                    \  
                    _fd_ = fopen (gbConf->cmdhistoryLogFile, "a");     \  
                    _logFileExist_ = true;                             \  
                }                                                      \  
              } else {                                                 \  
                _fd_ = stderr;                                         \  
              }                                                        \  
              if (_fd_ == NULL) {                                      \  
                if (_logFileExist_)                                    \  
                    fprintf(stderr, "Error opening log file: %s\n"     \  
                            "Logging to stderr.\n",                    \  
                            strerror(errno));                          \  
                _fd_ = stderr;                                         \  
              }                                                        \  
              logTimeNow(_timestamp_, GB_TIME_STRING_BUFLEN);          \  
              fprintf(_fd_, "[%s] %s: " fmt " [at %s+%d :<%s>]\n",     \  
                      _timestamp_, LogLevelLookup[level],              \  
                      ##__VA_ARGS__, __FILE__, __LINE__, __FUNCTION__);\  
              if (_fd_ != stderr)                                      \  
                fclose(_fd_);                                          \  
            }                                                          \  
            UNLOCK(gbConf->lock);                                      \  
            GB_FREE(_tmp_);                                            \  
          } while (0)  
  
```  
