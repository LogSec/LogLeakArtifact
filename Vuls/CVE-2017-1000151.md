## Summary:  
Software: mahara  
## Fix:  
Commit: https://git.mahara.org/mahara/mahara/commit/b984a1b40700e37f120019cae7fc5a681c9c092a  
Change Size: +44 -3  
Author: Aaron Wells  
Fix Time (of the Last Commit): 2016-04-14  
Fix Pattern: Disable Logging in Default  
  
Fixing-commits Count: 1  
Total Change Size: +44 -3  
## Sample logs: Yes  
```  
[WAR] 65 (auth/user.php:1438) ldap_bind() expects parameter 1 to be resource, null given  
 Call stack (most recent first):  
   * log_message("ldap_bind() expects parameter 1 to be resource, nu...", 8, true, true, "/home/aaronw/www/mahara/htdocs/auth/user.php", 1438) at /home/aaronw/www/mahara/htdocs/lib/errors.php:490  
  * error(2, "ldap_bind() expects parameter 1 to be resource, nu...", "/home/aaronw/www/mahara/htdocs/auth/user.php", 1438, array(size 2)) at Unknown:0  
   * ldap_bind(null, null, "password123") at /home/aaronw/www/mahara/htdocs/auth/user.php:1438  
   * LiveUser->login("aaronw", "password123") at /home/aaronw/www/mahara/htdocs/auth/lib.php:1460  
   * login_submit(object(Pieform), array(size 6)) at Unknown:0  
   * call_user_func_array("login_submit", array(size 2)) at /home/aaronw/www/mahara/htdocs/lib/pieforms/pieform.php:540  
   * Pieform->__construct(array(size 9)) at /home/aaronw/www/mahara/htdocs/lib/mahara.php:4483  
   * pieform_instance(array(size 9)) at /home/aaronw/www/mahara/htdocs/auth/lib.php:504  
   * auth_setup() at /home/aaronw/www/mahara/htdocs/init.php:367  
   * require("/home/aaronw/www/mahara/htdocs/init.php") at /home/aaronw/www/mahara/htdocs/index.php:16  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> passwords or other sensitive information being passed by unusual parameters  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（log_message，）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://git.mahara.org/mahara/mahara/-/blob/b984a1b40700e37f120019cae7fc5a681c9c092a/htdocs/auth/user.php#L1434） -> Variable Names（password）  
Programming Language:PHP  
```PHP  
// https://git.mahara.org/mahara/mahara/-/blob/b984a1b40700e37f120019cae7fc5a681c9c092a/htdocs/lib/errors.php#L52-59  
// Default error reporting settings. Some of these may be changed  
// later in init.php after we've loaded config.php  
$errorlevel = E_ALL & ~E_STRICT;  
error_reporting($errorlevel);  
if (!defined('TESTSRUNNING')) {  
    set_error_handler('error', $errorlevel);  
    set_exception_handler('exception');  
}  
  
  
// https://git.mahara.org/mahara/mahara/-/blob/b984a1b40700e37f120019cae7fc5a681c9c092a/htdocs/lib/errors.php#L460-516  
// Error/Exception handling  
  
/**  
 * Called when any error occurs, due to a PHP error or through a call to  
 * {@link trigger_error}.  
 *  
 * @param int    $code    The code of the error message  
 * @param string $message The message reported  
 * @param string $file    The file the error was detected in  
 * @param string $line    The line number the error was detected on  
 * @param array  $vars    The contents of $GLOBALS at the time the error was detected  
 * @access private  
 */  
function error ($code, $message, $file, $line, $vars) {  
    static $error_lookup = array(  
        E_NOTICE => 'Notice',  
        E_WARNING => 'Warning',  
        E_STRICT => 'Strict',  
        // These won't get handled here unless PHP's behavior changes  
        E_ERROR => 'Error',  
        // These three are not used by this application but may be used by third parties  
        E_USER_NOTICE => 'User Notice',  
        E_USER_WARNING => 'User Warning',  
        E_USER_ERROR => 'User Error'  
    );  
  
    if (defined('E_RECOVERABLE_ERROR')) {  
        $error_lookup[E_RECOVERABLE_ERROR] = 'Warning';  
    }  
  
    if (!error_reporting()) {  
        return;  
    }  
  
    if (!isset($error_lookup[$code])) {  
        return;  
    }  
  
    // Ignore errors from smarty templates, which happen all too often  
    if (function_exists('get_config')) {  
        $compiledir = realpath(get_config('dataroot') . 'dwoo/compile');  
  
        if (E_NOTICE == $code && substr($file, 0, strlen($compiledir)) == $compiledir) {  
            return;  
        }  
  
        if (E_NOTICE == $code && preg_match('#^' . quotemeta(get_config('docroot') . 'theme/') . '[a-z0-9-]+/pieforms#', $file)) {  
            return;  
        }  
    }  
  
    // Fix up the message, which is in HTML form  
    $message = strip_tags($message);  
    $message = htmlspecialchars_decode($message);  
  
    log_message($message, LOG_LEVEL_WARN, true, true, $file, $line); // HERE IS THE SINK 1  
}  
  
// https://git.mahara.org/mahara/mahara/-/blob/b984a1b40700e37f120019cae7fc5a681c9c092a/htdocs/lib/errors.php#L112-443  
/**  
 * Logs a message at the given log level. This function should not be called by  
 * any code outside of this module.  
 *  
 * @param string $message   The message to display  
 * @param int    $loglevel  The level to log the message at  
 * @param bool   $escape    Whether to HTML escape the message  
 * @param bool   $backtrace Whether to provide a backtrace if the system is  
 *                          configured to give backtraces at this level.  
 * @param string $file      The file the error occurred in  
 * @param int    $line      The line number the error occurred on  
 * @param array  $trace     The backtrace for the error  
 * @access private  
 */  
function log_message ($message, $loglevel, $escape, $backtrace, $file=null, $line=null, $trace=null) {  
    global $SESSION, $CFG;  
    if (!$SESSION && function_exists('get_config') && $CFG) {  
        require_once(get_config('docroot') . 'auth/session.php');  
        $SESSION = Session::singleton();  
    }  
  
    static $requestprefix = '';  
    if (!$requestprefix) {  
        $requestprefix = substr(md5(microtime()), 0, 2) . ' ';  
    }  
  
    static $loglevelnames = array(  
        LOG_LEVEL_ENVIRON => 'environ',  
        LOG_LEVEL_DBG     => 'dbg',  
        LOG_LEVEL_INFO    => 'info',  
        LOG_LEVEL_WARN    => 'warn'  
    );  
  
    if (!function_exists('get_config') || null === ($targets = get_config('log_' . $loglevelnames[$loglevel] . '_targets'))) {  
        $targets = LOG_TARGET_SCREEN | LOG_TARGET_ERRORLOG;  
    }  
  
    // Get nice backtrace information if required  
    $trace = ($trace) ? $trace : debug_backtrace();  
    // If the last caller was the 'error' function then it came from a PHP warning  
    if (!is_null($file)) {  
        $filename = $file;  
        $linenum  = $line;  
    }  
    else {  
        $filename  = $trace[1]['file'];  
        $linenum   = $trace[1]['line'];  
    }  
  
    if (!function_exists('get_config') || get_config('log_backtrace_levels') & $loglevel) {  
        list($textbacktrace, $htmlbacktrace) = log_build_backtrace($trace);  
    }  
    else {  
        $textbacktrace = $htmlbacktrace = '';  
    }  
  
    if (is_bool($message)) {  
        $loglines = array(($message ? 'bool(true)' : 'bool(false)'));  
    }  
    else if (is_null($message)) {  
        $loglines = array('NULL');  
    }  
    else {  
        $loglines = explode("\n", print_r($message, true));  
    }  
  
    // Make a prefix for each line, if we are logging a normal debug/info/warn message  
    $prefix = $requestprefix;  
    if ($loglevel != LOG_LEVEL_ENVIRON && function_exists('get_config')) {  
        $docroot = get_config('docroot');  
        $prefixfilename = (substr($filename, 0, strlen($docroot)) == $docroot)  
            ? substr($filename, strlen($docroot))  
            : $filename;  
        $prefix .= '(' . $prefixfilename . ':' . $linenum . ') ';  
    }  
    $prefix = '[' . str_pad(substr(strtoupper($loglevelnames[$loglevel]), 0, 3), 3) . '] ' . $prefix;  
  
    if ($targets & LOG_TARGET_SCREEN || (defined('ADMIN') && $targets & LOG_TARGET_ADMIN)) {  
        // Work out which method to call for displaying the message  
        if ($loglevel == LOG_LEVEL_DBG || $loglevel == LOG_LEVEL_INFO) {  
            $method = 'add_info_msg';  
        }  
        else {  
            $method = 'add_error_msg';  
        }  
  
        $message = implode("\n", $loglines);  
        if ($escape) {  
            $message = htmlspecialchars($message, ENT_COMPAT, 'UTF-8');  
            $message = str_replace('  ', '&nbsp; ', $message);  
        }  
        $message = nl2br($message);  
        $message = '<div class="backtrace">' . $prefix . $message . "</div>\n";  
        if (is_a($SESSION, 'Session')) {  
            $SESSION->$method($message, false);  
        }  
        else if (!function_exists('get_config') || get_config('installed')) {  
            // Don't output when we are not installed, since this will cause the  
            // redirect to the install page to fail.  
            echo $message;  
        }  
  
        if ($backtrace && $htmlbacktrace) {  
            if (is_a($SESSION, 'Session')) {  
                $SESSION->add_info_msg($htmlbacktrace, false);  
            }  
            else if (!function_exists('get_config') || get_config('installed')) {  
                echo $htmlbacktrace;  
            }  
        }  
    }  
  
    if ($targets & LOG_TARGET_ERRORLOG) {  
        foreach ($loglines as $line) {  
            error_log($prefix . $line);  
        }  
        if ($backtrace && $textbacktrace) {  
            $lines = explode("\n", $textbacktrace);  
            foreach ($lines as $line) {  
                error_log($line);  
            }  
        }  
    }  
  
    if ($targets & LOG_TARGET_STDOUT) {  
        foreach ($loglines as $line) {  
            echo($prefix . $line . "\n");  
        }  
        if ($backtrace && $textbacktrace) {  
            echo $textbacktrace;  
        }  
    }  
  
    if (function_exists('get_config')) {  
        if (!$logfilename = get_config('log_file')) {  
            $logfilename = get_config('dataroot') . 'error.log';  
        }  
        if (($targets & LOG_TARGET_FILE) && $logfilename) {  
            global $LOGFILE_FH;  
            static $logfile_open_attempted = null;  
            if (!$logfile_open_attempted) {  
                $logfile_open_attempted = true;  
                $LOGFILE_FH = fopen($logfilename, 'wb');  
                if ($LOGFILE_FH !== false) {  
                    function _close_logfile() {  
                        global $LOGFILE_FH;  
                        fclose($LOGFILE_FH);  
                    }  
                    register_shutdown_function('_close_logfile');  
                }  
                else {  
                    error_log("Could not open your custom log file ($logfilename)");  
                }  
            }  
  
            if (is_resource($LOGFILE_FH)) {  
                foreach ($loglines as $line) {  
                    fwrite($LOGFILE_FH, $prefix . $line . "\n");  
                }  
                if ($backtrace && $textbacktrace) {  
                    $lines = explode("\n", $textbacktrace);  
                    foreach ($lines as $line) {  
                        fwrite($LOGFILE_FH, $line . "\n");  
                    }  
                }  
            }  
        }  
    }  
}  
  
/**  
 * Given an array that contains a backtrace, builds two versions of it - one in  
 * HTML form and one in text form - for logging.  
 *  
 * @param array $backtrace The backtrace to build  
 * @return array           An array containing the backtraces, index 0  
 *                         containing the text version and index 1 containing  
 *                         the HTML version.  
 * @access private  
 */  
function log_build_backtrace($backtrace) {  
    global $CFG;  
    $calls = array();  
  
    // Remove the call to log_message  
    //array_shift($backtrace);  
  
    foreach ($backtrace as $bt) {  
  
        // Blank out any passwords from the logs  
        censor_password_parameters($bt);  
  
        $bt['file']  = (isset($bt['file'])) ? $bt['file'] : 'Unknown';  
        $bt['line']  = (isset($bt['line'])) ? $bt['line'] : 0;  
        $bt['class'] = (isset($bt['class'])) ? $bt['class'] : '';  
        $bt['type']  = (isset($bt['type'])) ? $bt['type'] : '';  
        $bt['args']  = (isset($bt['args'])) ? $bt['args'] : '';  
  
        $args = '';  
        if ($bt['args']) {  
            // Determine whether or not to print the values of the function's  
            // arguments (which may contain sensitive data).  
            // Still always print the values of the "include" pseudofunctions,  
            // though, so the stacktrace will make sense.  
            $showvalues = ($CFG->log_backtrace_print_args === true || in_array(  
                    $bt['function'],  
                    array(  
                        'require',  
                        'include',  
                        'require_once',  
                        'include_once'  
                    )  
            ));  
            foreach ($bt['args'] as $arg) {  
                if (!empty($args)) {  
                    $args .= ', ';  
                }  
                switch (gettype($arg)) {  
                    case 'integer':  
                    case 'double':  
                        if ($showvalues) {  
                            $args .= $arg;  
                        }  
                        else {  
                            $args .= (gettype($arg));  
                        }  
                        break;  
                    case 'string':  
                        if ($showvalues) {  
                            $arg = substr($arg, 0, 50) . ((strlen($arg) > 50) ? '...' : '');  
                            $args .= '"' . $arg . '"';  
                        }  
                        else {  
                            $args .= 'string(size ' . strlen($arg) . ')';  
                        }  
                        break;  
                    case 'array':  
                        $args .= 'array(size ' . count($arg) . ')';  
                        break;  
                    case 'object':  
                        $args .= 'object(' . get_class($arg) . ')';  
                        break;  
                    case 'resource':  
                        $args .= 'resource(' . strstr((string)$arg, '#') . ')';  
                        break;  
                    case 'boolean':  
                        $args .= $arg ? 'true' : 'false';  
                        break;  
                    case 'NULL':  
                        $args .= 'null';  
                        break;  
                    default:  
                        $args .= 'unknown';  
                }  
            }  
        }  
  
        $calls[] = array(  
            'file'  => $bt['file'],  
            'line'  => $bt['line'],  
            'class' => $bt['class'],  
            'type'  => $bt['type'],  
            'func'  => $bt['function'],  
            'args'  => $args  
        );  
    }  
  
    $textmessage = "Call stack (most recent first):\n";  
    $htmlmessage = "<div class=\"backtrace\"><strong>Call stack (most recent first):</strong>\n<ul>";  
  
    foreach ($calls as $call) {  
        $textmessage .= "  * {$call['class']}{$call['type']}{$call['func']}({$call['args']}) at {$call['file']}:{$call['line']}\n";  
        $htmlmessage .= '<li><span style="color:#933;">' . htmlspecialchars($call['class'], ENT_COMPAT, 'UTF-8') . '</span><span style="color:#060;">'  
            . htmlspecialchars($call['type'], ENT_COMPAT, 'UTF-8') . '</span><span style="color:#339;">' . htmlspecialchars($call['func'], ENT_COMPAT, 'UTF-8')  
            . '</span><span style="color:#060;">(</span><span style="color:#f00;">' . htmlspecialchars($call['args'], ENT_COMPAT, 'UTF-8') . '</span><span style="color:#060;">)</span> at <strong>' . htmlspecialchars($call['file'], ENT_COMPAT, 'UTF-8') . ':' . $call['line'] . '</strong></li>';  
    }  
    $htmlmessage .= "</div>\n";  
  
    return array($textmessage, $htmlmessage);  
}  
  
  
/**  
 * Detects whether a backtrace line contains a function call with password parameters in it.  
 * Replaces the value of any password params with "********" so that passwords won't be  
 * printed in the logs or error messages.  
 *  
 * This function assumes any parameter with a name that contains "password" or "pw"  
 * is a password.  
 *  
 * @param array &$backtraceline An entry in the array returned by debug_backtrace()  
 * @return void  
 */  
function censor_password_parameters(&$backtraceline) {  
    if (isset($backtraceline['function'])) {  
        try {  
            if (isset($backtraceline['class'])) {  
                $refClass = new ReflectionClass($backtraceline['class']);  
                $refFunc = $refClass->getMethod($backtraceline['function']);  
            }  
            else {  
                // Function-like "language constructs" such as "require" and "echo"  
                // are listed as a function by debug_backtrace(), but can't be  
                // reflected.  
                if (!function_exists($backtraceline['function'])) {  
                    return;  
                }  
                $refFunc = new ReflectionFunction($backtraceline['function']);  
            }  
  
            foreach ($refFunc->getParameters() as $param) {  
                $name = strtolower($param->getName());  
                if (  
                    strpos($name, 'password') !== false  
                    || strpos($name, 'pw') !== false  
                ) {  
                    $i = $param->getPosition();  
                    if (isset($backtraceline['args'][$i])) {  
                        $backtraceline['args'][$i] = '********';  
                    }  
                }  
            }  
            return;  
        }  
        catch (ReflectionException $re) {  
            // Don't want a failure here to totally prevent logging.  
            return;  
        }  
    }  
  
    return;  
}  
  
  
  
  
```  
