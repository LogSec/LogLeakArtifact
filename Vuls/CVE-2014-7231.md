## Summary:  
Software: openstack/olso  
## Fix:  
Commit: https://github.com/openstack/oslo.utils/commit/e0425691d90bce0bbe847a9ff49468ce0fab5486  
Change Size: +74 -13  
Author: Davanum Srinivas  
Fix Time (of the Last Commit): 2014-08-16  
  
Fix Pattern: Sanitization -> Redaction -> Enhancement (Corrective) -> Keyword/RegexBasedFiltration  
Fixing-commits Count: 1  
Total Change Size: +74 -13  
  
  
========  
Review: https://review.opendev.org/c/openstack/oslo.utils/+/114614/  
## Sample logs: Yes  
```  
2014-07-19 18:35:01.415 20588 ERROR openstack.common.processutils [-] Running cmd (subprocess): /usr/sbin/mysqld --password=secret  
2014-07-19 18:35:48.686 20605 ERROR openstack.common.processutils [-] Running cmd (subprocess): /usr/sbin/mysqld --password="***"  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> passwords from commands  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（Logging）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/cinder/blob/5e4e1f7ea71f9b4c7bd15809c58bc7a1838ed567/cinder/brick/iscsi/iscsi.py#L515） -> Variable Names(chap_auth_password)  
#### Sink 2:  
Logging call Function:  Standard Libraries（Logging）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/cinder/blob/5e4e1f7ea71f9b4c7bd15809c58bc7a1838ed567/cinder/brick/iscsi/iscsi.py#L515） -> Variable Names(chap_auth_password)  
#### Sink 3:  
Logging call Function:  Standard Libraries（Logging）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/cinder/blob/5e4e1f7ea71f9b4c7bd15809c58bc7a1838ed567/cinder/brick/iscsi/iscsi.py#L515） -> Variable Names(chap_auth_password)  
Programming Language:Python  
```Python  
# https://github.com/openstack-archive/oslo-incubator/blob/6a60f84258c2be3391541dbe02e30b8e836f6c22/openstack/common/processutils.py#L85-L213  
  
def execute(*cmd, **kwargs):  
    """Helper method to shell out and execute a command through subprocess.  
    Allows optional retry.  
    :param cmd:             Passed to subprocess.Popen.  
    :type cmd:              string  
    :param process_input:   Send to opened process.  
    :type process_input:    string  
    :param env_variables:   Environment variables and their values that  
                            will be set for the process.  
    :type env_variables:    dict  
    :param check_exit_code: Single bool, int, or list of allowed exit  
                            codes.  Defaults to [0].  Raise  
                            :class:`ProcessExecutionError` unless  
                            program exits with one of these code.  
    :type check_exit_code:  boolean, int, or [int]  
    :param delay_on_retry:  True | False. Defaults to True. If set to True,  
                            wait a short amount of time before retrying.  
    :type delay_on_retry:   boolean  
    :param attempts:        How many times to retry cmd.  
    :type attempts:         int  
    :param run_as_root:     True | False. Defaults to False. If set to True,  
                            the command is prefixed by the command specified  
                            in the root_helper kwarg.  
    :type run_as_root:      boolean  
    :param root_helper:     command to prefix to commands called with  
                            run_as_root=True  
    :type root_helper:      string  
    :param shell:           whether or not there should be a shell used to  
                            execute this command. Defaults to false.  
    :type shell:            boolean  
    :param loglevel:        log level for execute commands.  
    :type loglevel:         int.  (Should be logging.DEBUG or logging.INFO)  
    :returns:               (stdout, stderr) from process execution  
    :raises:                :class:`UnknownArgumentError` on  
                            receiving unknown arguments  
    :raises:                :class:`ProcessExecutionError`  
    """  
  
    process_input = kwargs.pop('process_input', None)  
    env_variables = kwargs.pop('env_variables', None)  
    check_exit_code = kwargs.pop('check_exit_code', [0])  
    ignore_exit_code = False  
    delay_on_retry = kwargs.pop('delay_on_retry', True)  
    attempts = kwargs.pop('attempts', 1)  
    run_as_root = kwargs.pop('run_as_root', False)  
    root_helper = kwargs.pop('root_helper', '')  
    shell = kwargs.pop('shell', False)  
    loglevel = kwargs.pop('loglevel', logging.DEBUG)  
  
    if isinstance(check_exit_code, bool):  
        ignore_exit_code = not check_exit_code  
        check_exit_code = [0]  
    elif isinstance(check_exit_code, int):  
        check_exit_code = [check_exit_code]  
  
    if kwargs:  
        raise UnknownArgumentError(_('Got unknown keyword args: %r') % kwargs)  
  
    if run_as_root and hasattr(os, 'geteuid') and os.geteuid() != 0:  
        if not root_helper:  
            raise NoRootWrapSpecified(  
                message=_('Command requested root, but did not '  
                          'specify a root helper.'))  
        cmd = shlex.split(root_helper) + list(cmd)  
  
    cmd = map(str, cmd)  
    sanitized_cmd = strutils.mask_password(' '.join(cmd))  
  
    while attempts > 0:  
        attempts -= 1  
        try:  
            LOG.log(loglevel, _('Running cmd (subprocess): %s'), sanitized_cmd) # HERE IS THE SINK 1  
            _PIPE = subprocess.PIPE  # pylint: disable=E1101  
  
            if os.name == 'nt':  
                preexec_fn = None  
                close_fds = False  
            else:  
                preexec_fn = _subprocess_setup  
                close_fds = True  
  
            obj = subprocess.Popen(cmd,  
                                   stdin=_PIPE,  
                                   stdout=_PIPE,  
                                   stderr=_PIPE,  
                                   close_fds=close_fds,  
                                   preexec_fn=preexec_fn,  
                                   shell=shell,  
                                   env=env_variables)  
            result = None  
            for _i in six.moves.range(20):  
                # NOTE(russellb) 20 is an arbitrary number of retries to  
                # prevent any chance of looping forever here.  
                try:  
                    if process_input is not None:  
                        result = obj.communicate(process_input)  
                    else:  
                        result = obj.communicate()  
                except OSError as e:  
                    if e.errno in (errno.EAGAIN, errno.EINTR):  
                        continue  
                    raise  
                break  
            obj.stdin.close()  # pylint: disable=E1101  
            _returncode = obj.returncode  # pylint: disable=E1101  
            LOG.log(loglevel, 'Result was %s' % _returncode)  
            if not ignore_exit_code and _returncode not in check_exit_code:  
                (stdout, stderr) = result  
                sanitized_stdout = strutils.mask_password(stdout)  
                sanitized_stderr = strutils.mask_password(stderr)  
                raise ProcessExecutionError(exit_code=_returncode,  
                                            stdout=sanitized_stdout,  
                                            stderr=sanitized_stderr,  
                                            cmd=sanitized_cmd) # HERE IS THE INNER SINK FOR SINK 3  
            return result  
        except ProcessExecutionError:  
            if not attempts:  
                raise  
            else:  
                LOG.log(loglevel, _('%r failed. Retrying.'), sanitized_cmd)  
                if delay_on_retry:  
                    greenthread.sleep(random.randint(20, 200) / 100.0)  
        finally:  
            # NOTE(termie): this appears to be necessary to let the subprocess  
            #               call clean something up in between calls, without  
            #               it two execute calls in a row hangs the second one  
            greenthread.sleep(0)  
  
  
# https://github.com/openstack-archive/oslo-incubator/blob/6a60f84258c2be3391541dbe02e30b8e836f6c22/openstack/common/processutils.py#L243-L277  
def ssh_execute(ssh, cmd, process_input=None,  
                addl_env=None, check_exit_code=True):  
    sanitized_cmd = strutils.mask_password(cmd)  
    LOG.debug('Running cmd (SSH): %s', sanitized_cmd) # HERE IS THE SINK 2  
    if addl_env:  
        raise InvalidArgumentError(_('Environment not supported over SSH'))  
  
    if process_input:  
        # This is (probably) fixable if we need it...  
        raise InvalidArgumentError(_('process_input not supported over SSH'))  
  
    stdin_stream, stdout_stream, stderr_stream = ssh.exec_command(cmd)  
    channel = stdout_stream.channel  
  
    # NOTE(justinsb): This seems suspicious...  
    # ...other SSH clients have buffering issues with this approach  
    stdout = stdout_stream.read()  
    sanitized_stdout = strutils.mask_password(stdout)  
    stderr = stderr_stream.read()  
    sanitized_stderr = strutils.mask_password(stderr)  
  
    stdin_stream.close()  
  
    exit_status = channel.recv_exit_status()  
  
    # exit_status == -1 if no exit code was returned  
    if exit_status != -1:  
        LOG.debug('Result was %s' % exit_status)  
        if check_exit_code and exit_status != 0:  
            raise ProcessExecutionError(exit_code=exit_status,  
                                        stdout=sanitized_stdout,  
                                        stderr=sanitized_stderr,  
                                        cmd=sanitized_cmd) # HERE IS THE INTERNAL SINK 3  
  
    return (sanitized_stdout, sanitized_stderr)  
  
```  
``` Python  
# https://github.com/openstack/cinder/blob/5e4e1f7ea71f9b4c7bd15809c58bc7a1838ed567/cinder/brick/iscsi/iscsi.py#L490-L533  
  
    def create_iscsi_target(self, name, tid, lun, path,  
                            chap_auth=None, **kwargs):  
        # tid and lun are not used  
  
        vol_id = name.split(':')[1]  
  
        LOG.info(_('Creating iscsi_target for volume: %s') % vol_id)  
  
        # rtstool requires chap_auth, but unit tests don't provide it  
        chap_auth_userid = 'test_id'  
        chap_auth_password = 'test_pass'  
  
        if chap_auth is not None:  
            (chap_auth_userid, chap_auth_password) = chap_auth.split(' ')[1:]  
  
        extra_args = []  
        if self.lio_initiator_iqns:  
            extra_args.append(self.lio_initiator_iqns)  
  
        try:  
            command_args = ['cinder-rtstool',  
                            'create',  
                            path,  
                            name,  
                            chap_auth_userid,  
                            chap_auth_password]  
            if extra_args:  
                command_args.extend(extra_args)  
            self._execute(*command_args, run_as_root=True)  
        except putils.ProcessExecutionError as e:  
            LOG.error(_("Failed to create iscsi target for volume "  
                        "id:%s.") % vol_id)  
            LOG.error("%s" % e) # HERE IS THE SINK 3  
  
            raise exception.ISCSITargetCreateFailed(volume_id=vol_id)  
  
        iqn = '%s%s' % (self.iscsi_target_prefix, vol_id)  
        tid = self._get_target(iqn)  
        if tid is None:  
            LOG.error(_("Failed to create iscsi target for volume "  
                        "id:%s.") % vol_id)  
            raise exception.NotFound()  
  
        return tid  
  
```  
