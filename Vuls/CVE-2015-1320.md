## Summary:  
Software: metal_as_a_service  
## Fix:  
Commit: https://github.com/maas/maas/commit/58996427be1e90a169d887b07e3f60363d462a9c  
Fix Time (of the Last Commit): 2015-03-05  
Author: Mike Pontillo  
Fix Pattern: Remove -> Logging Variables  
  
  
  
Fixing-commits Count: 2  
Total Change Size: +4 -7  
  
========  
Commit: https://github.com/maas/maas/commit/58996427be1e90a169d887b07e3f60363d462a9c  
Change Size: +3 -4  
Time: 2015-03-05  
Author: Mike Pontillo  
Commit: https://github.com/maas/maas/commit/378d48785e2b375a532eaa0ecf8e4a6287d3e192  
Change Size: +1 -3  
Time: 2015-03-06  
Author: Mike Pontillo  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> credentials, including username and password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Logging Statements -> Variable Names（password）|String Literals（password，finally outputed to logs）  
#### Sink 2:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Same Methods & Cross Statements（https://github.com/maas/maas/blob/8471a87397c8c45eef0b982ad26aece4731ea567/src/provisioningserver/drivers/hardware/seamicro.py#L291）-> Variable Names（password）|String Literals（power_pass,finally outputed to logs）  
Programming Language:Python  
```python  
# https://github.com/maas/maas/blob/8471a87397c8c45eef0b982ad26aece4731ea567/src/provisioningserver/drivers/hardware/seamicro.py#L278  
  
@synchronous  
def probe_seamicro15k_and_enlist(user, ip, username, password,  
                                 power_control=None, accept_all=False):  
    power_control = power_control or 'ipmi'  
  
    maaslog.info(  
        "Probing for seamicro15k nodes with arguments "  
        "ip=%s, username=%s, password=%s, power_control=%s",  
        ip, username, password, power_control) # HERE IS THE SINK 1  
    servers = find_seamicro15k_servers(ip, username, password, power_control)  
    for system_id, macs in servers:  
        params = {  
            'power_address': ip,  
            'power_user': username,  
            'power_pass': password,  
            'power_control': power_control,  
            'system_id': system_id  
        }  
        maaslog.info(  
            "Found seamicro15k node with macs %s; adding to MAAS with "  
            "params : %s", macs, params) # HERE IS THE SINK 2  
        system_id = create_node(macs, 'amd64', 'sm15k', params).wait(30)  
  
        if accept_all:  
            commission_node(system_id, user).wait(30)  
  
# https://github.com/maas/maas/blob/31a95206afe563012c48a20bcd8492fa32c7f405/src/provisioningserver/rpc/clusterservice.py#L762-L898  
@cluster.AddChassis.responder  
    def add_chassis(  
        self,  
        user,  
        chassis_type,  
        hostname,  
        username=None,  
        password=None,  
        accept_all=False,  
        domain=None,  
        prefix_filter=None,  
        power_control=None,  
        port=None,  
        protocol=None,  
        token_name=None,  
        token_secret=None,  
        verify_ssl=False,  
    ):  
        """AddChassis()  
        Implementation of  
        :py:class:`~provisioningserver.rpc.cluster.AddChassis`.  
        """  
        if chassis_type in ("virsh", "powerkvm"):  
            d = deferToThread(  
                probe_virsh_and_enlist,  
                user,  
                hostname,  
                password,  
                prefix_filter,  
                accept_all,  
                domain,  
            )  
            d.addErrback(partial(catch_probe_and_enlist_error, "virsh"))  
# OMIT FOR SIMPLICITY  
            elif chassis_type == "seamicro15k":  
            d = deferToThread(  
                probe_seamicro15k_and_enlist,  
                user,  
                hostname,  
                username,  
                password,  
                power_control,  
                accept_all,  
                domain,  
            ) # HERE IS THE FLOW  
            d.addErrback(  
                partial(catch_probe_and_enlist_error, "SeaMicro 15000")  
            )  
# OMIT FOR SIMPLICITY  
  
  
# https://github.com/maas/maas/blob/31a95206afe563012c48a20bcd8492fa32c7f405/src/maasserver/api/machines.py#L2568-L2844  
  
    @admin_method  
    @operation(idempotent=False)  
    def add_chassis(self, request):  
        """@description-title Add special hardware  
        @description Add special hardware types.  
        @param (string) "chassis_type" [required=true,formatting=true] The type  
        of hardware:  
        - ``hmcz``: IBM Hardware Management Console (HMC) for Z  
        - ``mscm``: Moonshot Chassis Manager.  
        - ``msftocs``: Microsoft OCS Chassis Manager.  
        - ``powerkvm``: Virtual Machines on Power KVM, managed by Virsh.  
        - ``proxmox``: Virtual Machines managed by Proxmox  
        - ``recs_box``: Christmann RECS|Box servers.  
        - ``sm15k``: Seamicro 1500 Chassis.  
        - ``ucsm``: Cisco UCS Manager.  
        - ``virsh``: virtual machines managed by Virsh.  
        - ``vmware`` is the type for virtual machines managed by VMware.  
        @param (string) "hostname" [required=true] The URL, hostname, or IP  
        address to access the chassis.  
        @param (string) "username" [required=false] The username used to access  
        the chassis. This field is required for the recs_box, seamicro15k,  
        vmware, mscm, msftocs, ucsm, and hmcz chassis types.  
        @param (string) "password" [required=false] The password used to access  
        the chassis. This field is required for the ``recs_box``,  
        ``seamicro15k``, ``vmware``, ``mscm``, ``msftocs``, ``ucsm``, and  
        ``hmcz`` chassis types.  
        @param (string) "accept_all" [required=false] If true, all enlisted  
        machines will be commissioned.  
        @param (string) "rack_controller" [required=false] The system_id of the  
        rack controller to send the add chassis command through. If none is  
        specifed MAAS will automatically determine the rack controller to use.  
        @param (string) "domain" [required=false] The domain that each new  
        machine added should use.  
        @param (string) "prefix_filter" [required=false] (``virsh``,  
        ``vmware``, ``powerkvm``, ``proxmox``, ``hmcz`` only.) Filter machines  
        with supplied prefix.  
        @param (string) "power_control" [required=false] (``seamicro15k`` only)  
        The power_control to use, either ipmi (default), restapi, or restapi2.  
        The following are optional if you are adding a proxmox chassis.  
        @param (string) "token_name" [required=false] The name the  
        authentication token to be used instead of a password.  
        @param (string) "token_secret" [required=false] The token secret  
        to be used in combination with the power_token_name used in place of  
        a password.  
        @param (boolean) "verify_ssl" [required=false] Whether SSL  
        connections should be verified.  
        The following are optional if you are adding a recs_box, vmware or  
        msftocs chassis.  
        @param (int) "port" [required=false] (``recs_box``, ``vmware``,  
        ``msftocs`` only) The port to use when accessing the chassis.  
        The following are optional if you are adding a vmware chassis:  
        @param (string) "protocol" [required=false] (``vmware`` only) The  
        protocol to use when accessing the VMware chassis (default: https).  
        :return: A string containing the chassis powered on by which rack  
            controller.  
        @success (http-status-code) "200" 200  
        @success (content) "success-content"  
            Asking maas-run to add machines from chassis  
        @error (http-status-code) "403" 403  
        @error (content) "no-perms" The user does not have permission to  
        access the rack controller.  
        @error (http-status-code) "404" 404  
        @error (content) "not-found" No rack controller can be found that has  
        access to the given URL.  
        @error-example "not-found"  
            Not Found  
        @error (http-status-code) "400" 400  
        @error (content) "bad-params" Required parameters are missing.  
        """  
  
        chassis_type = self._get_chassis_param(request)  
  
        hostname = get_mandatory_param(request.POST, "hostname")  
  
        if chassis_type in (  
            "hmcz",  
            "mscm",  
            "msftocs",  
            "recs_box",  
            "seamicro15k",  
            "ucsm",  
            "vmware",  
        ):  
            username = get_mandatory_param(request.POST, "username")  
            password = get_mandatory_param(request.POST, "password") # HERE IS THE SOURCE  
            token_name = None  
            token_secret = None  
        elif chassis_type == "proxmox":  
            username = get_mandatory_param(request.POST, "username")  
            password = get_optional_param(request.POST, "password")  
            token_name = get_optional_param(request.POST, "token_name")  
            token_secret = get_optional_param(request.POST, "token_secret")  
            if not any([password, token_name, token_secret]):  
                return HttpResponseBadRequest(  
                    "You must use a password or token with Proxmox."  
                )  
            elif all([password, token_name, token_secret]):  
                return HttpResponseBadRequest(  
                    "You may only use a password or token with Proxmox, "  
                    "not both."  
                )  
            elif password is None and not all([token_name, token_secret]):  
                return HttpResponseBadRequest(  
                    "Proxmox requires both a token_name and token_secret."  
                )  
        else:  
            username = get_optional_param(request.POST, "username")  
            password = get_optional_param(request.POST, "password")  
            token_name = None  
            token_secret = None  
            if username is not None and chassis_type in ("powerkvm", "virsh"):  
                return HttpResponseBadRequest(  
                    "username can not be specified when using the %s chassis."  
                    % chassis_type,  
                    content_type=(  
                        "text/plain; charset=%s" % settings.DEFAULT_CHARSET  
                    ),  
                )  
  
        accept_all = get_optional_param(request.POST, "accept_all")  
        if isinstance(accept_all, str):  
            accept_all = accept_all.lower() == "true"  
        else:  
            accept_all = False  
  
        # Only available with virsh, vmware, powerkvm, and proxmox  
        prefix_filter = get_optional_param(request.POST, "prefix_filter")  
        if prefix_filter is not None and chassis_type not in (  
            "hmcz",  
            "powerkvm",  
            "virsh",  
            "vmware",  
            "proxmox",  
        ):  
            return HttpResponseBadRequest(  
                "prefix_filter is unavailable with the %s chassis type"  
                % chassis_type,  
                content_type=(  
                    "text/plain; charset=%s" % settings.DEFAULT_CHARSET  
                ),  
            )  
  
        # Only available with seamicro15k  
        power_control = get_optional_param(  
            request.POST,  
            "power_control",  
            validator=validators.OneOf(["ipmi", "restapi", "restapi2"]),  
        )  
        if power_control is not None and chassis_type != "seamicro15k":  
            return HttpResponseBadRequest(  
                "power_control is unavailable with the %s chassis type"  
                % chassis_type,  
                content_type=(  
                    "text/plain; charset=%s" % settings.DEFAULT_CHARSET  
                ),  
            )  
  
        # Only available with vmware, recs_box or msftocs  
        port = get_optional_param(  
            request.POST, "port", validator=validators.Int(min=1, max=65535)  
        )  
        if port is not None and chassis_type not in (  
            "msftocs",  
            "recs_box",  
            "vmware",  
        ):  
            return HttpResponseBadRequest(  
                "port is unavailable with the %s chassis type" % chassis_type,  
                content_type=(  
                    "text/plain; charset=%s" % settings.DEFAULT_CHARSET  
                ),  
            )  
  
        # Only available with vmware  
        protocol = get_optional_param(request.POST, "protocol")  
        if protocol is not None and chassis_type != "vmware":  
            return HttpResponseBadRequest(  
                "protocol is unavailable with the %s chassis type"  
                % chassis_type,  
                content_type=(  
                    "text/plain; charset=%s" % settings.DEFAULT_CHARSET  
                ),  
            )  
  
        verify_ssl = get_optional_param(  
            request.POST, "verify_ssl", default=False, validator=StringBool  
        )  
  
        # If given a domain make sure it exists first  
        domain_name = get_optional_param(request.POST, "domain")  
        if domain_name is not None:  
            try:  
                domain = Domain.objects.get(id=int(domain_name))  
            except ValueError:  
                try:  
                    domain = Domain.objects.get(name=domain_name)  
                except Domain.DoesNotExist:  
                    return HttpResponseNotFound(  
                        "Unable to find specified domain %s" % domain_name  
                    )  
            domain_name = domain.name  
  
        rack_controller = get_optional_param(request.POST, "rack_controller")  
        if rack_controller is None:  
            rack = RackController.objects.get_accessible_by_url(hostname)  
            if rack:  
                racks = [rack]  
            else:  
                racks = RackController.objects.all()  
        else:  
            try:  
                racks = [  
                    RackController.objects.get(  
                        Q(system_id=rack_controller)  
                        | Q(hostname=rack_controller)  
                    )  
                ]  
            except RackController.DoesNotExist:  
                return HttpResponseNotFound(  
                    "Unable to find specified rack %s" % rack_controller,  
                    content_type=(  
                        "text/plain; charset=%s" % settings.DEFAULT_CHARSET  
                    ),  
                )  
  
        # Ask all racks to add the chassis. add_chassis() is kind of  
        # idempotent, so nodes won't be added multiple times by  
        # different racks.  
        for rack in racks:  
            # Ideally we should break after the first rack managed to  
            # add the chassis. But currently add_chassis() doesn't  
            # return whether it succeeds.  
            rack.add_chassis(  
                request.user.username,  
                chassis_type,  
                hostname,  
                username,  
                password,  
                accept_all,  
                domain_name,  
                prefix_filter,  
                power_control,  
                port,  
                protocol,  
                token_name,  
                token_secret,  
                verify_ssl,  
            ) # HERE IS THE FLOW  
  
        return HttpResponse(  
            "Asking %s to add machines from chassis %s"  
            % (", ".join(rack.hostname for rack in racks), hostname),  
            content_type=("text/plain; charset=%s" % settings.DEFAULT_CHARSET),  
        )  
  
```  
