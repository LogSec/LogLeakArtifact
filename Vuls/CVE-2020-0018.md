## Summary:  
Software: android  
## Fix:  
Commit: https://android.googlesource.com/platform/frameworks/native/+/7fb8682cbf494e3f1d5c79ebfbd9b020e1191679  
Change Size: +unkonwn -unkonwn  
Change Size: +2 -49  
Author: Ashwini Oruganti  
Fix Time (of the Last Commit): 2019-12-04  
  
Fix Pattern: Remove -> Logging Variables  
Fixing-commits Count: 1  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:users' behavior data -> sensitive information  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（logDispatchStateLocked）  
Sensitiveness-Identifiable Source:  No  
#### Sink 2:  
Logging call Function:  User-defined（logDispatchStateLocked）  
Sensitiveness-Identifiable Source:  No  
#### Sink 3:  
Logging call Function:  User-defined（logDispatchStateLocked）  
Sensitiveness-Identifiable Source:  No  
Programming Language:C/C++  
```C++  
  
// https://android.googlesource.com/platform/frameworks/native/+/daf29a6dbfafc6c06654a3878c0ad2a7f8ebc063/services/inputflinger/InputDispatcher.cpp#3435  
/**  
 * Sets the focused display, which is responsible for receiving focus-dispatched input events where  
 * the display not specified.  
 *  
 * We track any unreleased events for each window. If a window loses the ability to receive the  
 * released event, we will send a cancel event to it. So when the focused display is changed, we  
 * cancel all the unreleased display-unspecified events for the focused window on the old focused  
 * display. The display-specified events won't be affected.  
 */  
void InputDispatcher::setFocusedDisplay(int32_t displayId) {  
#if DEBUG_FOCUS  
    ALOGD("setFocusedDisplay displayId=%" PRId32, displayId);  
#endif  
    { // acquire lock  
        std::scoped_lock _l(mLock);  
        if (mFocusedDisplayId != displayId) {  
            sp<InputWindowHandle> oldFocusedWindowHandle =  
                    getValueByKey(mFocusedWindowHandlesByDisplay, mFocusedDisplayId);  
            if (oldFocusedWindowHandle != nullptr) {  
                sp<InputChannel> inputChannel =  
                    getInputChannelLocked(oldFocusedWindowHandle->getToken());  
                if (inputChannel != nullptr) {  
                    CancelationOptions options(  
                            CancelationOptions::CANCEL_NON_POINTER_EVENTS,  
                            "The display which contains this window no longer has focus.");  
                    options.displayId = ADISPLAY_ID_NONE;  
                    synthesizeCancelationEventsForInputChannelLocked(inputChannel, options);  
                }  
            }  
            mFocusedDisplayId = displayId;  
            // Sanity check  
            sp<InputWindowHandle> newFocusedWindowHandle =  
                    getValueByKey(mFocusedWindowHandlesByDisplay, displayId);  
            onFocusChangedLocked(oldFocusedWindowHandle, newFocusedWindowHandle);  
            if (newFocusedWindowHandle == nullptr) {  
                ALOGW("Focused display #%" PRId32 " does not have a focused window.", displayId);  
                if (!mFocusedWindowHandlesByDisplay.empty()) {  
                    ALOGE("But another display has a focused window:");  
                    for (auto& it : mFocusedWindowHandlesByDisplay) {  
                        const int32_t displayId = it.first;  
                        const sp<InputWindowHandle>& windowHandle = it.second;  
                        ALOGE("Display #%" PRId32 " has focused window: '%s'\n",  
                                displayId, windowHandle->getName().c_str());  
                    }  
                }  
            }  
        }  
#if DEBUG_FOCUS  
        logDispatchStateLocked(); // HERE IS THE SINK 1  
#endif  
    } // release lock  
    // Wake up poll loop since it may need to make new input dispatching choices.  
    mLooper->wake();  
}  
  
// https://android.googlesource.com/platform/frameworks/native/+/daf29a6dbfafc6c06654a3878c0ad2a7f8ebc063/services/inputflinger/InputDispatcher.cpp#3469  
  
void InputDispatcher::setInputDispatchMode(bool enabled, bool frozen) {  
#if DEBUG_FOCUS  
    ALOGD("setInputDispatchMode: enabled=%d, frozen=%d", enabled, frozen);  
#endif  
    bool changed;  
    { // acquire lock  
        std::scoped_lock _l(mLock);  
        if (mDispatchEnabled != enabled || mDispatchFrozen != frozen) {  
            if (mDispatchFrozen && !frozen) {  
                resetANRTimeoutsLocked();  
            }  
            if (mDispatchEnabled && !enabled) {  
                resetAndDropEverythingLocked("dispatcher is being disabled");  
            }  
            mDispatchEnabled = enabled;  
            mDispatchFrozen = frozen;  
            changed = true;  
        } else {  
            changed = false;  
        }  
#if DEBUG_FOCUS  
        logDispatchStateLocked(); // HERE IS THE SINK 2  
#endif  
    } // release lock  
    if (changed) {  
        // Wake up poll loop since it may need to make new input dispatching choices.  
        mLooper->wake();  
    }  
}  
  
// https://android.googlesource.com/platform/frameworks/native/+/daf29a6dbfafc6c06654a3878c0ad2a7f8ebc063/services/inputflinger/InputDispatcher.cpp#3573  
bool InputDispatcher::transferTouchFocus(const sp<IBinder>& fromToken, const sp<IBinder>& toToken) {  
    if (fromToken == toToken) {  
#if DEBUG_FOCUS  
        ALOGD("Trivial transfer to same window.");  
#endif  
        return true;  
    }  
    { // acquire lock  
        std::scoped_lock _l(mLock);  
        sp<InputWindowHandle> fromWindowHandle = getWindowHandleLocked(fromToken);  
        sp<InputWindowHandle> toWindowHandle = getWindowHandleLocked(toToken);  
        if (fromWindowHandle == nullptr || toWindowHandle == nullptr) {  
            ALOGW("Cannot transfer focus because from or to window not found.");  
            return false;  
        }  
#if DEBUG_FOCUS  
        ALOGD("transferTouchFocus: fromWindowHandle=%s, toWindowHandle=%s",  
            fromWindowHandle->getName().c_str(), toWindowHandle->getName().c_str());  
#endif  
        if (fromWindowHandle->getInfo()->displayId != toWindowHandle->getInfo()->displayId) {  
#if DEBUG_FOCUS  
            ALOGD("Cannot transfer focus because windows are on different displays.");  
#endif  
            return false;  
        }  
        bool found = false;  
        for (size_t d = 0; d < mTouchStatesByDisplay.size(); d++) {  
            TouchState& state = mTouchStatesByDisplay.editValueAt(d);  
            for (size_t i = 0; i < state.windows.size(); i++) {  
                const TouchedWindow& touchedWindow = state.windows[i];  
                if (touchedWindow.windowHandle == fromWindowHandle) {  
                    int32_t oldTargetFlags = touchedWindow.targetFlags;  
                    BitSet32 pointerIds = touchedWindow.pointerIds;  
                    state.windows.erase(state.windows.begin() + i);  
                    int32_t newTargetFlags = oldTargetFlags  
                            & (InputTarget::FLAG_FOREGROUND  
                                    | InputTarget::FLAG_SPLIT | InputTarget::FLAG_DISPATCH_AS_IS);  
                    state.addOrUpdateWindow(toWindowHandle, newTargetFlags, pointerIds);  
                    found = true;  
                    goto Found;  
                }  
            }  
        }  
Found:  
        if (! found) {  
#if DEBUG_FOCUS  
            ALOGD("Focus transfer failed because from window did not have focus.");  
#endif  
            return false;  
        }  
        sp<InputChannel> fromChannel = getInputChannelLocked(fromToken);  
        sp<InputChannel> toChannel = getInputChannelLocked(toToken);  
        ssize_t fromConnectionIndex = getConnectionIndexLocked(fromChannel);  
        ssize_t toConnectionIndex = getConnectionIndexLocked(toChannel);  
        if (fromConnectionIndex >= 0 && toConnectionIndex >= 0) {  
            sp<Connection> fromConnection = mConnectionsByFd.valueAt(fromConnectionIndex);  
            sp<Connection> toConnection = mConnectionsByFd.valueAt(toConnectionIndex);  
            fromConnection->inputState.copyPointerStateTo(toConnection->inputState);  
            CancelationOptions options(CancelationOptions::CANCEL_POINTER_EVENTS,  
                    "transferring touch focus from this window to another window");  
            synthesizeCancelationEventsForConnectionLocked(fromConnection, options);  
        }  
#if DEBUG_FOCUS  
        logDispatchStateLocked(); // HERE IS THE SINK 3  
#endif  
    } // release lock  
    // Wake up poll loop since it may need to make new input dispatching choices.  
    mLooper->wake();  
    return true;  
}  
  
// https://android.googlesource.com/platform/frameworks/native/+/daf29a6dbfafc6c06654a3878c0ad2a7f8ebc063/services/inputflinger/InputDispatcher.cpp#3600  
  
void InputDispatcher::logDispatchStateLocked() {  
    std::string dump;  
    dumpDispatchStateLocked(dump);  
    std::istringstream stream(dump);  
    std::string line;  
    while (std::getline(stream, line, '\n')) {  
        ALOGD("%s", line.c_str()); // HERE IS THE INNER SINK  
    }  
}  
  
// https://android.googlesource.com/platform/frameworks/native/+/daf29a6dbfafc6c06654a3878c0ad2a7f8ebc063/services/inputflinger/InputDispatcher.cpp#3612  
  
void InputDispatcher::dumpDispatchStateLocked(std::string& dump) {  
    dump += StringPrintf(INDENT "DispatchEnabled: %s\n", toString(mDispatchEnabled));  
    dump += StringPrintf(INDENT "DispatchFrozen: %s\n", toString(mDispatchFrozen));  
    dump += StringPrintf(INDENT "InputFilterEnabled: %s\n", toString(mInputFilterEnabled));  
    dump += StringPrintf(INDENT "FocusedDisplayId: %" PRId32 "\n", mFocusedDisplayId);  
    if (!mFocusedApplicationHandlesByDisplay.empty()) {  
        dump += StringPrintf(INDENT "FocusedApplications:\n");  
        for (auto& it : mFocusedApplicationHandlesByDisplay) {  
            const int32_t displayId = it.first;  
            const sp<InputApplicationHandle>& applicationHandle = it.second;  
            dump += StringPrintf(  
                    INDENT2 "displayId=%" PRId32 ", name='%s', dispatchingTimeout=%0.3fms\n",  
                    displayId,  
                    applicationHandle->getName().c_str(),  
                    applicationHandle->getDispatchingTimeout(  
                            DEFAULT_INPUT_DISPATCHING_TIMEOUT) / 1000000.0);  
        }  
    } else {  
        dump += StringPrintf(INDENT "FocusedApplications: <none>\n");  
    }  
    if (!mFocusedWindowHandlesByDisplay.empty()) {  
        dump += StringPrintf(INDENT "FocusedWindows:\n");  
        for (auto& it : mFocusedWindowHandlesByDisplay) {  
            const int32_t displayId = it.first;  
            const sp<InputWindowHandle>& windowHandle = it.second;  
            dump += StringPrintf(INDENT2 "displayId=%" PRId32 ", name='%s'\n",  
                    displayId, windowHandle->getName().c_str());  
        }  
    } else {  
        dump += StringPrintf(INDENT "FocusedWindows: <none>\n");  
    }  
    if (!mTouchStatesByDisplay.isEmpty()) {  
        dump += StringPrintf(INDENT "TouchStatesByDisplay:\n");  
        for (size_t i = 0; i < mTouchStatesByDisplay.size(); i++) {  
            const TouchState& state = mTouchStatesByDisplay.valueAt(i);  
            dump += StringPrintf(INDENT2 "%d: down=%s, split=%s, deviceId=%d, source=0x%08x\n",  
                    state.displayId, toString(state.down), toString(state.split),  
                    state.deviceId, state.source);  
            if (!state.windows.empty()) {  
                dump += INDENT3 "Windows:\n";  
                for (size_t i = 0; i < state.windows.size(); i++) {  
                    const TouchedWindow& touchedWindow = state.windows[i];  
                    dump += StringPrintf(INDENT4 "%zu: name='%s', pointerIds=0x%0x, targetFlags=0x%x\n",  
                            i, touchedWindow.windowHandle->getName().c_str(),  
                            touchedWindow.pointerIds.value,  
                            touchedWindow.targetFlags);  
                }  
            } else {  
                dump += INDENT3 "Windows: <none>\n";  
            }  
            if (!state.portalWindows.empty()) {  
                dump += INDENT3 "Portal windows:\n";  
                for (size_t i = 0; i < state.portalWindows.size(); i++) {  
                    const sp<InputWindowHandle> portalWindowHandle = state.portalWindows[i];  
                    dump += StringPrintf(INDENT4 "%zu: name='%s'\n",  
                            i, portalWindowHandle->getName().c_str());  
                }  
            }  
        }  
    } else {  
        dump += INDENT "TouchStates: <no displays touched>\n";  
    }  
    if (!mWindowHandlesByDisplay.empty()) {  
       for (auto& it : mWindowHandlesByDisplay) {  
            const std::vector<sp<InputWindowHandle>> windowHandles = it.second;  
            dump += StringPrintf(INDENT "Display: %" PRId32 "\n", it.first);  
            if (!windowHandles.empty()) {  
                dump += INDENT2 "Windows:\n";  
                for (size_t i = 0; i < windowHandles.size(); i++) {  
                    const sp<InputWindowHandle>& windowHandle = windowHandles[i];  
                    const InputWindowInfo* windowInfo = windowHandle->getInfo();  
                    dump += StringPrintf(INDENT3 "%zu: name='%s', displayId=%d, "  
                            "portalToDisplayId=%d, paused=%s, hasFocus=%s, hasWallpaper=%s, "  
                            "visible=%s, canReceiveKeys=%s, flags=0x%08x, type=0x%08x, layer=%d, "  
                            "frame=[%d,%d][%d,%d], globalScale=%f, windowScale=(%f,%f), "  
                            "touchableRegion=",  
                            i, windowInfo->name.c_str(), windowInfo->displayId,  
                            windowInfo->portalToDisplayId,  
                            toString(windowInfo->paused),  
                            toString(windowInfo->hasFocus),  
                            toString(windowInfo->hasWallpaper),  
                            toString(windowInfo->visible),  
                            toString(windowInfo->canReceiveKeys),  
                            windowInfo->layoutParamsFlags, windowInfo->layoutParamsType,  
                            windowInfo->layer,  
                            windowInfo->frameLeft, windowInfo->frameTop,  
                            windowInfo->frameRight, windowInfo->frameBottom,  
                            windowInfo->globalScaleFactor,  
                            windowInfo->windowXScale, windowInfo->windowYScale);  
                    dumpRegion(dump, windowInfo->touchableRegion);  
                    dump += StringPrintf(", inputFeatures=0x%08x", windowInfo->inputFeatures);  
                    dump += StringPrintf(", ownerPid=%d, ownerUid=%d, dispatchingTimeout=%0.3fms\n",  
                            windowInfo->ownerPid, windowInfo->ownerUid,  
                            windowInfo->dispatchingTimeout / 1000000.0);  
                }  
            } else {  
                dump += INDENT2 "Windows: <none>\n";  
            }  
        }  
    } else {  
        dump += INDENT "Displays: <none>\n";  
    }  
    if (!mGlobalMonitorsByDisplay.empty() || !mGestureMonitorsByDisplay.empty()) {  
       for (auto& it : mGlobalMonitorsByDisplay) {  
            const std::vector<Monitor>& monitors = it.second;  
            dump += StringPrintf(INDENT "Global monitors in display %" PRId32 ":\n", it.first);  
            dumpMonitors(dump, monitors);  
       }  
       for (auto& it : mGestureMonitorsByDisplay) {  
            const std::vector<Monitor>& monitors = it.second;  
            dump += StringPrintf(INDENT "Gesture monitors in display %" PRId32 ":\n", it.first);  
            dumpMonitors(dump, monitors);  
       }  
    } else {  
        dump += INDENT "Monitors: <none>\n";  
    }  
    nsecs_t currentTime = now();  
    // Dump recently dispatched or dropped events from oldest to newest.  
    if (!mRecentQueue.isEmpty()) {  
        dump += StringPrintf(INDENT "RecentQueue: length=%u\n", mRecentQueue.count());  
        for (EventEntry* entry = mRecentQueue.head; entry; entry = entry->next) {  
            dump += INDENT2;  
            entry->appendDescription(dump);  
            dump += StringPrintf(", age=%0.1fms\n",  
                    (currentTime - entry->eventTime) * 0.000001f);  
        }  
    } else {  
        dump += INDENT "RecentQueue: <empty>\n";  
    }  
    // Dump event currently being dispatched.  
    if (mPendingEvent) {  
        dump += INDENT "PendingEvent:\n";  
        dump += INDENT2;  
        mPendingEvent->appendDescription(dump);  
        dump += StringPrintf(", age=%0.1fms\n",  
                (currentTime - mPendingEvent->eventTime) * 0.000001f);  
    } else {  
        dump += INDENT "PendingEvent: <none>\n";  
    }  
    // Dump inbound events from oldest to newest.  
    if (!mInboundQueue.isEmpty()) {  
        dump += StringPrintf(INDENT "InboundQueue: length=%u\n", mInboundQueue.count());  
        for (EventEntry* entry = mInboundQueue.head; entry; entry = entry->next) {  
            dump += INDENT2;  
            entry->appendDescription(dump);  
            dump += StringPrintf(", age=%0.1fms\n",  
                    (currentTime - entry->eventTime) * 0.000001f);  
        }  
    } else {  
        dump += INDENT "InboundQueue: <empty>\n";  
    }  
    if (!mReplacedKeys.isEmpty()) {  
        dump += INDENT "ReplacedKeys:\n";  
        for (size_t i = 0; i < mReplacedKeys.size(); i++) {  
            const KeyReplacement& replacement = mReplacedKeys.keyAt(i);  
            int32_t newKeyCode = mReplacedKeys.valueAt(i);  
            dump += StringPrintf(INDENT2 "%zu: originalKeyCode=%d, deviceId=%d, newKeyCode=%d\n",  
                    i, replacement.keyCode, replacement.deviceId, newKeyCode);  
        }  
    } else {  
        dump += INDENT "ReplacedKeys: <empty>\n";  
    }  
    if (!mConnectionsByFd.isEmpty()) {  
        dump += INDENT "Connections:\n";  
        for (size_t i = 0; i < mConnectionsByFd.size(); i++) {  
            const sp<Connection>& connection = mConnectionsByFd.valueAt(i);  
            dump += StringPrintf(INDENT2 "%zu: channelName='%s', windowName='%s', "  
                    "status=%s, monitor=%s, inputPublisherBlocked=%s\n",  
                    i, connection->getInputChannelName().c_str(),  
                    connection->getWindowName().c_str(),  
                    connection->getStatusLabel(), toString(connection->monitor),  
                    toString(connection->inputPublisherBlocked));  
            if (!connection->outboundQueue.isEmpty()) {  
                dump += StringPrintf(INDENT3 "OutboundQueue: length=%u\n",  
                        connection->outboundQueue.count());  
                for (DispatchEntry* entry = connection->outboundQueue.head; entry;  
                        entry = entry->next) {  
                    dump.append(INDENT4);  
                    entry->eventEntry->appendDescription(dump);  
                    dump += StringPrintf(", targetFlags=0x%08x, resolvedAction=%d, age=%0.1fms\n",  
                            entry->targetFlags, entry->resolvedAction,  
                            (currentTime - entry->eventEntry->eventTime) * 0.000001f);  
                }  
            } else {  
                dump += INDENT3 "OutboundQueue: <empty>\n";  
            }  
            if (!connection->waitQueue.isEmpty()) {  
                dump += StringPrintf(INDENT3 "WaitQueue: length=%u\n",  
                        connection->waitQueue.count());  
                for (DispatchEntry* entry = connection->waitQueue.head; entry;  
                        entry = entry->next) {  
                    dump += INDENT4;  
                    entry->eventEntry->appendDescription(dump);  
                    dump += StringPrintf(", targetFlags=0x%08x, resolvedAction=%d, "  
                            "age=%0.1fms, wait=%0.1fms\n",  
                            entry->targetFlags, entry->resolvedAction,  
                            (currentTime - entry->eventEntry->eventTime) * 0.000001f,  
                            (currentTime - entry->deliveryTime) * 0.000001f);  
                }  
            } else {  
                dump += INDENT3 "WaitQueue: <empty>\n";  
            }  
        }  
    } else {  
        dump += INDENT "Connections: <none>\n";  
    }  
    if (isAppSwitchPendingLocked()) {  
        dump += StringPrintf(INDENT "AppSwitch: pending, due in %0.1fms\n",  
                (mAppSwitchDueTime - now()) / 1000000.0);  
    } else {  
        dump += INDENT "AppSwitch: not pending\n";  
    }  
    dump += INDENT "Configuration:\n";  
    dump += StringPrintf(INDENT2 "KeyRepeatDelay: %0.1fms\n",  
            mConfig.keyRepeatDelay * 0.000001f);  
    dump += StringPrintf(INDENT2 "KeyRepeatTimeout: %0.1fms\n",  
            mConfig.keyRepeatTimeout * 0.000001f);  
}  
  
// https://android.googlesource.com/platform/frameworks/native/+/daf29a6dbfafc6c06654a3878c0ad2a7f8ebc063/services/inputflinger/InputDispatcher.cpp#4616  
  
void InputDispatcher::KeyEntry::appendDescription(std::string& msg) const {  
    msg += StringPrintf("KeyEvent(deviceId=%d, source=0x%08x, displayId=%" PRId32 ", action=%s, "  
            "flags=0x%08x, keyCode=%d, scanCode=%d, metaState=0x%08x, "  
            "repeatCount=%d), policyFlags=0x%08x",  
            deviceId, source, displayId, keyActionToString(action).c_str(), flags, keyCode,  
            scanCode, metaState, repeatCount, policyFlags);  
}  
  
// https://android.googlesource.com/platform/frameworks/native/+/daf29a6dbfafc6c06654a3878c0ad2a7f8ebc063/services/inputflinger/InputDispatcher.cpp#4663  
  
void InputDispatcher::MotionEntry::appendDescription(std::string& msg) const {  
    msg += StringPrintf("MotionEvent(deviceId=%d, source=0x%08x, displayId=%" PRId32  
            ", action=%s, actionButton=0x%08x, flags=0x%08x, metaState=0x%08x, buttonState=0x%08x, "  
            "classification=%s, edgeFlags=0x%08x, xPrecision=%.1f, yPrecision=%.1f, pointers=[",  
            deviceId, source, displayId, motionActionToString(action).c_str(), actionButton, flags,  
            metaState, buttonState, motionClassificationToString(classification), edgeFlags,  
            xPrecision, yPrecision);  
    for (uint32_t i = 0; i < pointerCount; i++) {  
        if (i) {  
            msg += ", ";  
        }  
        msg += StringPrintf("%d: (%.1f, %.1f)", pointerProperties[i].id,  
                pointerCoords[i].getX(), pointerCoords[i].getY());  
    }  
    msg += StringPrintf("]), policyFlags=0x%08x", policyFlags);  
}  
  
  
```  
