## Summary:  
Software: opensuse  
## Fix:  
Commit: https://github.com/yast/yast-network/commit/e5f6f07332d25703b249f7c8955597075a2d7a09  
Change Size: +5 -1  
Fix Time (of the Last Commit): 2012-09-05  
Author: mchf  
Fix Pattern: Disable Logging in Default (日志等级) | Redaction -> Reuse -> Keyword/RegexBasedFiltration -> RedactionFunctionDefined  
  
Fixing-commits Count: 1  
Total Change Size: +5 -1  
## Sample logs: Yes  
```  
YaST2/y2log:2012-03-15 10:20:24 <5> indian(11489) [YCP] LanItems.ycp:1191 $["BOOTPROTO":"dhcp", "BROADCAST":"", "ETHTOOL_OPTIONS":"", "IFPLUGD_PRIORITY":"0", "IPADDR":"", "MTU":"", "NAME":"WiFi Link 6000 Series", "NETWORK":"", "PREFIXLEN":"32", "REMOTE_IPADDR":"", "STARTMODE":"ifplugd", "USERCONTROL":"no", "WIRELESS_AP":"", "WIRELESS_AP_SCANMODE":"1", "WIRELESS_AUTH_MODE":"eap", "WIRELESS_BITRATE":"auto", "WIRELESS_CA_CERT":"", "WIRELESS_CHANNEL":"", "WIRELESS_CLIENT_CERT":"", "WIRELESS_CLIENT_KEY":"", "WIRELESS_CLIENT_KEY_PASSWORD":"", "WIRELESS_DEFAULT_KEY":"0", "WIRELESS_EAP_AUTH":"PEAP", "WIRELESS_EAP_MODE":"PEAP", "WIRELESS_ESSID":"Novell", "WIRELESS_FREQUENCY":"", "WIRELESS_KEY":"", "WIRELESS_KEY_0":"", "WIRELESS_KEY_1":"", "WIRELESS_KEY_2":"", "WIRELESS_KEY_3":"", "WIRELESS_KEY_LENGTH":"128", "WIRELESS_MODE":"Managed", "WIRELESS_NICK":"", "WIRELESS_NWID":"", "WIRELESS_PEAP_VERSION":"", "WIRELESS_POWER":"no", "WIRELESS_WPA_ANONID":"", "WIRELESS_WPA_IDENTITY":"aspiers", "WIRELESS_WPA_PASSWORD":"[censored :-)]", "WIRELESS_WPA_PSK":"", "_aliases":$[]]  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> Wi-Fi credentials  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（YCP Logging）  
Sensitiveness-Identifiable Source:  Same Methods & Cross Statements（https://github.com/yast/yast-network/blob/7769953968b61c06a37a1a6145584a22947103dc/src/modules/LanItems.ycp#L1129） -> String Literals（WIRELESS_WPA_PASSWORD，finally outputed to logs）  
Programming Language:PHP  
```PHP  
# https://github.com/yast/yast-network/blob/7769953968b61c06a37a1a6145584a22947103dc/src/modules/LanItems.ycp#L1031-L1176  
  
global define boolean Commit() {  
    if(operation == `add || operation == `edit) {  
	map<string,any> newdev = $[];  
  
	// #104494 - always write IPADDR+NETMASK, even empty  
	newdev["IPADDR"] = ipaddr;  
	if(size(prefix)>0) newdev["PREFIXLEN"] = prefix;  
		else newdev["NETMASK"] = netmask;  
	// #50955 omit computable fields  
	newdev["BROADCAST"] = "";  
	newdev["NETWORK"] = "";  
  
	newdev["REMOTE_IPADDR"] = remoteip;  
	if (qeth_layer2) newdev["LLADDR"] = qeth_macaddress;  
  
	if(alias == "") {  
	    newdev["MTU"] = mtu;  
	    newdev["ETHTOOL_OPTIONS"] = ethtool_options;  
	    newdev["STARTMODE"] = startmode;  
	    // it is not in Select yet because we don't have a widget for it  
	    if (startmode == "ifplugd")  
	    {  
/*  
		string prio = ifplugd_priorities[type]:"";  
		newdev["IFPLUGD_PRIORITY"] = prio;  
*/  
		if (ifplugd_priority!=nil)  
			newdev["IFPLUGD_PRIORITY"] = ifplugd_priority;  
		else  
			newdev["IFPLUGD_PRIORITY"] = ifplugd_priorities[type]:"0";  
	    } // else if (haskey(newdev, "IFPLUGD_PRIORITY"))newdev = remove(newdev, "IFPLUGD_PRIORITY");  
	    newdev["USERCONTROL"] = usercontrol? "yes": "no";  
	    newdev["BOOTPROTO"] = bootproto;  
	}  
	newdev["NAME"] = description;  
        // L3: bnc#585458  
//      if (!issubstring(Items[current, "ifcfg"]:"", type)) newdev["INTERFACETYPE"]=type;  
									// exception for VLAN  
									// because of ethX.Y  
//        if (deletechars(Items[current, "ifcfg"]:"", "0123456789")!=type && type!="vlan") newdev["INTERFACETYPE"]=type;  
  
	if(hotplug == "pcmcia") newdev["DHCLIENT_SET_DOWN_LINK"] = "yes";  
  
  
	if (type == "bond")  
	{  
            integer i = 0;  
            foreach (string slave, bond_slaves,  
            {  
		newdev[sformat("BONDING_SLAVE%1", i)] = slave;  
                i = i + 1;  
            });  
  
            //assign nil to rest BONDING_SLAVEn to remove them  
            while (i<10)  
            {  
               newdev[sformat("BONDING_SLAVE%1", i)] = nil;  
               i = i + 1;  
            };  
  
            newdev["BONDING_MODULE_OPTS"] = bond_option;  
  
            //BONDING_MASTER always is yes  
            newdev["BONDING_MASTER"] = "yes";  
	}  
  
	if (type=="vlan"){  
	 newdev["ETHERDEVICE"]=vlan_etherdevice;  
	 newdev["VLAN_ID"]=vlan_id;  
	}  
	if (type=="br"){  
	 newdev["BRIDGE_PORTS"]=bridge_ports;  
	 newdev["BRIDGE"]="yes";  
	 newdev["BRIDGE_STP"]="off";  
	 newdev["BRIDGE_FORWARDDELAY"]="0";  
	}  
  
	if(type == "wlan") {  
	    newdev["WIRELESS_MODE"] = wl_mode;  
	    newdev["WIRELESS_ESSID"] = wl_essid;  
	    newdev["WIRELESS_NWID"] = wl_nwid;  
	    newdev["WIRELESS_AUTH_MODE"] = wl_auth_mode;  
	    newdev["WIRELESS_WPA_PSK"] = wl_wpa_psk;  
	    newdev["WIRELESS_KEY_LENGTH"] = wl_key_length;  
	    // obsoleted by WIRELESS_KEY_0  
	    newdev["WIRELESS_KEY"] = ""; // TODO: delete the varlable  
	    newdev["WIRELESS_KEY_0"] = wl_key[0]:"";  
	    newdev["WIRELESS_KEY_1"] = wl_key[1]:"";  
	    newdev["WIRELESS_KEY_2"] = wl_key[2]:"";  
	    newdev["WIRELESS_KEY_3"] = wl_key[3]:"";  
	    newdev["WIRELESS_DEFAULT_KEY"] = tostring (wl_default_key);  
	    newdev["WIRELESS_NICK"] = wl_nick;  
	    newdev["WIRELESS_AP_SCANMODE"] = wl_ap_scanmode;  
  
	    if (wl_wpa_eap != $[])  
	    {  
		newdev["WIRELESS_EAP_MODE"] = wl_wpa_eap["WPA_EAP_MODE"]:"";  
		newdev["WIRELESS_WPA_IDENTITY"] = wl_wpa_eap["WPA_EAP_IDENTITY"]:"";  
		newdev["WIRELESS_WPA_PASSWORD"] = wl_wpa_eap["WPA_EAP_PASSWORD"]:"";  
		newdev["WIRELESS_WPA_ANONID"] = wl_wpa_eap["WPA_EAP_ANONID"]:"";  
		newdev["WIRELESS_CLIENT_CERT"] = wl_wpa_eap["WPA_EAP_CLIENT_CERT"]:"";  
		newdev["WIRELESS_CLIENT_KEY"] = wl_wpa_eap["WPA_EAP_CLIENT_KEY"]:"";  
		newdev["WIRELESS_CLIENT_KEY_PASSWORD"] = wl_wpa_eap["WPA_EAP_CLIENT_KEY_PASSWORD"]:"";  
		newdev["WIRELESS_CA_CERT"] = wl_wpa_eap["WPA_EAP_CA_CERT"]:"";  
		newdev["WIRELESS_EAP_AUTH"] = wl_wpa_eap["WPA_EAP_AUTH"]:"";  
		newdev["WIRELESS_PEAP_VERSION"] = wl_wpa_eap["WPA_EAP_PEAP_VERSION"]:"";	      
	    }  
  
	    newdev["WIRELESS_CHANNEL"] = wl_channel;  
	    newdev["WIRELESS_FREQUENCY"] = wl_frequency;  
	    newdev["WIRELESS_BITRATE"] = wl_bitrate;  
	    newdev["WIRELESS_AP"] = wl_accesspoint;  
	    newdev["WIRELESS_POWER"] = wl_power ? "yes" : "no";  
	}  
  
	if(DriverType (type) == "ctc")  
	    if(NetworkConfig::Config["WAIT_FOR_INTERFACES"]:nil == nil || NetworkConfig::Config["WAIT_FOR_INTERFACES"]:0 < 40)  
		NetworkConfig::Config["WAIT_FOR_INTERFACES"] = 40;  
  
	if(alias == "") {  
	    newdev["_aliases"] = aliases;  
	    y2milestone("aliases %1", aliases);  
	}  
	if (contains(["tun", "tap"], type)){  
	 newdev=$[  
		"BOOTPROTO" : "static",  
		"STARTMODE" : "auto",  
		"TUNNEL" : type,  
		"TUNNEL_SET_PERSISTENT" : tunnel_set_persistent ? "yes" : "no",  
		"TUNNEL_SET_OWNER" : tunnel_set_owner,  
		"TUNNEL_SET_GROUP" : tunnel_set_group  
		];  
	}  
	NetworkInterfaces::Name = Items[current, "ifcfg"]:"";  
	NetworkInterfaces::Current = newdev;  
y2internal("%1", newdev); // HERE IS THE SINK 1  
	if (!NetworkInterfaces::Commit()) Items[current, "ifcfg"]="";  
    }  
    else {  
	y2error("Unknown operation: %1", operation);  
	return false;  
    }  
   modified = true;  
   operation = nil;  
   return true;  
}  
  
```  
