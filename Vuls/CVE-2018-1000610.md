## Summary:  
Software: jenkins/configuration_as_code_plugin  
## Fix:  
Commit: https://github.com/jenkinsci/configuration-as-code-plugin/pull/252/commits/dbe17d4da2f06c3044cd4836156cbe325348d7e2  
Fix Time (of the Last Commit): 2018-06-02  
Author: hawky-4s-  
Fix Pattern: Sanitization -> Redaction -> Introduction -> Tag/TypeBasedFiltration -> NoRedactionFunctionDefined  
  
  
Fixing-commits Count: 2  
Total Change Size: +32 -4  
  
========  
Commit: https://github.com/jenkinsci/configuration-as-code-plugin/commit/8e99814c0bf040a3a7acb56e47056068ebad1219  
Change Size: +13 -3  
Time: 2018-05-29  
  
Commit: https://github.com/jenkinsci/configuration-as-code-plugin/pull/252/commits/dbe17d4da2f06c3044cd4836156cbe325348d7e2  
Change Size: +19 -1  
Time: 2018-06-02  
## Sample logs: Yes  
```  
INFO: Setting class com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey.id = foo  
May 28, 2018 7:01:27 AM org.jenkinsci.plugins.casc.DataBoundConfigurator configure  
INFO: Setting class com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey.username = bar  
May 28, 2018 7:01:27 AM org.jenkinsci.plugins.casc.DataBoundConfigurator configure  
INFO: Setting class com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl.password = secret  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> the passwords configured using Configuration as Code Plugin  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（Logger）  
Sensitiveness-Identifiable Source:  No  
#### Sink 2:  
Logging call Function:  Standard Libraries（Logger）  
Sensitiveness-Identifiable Source:  No  
Programming Language:Java  
```java  
// https://github.com/jenkinsci/configuration-as-code-plugin/blob/1070b7da6cfbadffec0dc8bbe5ce4b78c1315337/src/main/java/org/jenkinsci/plugins/casc/Attribute.java#L166-L196  
  
    private void _setValue(Owner target, Type value) throws Exception {  
        final String setterId = target.getClass().getCanonicalName()+'#'+name;  
        logger.info("Setting " + setterId + " = " + value); // HERE IS THE SINK 1  
        final PropertyDescriptor property = PropertyUtils.getPropertyDescriptor(target, name);  
        if (property == null) {  
            throw new Exception("Default value setter cannot find Property Descriptor for " + setterId);  
        }  
        final Method writeMethod = property.getWriteMethod();  
  
        Object o = value;  
        if (multiple) {  
            if (!(value instanceof Collection)) {  
                throw new IllegalArgumentException(setterId + " should be a list.");  
            }  
            // if setter expect an Array, convert Collection to expected array type  
            // Typically required for hudson.tools.ToolDescriptor.setInstallations  
            // as java varargs unfortunately only supports Arrays, not all Iterable (sic)  
            final Class c = writeMethod.getParameterTypes()[0];  
            if (c.isArray()) {  
                Collection collection = (Collection) value;  
                o = collection.toArray((Object[]) Array.newInstance(type, collection.size()));  
  
                // if setter expect a Set, convert Collection to Set  
                // see jenkins.agentProtocols  
            } else if(c.isAssignableFrom(Set.class)){  
                o = new HashSet((Collection)value);  
            }  
        }  
  
        writeMethod.invoke(target, o);  
    }  
  
// https://github.com/hawky-4s-/configuration-as-code-plugin/blob/2f896fda2a69f4e954588628ba9a47c3bb33c8ae/src/main/java/org/jenkinsci/plugins/casc/DataBoundConfigurator.java#L47-L144  
  
    public T configure(CNode c) throws ConfiguratorException {  
  
        // c can be null for component with no-arg constructor and no extra property to be set  
        Mapping config = (c != null ? c.asMapping() : Mapping.EMPTY);  
  
        final Constructor constructor = getDataBoundConstructor();  
  
        final Parameter[] parameters = constructor.getParameters();  
        final String[] names = ClassDescriptor.loadParameterNames(constructor);  
        Object[] args = new Object[names.length];  
  
        if (parameters.length > 0) {  
            // Many jenkins components haven't been migrated to @DataBoundSetter vs @NotNull constructor parameters  
            // as a result it might be valid to reference a describable without parameters  
  
            for (int i = 0; i < names.length; i++) {  
                final CNode value = config.remove(names[i]);  
                if (value == null && parameters[i].getAnnotation(Nonnull.class) != null) {  
                    throw new ConfiguratorException(names[i] + " is required to configure " + target);  
                }  
                final Class t = parameters[i].getType();  
                if (value != null) {  
                    if (Collection.class.isAssignableFrom(t)) {  
                        final Type pt = parameters[i].getParameterizedType();  
                        final Configurator lookup = Configurator.lookup(pt);  
  
                        final ArrayList<Object> list = new ArrayList<>();  
                        for (CNode o : value.asSequence()) {  
                            list.add(lookup.configure(o));  
                        }  
                        args[i] = list;  
  
                    } else {  
                        final Type pt = parameters[i].getParameterizedType();  
                        final Type k = pt != null ? pt : t;  
                        final Configurator configurator = Configurator.lookup(k);  
                        if (configurator == null) throw new IllegalStateException("No configurator implementation to manage "+k);  
                        args[i] = configurator.configure(value);  
                    }  
                    logger.info("Setting " + target + "." + names[i] + " = " + value);  
                } else if (t.isPrimitive()) {  
                    args[i] = Defaults.defaultValue(t);  
                }  
            }  
        }  
  
        final Object object;  
        try {  
            object = constructor.newInstance(args);  
        } catch (IllegalArgumentException | InstantiationException | InvocationTargetException | IllegalAccessException ex) {  
             List<String> argumentTypes = new ArrayList<>(args.length);  
             for (Object arg : args) {  
                argumentTypes.add(arg != null ? arg.getClass().getName() : "null");  
             }  
             throw new ConfiguratorException(this,  
                     "Failed to construct instance of " + target +  
                    ".\n Constructor: " + constructor.toString() +  
                    ".\n Arguments: " + argumentTypes, ex);  
        }  
  
        final Set<Attribute> attributes = describe();  
  
        for (Attribute attribute : attributes) {  
            final String name = attribute.getName();  
            final Configurator lookup = Configurator.lookup(attribute.getType());  
            if (config.containsKey(name)) {  
                final CNode yaml = config.get(name);  
                Object value;  
                if (attribute.isMultiple()) {  
                    List l = new ArrayList<>();  
                    for (CNode o : yaml.asSequence()) {  
                        l.add(lookup.configure(o));  
                    }  
                    value = l;  
                } else {  
                    value = lookup.configure(config.get(name));  
                }  
                try {  
                    logger.info("Setting " + object + '.' + name + " = " + (yaml.isSensitiveData() ? "****" : value));  // HERE IS THE SINK 2  
                    attribute.setValue(object, value);  
                } catch (Exception e) {  
                    throw new ConfiguratorException(this, "Failed to set attribute " + attribute, e);  
                }  
            }  
        }  
  
        for (Method method : target.getMethods()) {  
            if (method.getParameterCount() == 0 && method.getAnnotation(PostConstruct.class) != null) {  
                try {  
                    method.invoke(object, null);  
                } catch (IllegalAccessException | InvocationTargetException e) {  
                    throw new ConfiguratorException(this, "Failed to invoke configurator method " + method, e);  
                }  
            }  
        }  
  
        return (T) object;  
    }  
  
```  
