## Summary:  
Software: 389_directory_server  
## Fix:  
Commit: https://github.com/389ds/389-ds-base/commit/104be9958cdc245ebb44912d3eadeec2b97731b8  
Author: tbordaz  
Fix Time (of the Last Commit): 2019-07-16  
  
Fix Pattern: Sanitization -> Hashing  
  
Fixing-commits Count: 1  
Total Change Size: +122 -3  
  
========  
PR: https://pagure.io/389-ds-base/pull-request/50496  
Commit: https://github.com/389ds/389-ds-base/commit/104be9958cdc245ebb44912d3eadeec2b97731b8  
Change Size: +122 -3  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> passwords  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（write_audit_log_entry）  
Sensitiveness-Identifiable Source:  Same Methods & Cross Statements（https://github.com/389ds/389-ds-base/blob/d38ae06d3e43ee429e5128bca263187a0949a96b/ldap/servers/slapd/modify.c#L599） -> Variable Names（unhashed_pw_smod）  
Programming Language:C/C++  
```C++  
// https://github.com/389ds/389-ds-base/blob/d38ae06d3e43ee429e5128bca263187a0949a96b/ldap/servers/slapd/modify.c#L832-L865  
		slapi_pblock_get (pb, SLAPI_MODIFY_MODS, &mods);  
		if (hash_rootpw (mods) != 0) {  
			send_ldap_result(pb, LDAP_UNWILLING_TO_PERFORM, NULL,  
			"Failed to hash root user's password", 0, NULL);  
			goto free_and_return;  
		}  
  
		slapi_pblock_set(pb, SLAPI_PLUGIN, be->be_database);  
		set_db_default_result_handlers(pb);  
  
		/* Remove the unhashed password pseudo-attribute prior */  
		/* to db access */  
		if (pw_change)  
		{  
			slapi_mods_init_passin (&smods, mods);  
			remove_mod (&smods, unhashed_pw_attr, &unhashed_pw_smod);  
			slapi_pblock_set (pb, SLAPI_MODIFY_MODS,   
							  (void*)slapi_mods_get_ldapmods_passout (&smods));	  
		}  
  
		if (be->be_modify != NULL)  
		{  
			if ((rc = (*be->be_modify)(pb)) == 0)  
			{  
				/* acl is not used for internal operations */  
				/* don't update aci store for remote acis  */  
				if ((!internal_op) &&  
					(!slapi_be_is_flag_set(be,SLAPI_BE_FLAG_REMOTE_DATA)))  
				{  
					plugin_call_acl_mods_update (pb, SLAPI_OPERATION_MODIFY);   
				}  
  
				if (operation_is_flag_set(operation,OP_FLAG_ACTION_LOG_AUDIT))  
					write_audit_log_entry(pb); /* Record the operation in the audit log */ // HERE IS THE SINK 1  
  
  
// https://github.com/389ds/389-ds-base/blob/d38ae06d3e43ee429e5128bca263187a0949a96b/ldap/servers/slapd/auditlog.c#L62-L258  
void  
write_audit_log_entry( Slapi_PBlock *pb )  
{  
    time_t curtime;  
    char *dn;  
    void *change;  
	int flag = 0;  
	Operation *op;  
  
	/* if the audit log is not enabled, just skip all of  
	   this stuff */  
	if (!config_get_auditlog_logging_enabled()) {  
		return;  
	}  
  
	slapi_pblock_get( pb, SLAPI_OPERATION, &op );  
    slapi_pblock_get( pb, SLAPI_TARGET_DN, &dn );  
    switch ( operation_get_type(op) )  
	{  
    case SLAPI_OPERATION_MODIFY:  
	    slapi_pblock_get( pb, SLAPI_MODIFY_MODS, &change );  
    	break;  
    case SLAPI_OPERATION_ADD:  
	    {  
    	/*  
    	 * For adds, we want the unnormalized dn, so we can preserve  
    	 * spacing, case, when replicating it.  
    	 */  
        Slapi_Entry *te = NULL;  
    	slapi_pblock_get( pb, SLAPI_ADD_ENTRY, &change );  
    	te = (Slapi_Entry *)change;  
    	if ( NULL != te )  
		{  
    	    dn = slapi_entry_get_dn( te );  
    	}  
		}  
    	break;  
    case SLAPI_OPERATION_DELETE:  
		{  
		char * deleterDN = NULL;  
		slapi_pblock_get(pb, SLAPI_REQUESTOR_DN, &deleterDN);  
    	change = deleterDN;  
		}  
    	break;  
	  
    case SLAPI_OPERATION_MODDN:  
    	slapi_pblock_get( pb, SLAPI_MODRDN_NEWRDN, &change );  
    	slapi_pblock_get( pb, SLAPI_MODRDN_DELOLDRDN, &flag );  
    	break;  
    }  
    curtime = current_time();  
    write_audit_file( operation_get_type(op), dn, change, flag, curtime );  
}  
  
  
  
/*  
 * Function: write_audit_file  
 * Arguments:   
 *            optype - type of LDAP operation being logged  
 *            dn     - distinguished name of entry being changed  
 *            change - pointer to the actual change operation  
 *                     For a delete operation, may contain the modifier's DN.  
 *            flag   - only used by modrdn operations - value of deleteoldrdn flag  
 *            curtime - the current time  
 * Returns: nothing  
 */  
  
static void  
write_audit_file(  
    int			optype,  
    char		*dn,  
    void		*change,  
    int			flag,  
    time_t		curtime  
)  
{  
    LDAPMod	**mods;  
    Slapi_Entry	*e;  
    char	*newrdn, *tmp, *tmpsave;  
    int	len, i, j;  
    char	*timestr;  
    lenstr	*l;  
  
    l = lenstr_new();  
  
    addlenstr( l, "time: " );  
    timestr = format_localTime( curtime );  
    addlenstr( l, timestr );  
    slapi_ch_free((void **) &timestr );  
    addlenstr( l, "\n" );  
    addlenstr( l, "dn: " );  
    addlenstr( l, dn );  
    addlenstr( l, "\n" );  
  
    switch ( optype )  
	{  
    case SLAPI_OPERATION_MODIFY:  
    	addlenstr( l, attr_changetype );  
    	addlenstr( l, ": modify\n" );  
    	mods = change;  
    	for ( j = 0; mods[j] != NULL; j++ )  
		{  
			int operationtype= mods[j]->mod_op & ~LDAP_MOD_BVALUES;  
    	    switch ( operationtype )  
			{  
    	    case LDAP_MOD_ADD:  
        		addlenstr( l, "add: " );  
        		addlenstr( l, mods[j]->mod_type );  
        		addlenstr( l, "\n" );  
        		break;  
  
    	    case LDAP_MOD_DELETE:  
        		addlenstr( l, "delete: " );  
        		addlenstr( l, mods[j]->mod_type );  
        		addlenstr( l, "\n" );  
        		break;  
  
    	    case LDAP_MOD_REPLACE:  
        		addlenstr( l, "replace: " );  
        		addlenstr( l, mods[j]->mod_type );  
        		addlenstr( l, "\n" );  
        		break;  
  
			default:  
				operationtype= LDAP_MOD_IGNORE;  
				break;  
    	    }  
			if(operationtype!=LDAP_MOD_IGNORE)  
			{  
    			for ( i = 0; mods[j]->mod_bvalues != NULL && mods[j]->mod_bvalues[i] != NULL; i++ )  
				{  
        			char *buf, *bufp;  
        			len = strlen( mods[j]->mod_type );  
        			len = LDIF_SIZE_NEEDED( len, mods[j]->mod_bvalues[i]->bv_len ) + 1;  
       				buf = slapi_ch_malloc( len );  
        			bufp = buf;  
        			slapi_ldif_put_type_and_value_with_options( &bufp, mods[j]->mod_type,  
        				mods[j]->mod_bvalues[i]->bv_val,  
        				mods[j]->mod_bvalues[i]->bv_len, 0 );  
        			*bufp = '\0';  
        			addlenstr( l, buf );  
        			slapi_ch_free( (void**)&buf );  
    			}  
			}  
    	    addlenstr( l, "-\n" );  
    	}  
    	break;  
  
    case SLAPI_OPERATION_ADD:  
    	e = change;  
    	addlenstr( l, attr_changetype );  
    	addlenstr( l, ": add\n" );  
    	tmp = slapi_entry2str( e, &len );  
    	tmpsave = tmp;  
    	while (( tmp = strchr( tmp, '\n' )) != NULL )  
		{  
    	    tmp++;  
    	    if ( !ldap_utf8isspace( tmp ))  
			{  
        		break;  
    	    }  
    	}  
    	addlenstr( l, tmp );  
    	slapi_ch_free((void**)&tmpsave );  
    	break;  
  
    case SLAPI_OPERATION_DELETE:  
		tmp = change;  
    	addlenstr( l, attr_changetype );  
    	addlenstr( l, ": delete\n" );  
		if (tmp && tmp[0]) {  
			addlenstr( l, attr_modifiersname );  
			addlenstr( l, ": ");  
			addlenstr( l, tmp);  
			addlenstr( l, "\n");  
		}  
    	break;  
      
    case SLAPI_OPERATION_MODDN:  
    	newrdn = change;  
    	addlenstr( l, attr_changetype );  
    	addlenstr( l, ": modrdn\n" );  
    	addlenstr( l, attr_newrdn );  
    	addlenstr( l, ": " );  
    	addlenstr( l, newrdn );  
    	addlenstr( l, "\n" );  
    	addlenstr( l, attr_deleteoldrdn );  
    	addlenstr( l, ": " );  
    	addlenstr( l, flag ? "1" : "0" );  
    	addlenstr( l, "\n" );  
    }  
    addlenstr( l, "\n" );  
  
    slapd_log_audit_proc (l->ls_buf, l->ls_len); // HERE IS THE INNER SINK  
  
    lenstr_free( &l );  
}  
  
```  
