## Summary:  
Software: 389_directory_server  
## Fix:  
Commit: https://github.com/389ds/389-ds-base/commit/d38ae06d3e43ee429e5128bca263187a0949a96b  
Change Size: +58 -2  
Fix Time (of the Last Commit): 2010-11-23  
Fix Pattern: Sanitization -> Hashing  
Author: Nathan Kinder  
  
Fixing-commits Count: 1  
Total Change Size: +58 -2  
## Sample logs: Yes  
```  
dn: cn=config  
changetype: modify  
replace: nsslapd-rootpw  
nsslapd-rootpw: secret  
  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> Directory Manager password (nsslapd-rootpw)  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（write_audit_log_entry）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/389ds/389-ds-base/blob/d38ae06d3e43ee429e5128bca263187a0949a96b/ldap/servers/slapd/slap.h#L1799） -> Variable Names（CONFIG_ROOTPW_ATTRIBUTE）|String Literals（nsslapd-rootpw，finally outputed to logs）  
Programming Language:C/C++  
```C++  
// https://github.com/389ds/389-ds-base/blob/6160200187b5b5f7ee662762b997c5c55401fe77/ldap/servers/slapd/modify.c#L827-L851  
		/* Remove the unhashed password pseudo-attribute prior */  
		/* to db access */  
		if (pw_change)  
		{  
			slapi_pblock_get (pb, SLAPI_MODIFY_MODS, &mods);  
			slapi_mods_init_passin (&smods, mods);  
			remove_mod (&smods, unhashed_pw_attr, &unhashed_pw_smod);  
			slapi_pblock_set (pb, SLAPI_MODIFY_MODS,   
							  (void*)slapi_mods_get_ldapmods_passout (&smods));	  
		}  
  
		if (be->be_modify != NULL)  
		{  
			if ((rc = (*be->be_modify)(pb)) == 0)  
			{  
				/* acl is not used for internal operations */  
				/* don't update aci store for remote acis  */  
				if ((!internal_op) &&  
					(!slapi_be_is_flag_set(be,SLAPI_BE_FLAG_REMOTE_DATA)))  
				{  
					plugin_call_acl_mods_update (pb, SLAPI_OPERATION_MODIFY);   
				}  
  
				if (operation_is_flag_set(operation,OP_FLAG_ACTION_LOG_AUDIT))  
					write_audit_log_entry(pb); /* Record the operation in the audit log */ // HERE IS THE SINK 1  
  
  
// https://github.com/389ds/389-ds-base/blob/d38ae06d3e43ee429e5128bca263187a0949a96b/ldap/servers/slapd/auditlog.c#L62-L258  
void  
write_audit_log_entry( Slapi_PBlock *pb )  
{  
    time_t curtime;  
    char *dn;  
    void *change;  
	int flag = 0;  
	Operation *op;  
  
	/* if the audit log is not enabled, just skip all of  
	   this stuff */  
	if (!config_get_auditlog_logging_enabled()) {  
		return;  
	}  
  
	slapi_pblock_get( pb, SLAPI_OPERATION, &op );  
    slapi_pblock_get( pb, SLAPI_TARGET_DN, &dn );  
    switch ( operation_get_type(op) )  
	{  
    case SLAPI_OPERATION_MODIFY:  
	    slapi_pblock_get( pb, SLAPI_MODIFY_MODS, &change );  
    	break;  
    case SLAPI_OPERATION_ADD:  
	    {  
    	/*  
    	 * For adds, we want the unnormalized dn, so we can preserve  
    	 * spacing, case, when replicating it.  
    	 */  
        Slapi_Entry *te = NULL;  
    	slapi_pblock_get( pb, SLAPI_ADD_ENTRY, &change );  
    	te = (Slapi_Entry *)change;  
    	if ( NULL != te )  
		{  
    	    dn = slapi_entry_get_dn( te );  
    	}  
		}  
    	break;  
    case SLAPI_OPERATION_DELETE:  
		{  
		char * deleterDN = NULL;  
		slapi_pblock_get(pb, SLAPI_REQUESTOR_DN, &deleterDN);  
    	change = deleterDN;  
		}  
    	break;  
	  
    case SLAPI_OPERATION_MODDN:  
    	slapi_pblock_get( pb, SLAPI_MODRDN_NEWRDN, &change );  
    	slapi_pblock_get( pb, SLAPI_MODRDN_DELOLDRDN, &flag );  
    	break;  
    }  
    curtime = current_time();  
    write_audit_file( operation_get_type(op), dn, change, flag, curtime ); // HERE IS THE INNER SINK  
}  
  
  
  
/*  
 * Function: write_audit_file  
 * Arguments:   
 *            optype - type of LDAP operation being logged  
 *            dn     - distinguished name of entry being changed  
 *            change - pointer to the actual change operation  
 *                     For a delete operation, may contain the modifier's DN.  
 *            flag   - only used by modrdn operations - value of deleteoldrdn flag  
 *            curtime - the current time  
 * Returns: nothing  
 */  
  
static void  
write_audit_file(  
    int			optype,  
    char		*dn,  
    void		*change,  
    int			flag,  
    time_t		curtime  
)  
{  
    LDAPMod	**mods;  
    Slapi_Entry	*e;  
    char	*newrdn, *tmp, *tmpsave;  
    int	len, i, j;  
    char	*timestr;  
    lenstr	*l;  
  
    l = lenstr_new();  
  
    addlenstr( l, "time: " );  
    timestr = format_localTime( curtime );  
    addlenstr( l, timestr );  
    slapi_ch_free((void **) &timestr );  
    addlenstr( l, "\n" );  
    addlenstr( l, "dn: " );  
    addlenstr( l, dn );  
    addlenstr( l, "\n" );  
  
    switch ( optype )  
	{  
    case SLAPI_OPERATION_MODIFY:  
    	addlenstr( l, attr_changetype );  
    	addlenstr( l, ": modify\n" );  
    	mods = change;  
    	for ( j = 0; mods[j] != NULL; j++ )  
		{  
			int operationtype= mods[j]->mod_op & ~LDAP_MOD_BVALUES;  
    	    switch ( operationtype )  
			{  
    	    case LDAP_MOD_ADD:  
        		addlenstr( l, "add: " );  
        		addlenstr( l, mods[j]->mod_type );  
        		addlenstr( l, "\n" );  
        		break;  
  
    	    case LDAP_MOD_DELETE:  
        		addlenstr( l, "delete: " );  
        		addlenstr( l, mods[j]->mod_type );  
        		addlenstr( l, "\n" );  
        		break;  
  
    	    case LDAP_MOD_REPLACE:  
        		addlenstr( l, "replace: " );  
        		addlenstr( l, mods[j]->mod_type );  
        		addlenstr( l, "\n" );  
        		break;  
  
			default:  
				operationtype= LDAP_MOD_IGNORE;  
				break;  
    	    }  
			if(operationtype!=LDAP_MOD_IGNORE)  
			{  
    			for ( i = 0; mods[j]->mod_bvalues != NULL && mods[j]->mod_bvalues[i] != NULL; i++ )  
				{  
        			char *buf, *bufp;  
        			len = strlen( mods[j]->mod_type );  
        			len = LDIF_SIZE_NEEDED( len, mods[j]->mod_bvalues[i]->bv_len ) + 1;  
       				buf = slapi_ch_malloc( len );  
        			bufp = buf;  
        			slapi_ldif_put_type_and_value_with_options( &bufp, mods[j]->mod_type,  
        				mods[j]->mod_bvalues[i]->bv_val,  
        				mods[j]->mod_bvalues[i]->bv_len, 0 );  
        			*bufp = '\0';  
        			addlenstr( l, buf );  
        			slapi_ch_free( (void**)&buf );  
    			}  
			}  
    	    addlenstr( l, "-\n" );  
    	}  
    	break;  
  
    case SLAPI_OPERATION_ADD:  
    	e = change;  
    	addlenstr( l, attr_changetype );  
    	addlenstr( l, ": add\n" );  
    	tmp = slapi_entry2str( e, &len );  
    	tmpsave = tmp;  
    	while (( tmp = strchr( tmp, '\n' )) != NULL )  
		{  
    	    tmp++;  
    	    if ( !ldap_utf8isspace( tmp ))  
			{  
        		break;  
    	    }  
    	}  
    	addlenstr( l, tmp );  
    	slapi_ch_free((void**)&tmpsave );  
    	break;  
  
    case SLAPI_OPERATION_DELETE:  
		tmp = change;  
    	addlenstr( l, attr_changetype );  
    	addlenstr( l, ": delete\n" );  
		if (tmp && tmp[0]) {  
			addlenstr( l, attr_modifiersname );  
			addlenstr( l, ": ");  
			addlenstr( l, tmp);  
			addlenstr( l, "\n");  
		}  
    	break;  
      
    case SLAPI_OPERATION_MODDN:  
    	newrdn = change;  
    	addlenstr( l, attr_changetype );  
    	addlenstr( l, ": modrdn\n" );  
    	addlenstr( l, attr_newrdn );  
    	addlenstr( l, ": " );  
    	addlenstr( l, newrdn );  
    	addlenstr( l, "\n" );  
    	addlenstr( l, attr_deleteoldrdn );  
    	addlenstr( l, ": " );  
    	addlenstr( l, flag ? "1" : "0" );  
    	addlenstr( l, "\n" );  
    }  
    addlenstr( l, "\n" );  
  
    slapd_log_audit_proc (l->ls_buf, l->ls_len);  
  
    lenstr_free( &l );  
}  
  
// https://github.com/389ds/389-ds-base/blob/d38ae06d3e43ee429e5128bca263187a0949a96b/ldap/servers/slapd/pblock.c#L144-L160  
  
int  
slapi_pblock_get( Slapi_PBlock *pblock, int arg, void *value )  
{  
    char *authtype;  
	Slapi_Backend		*be;  
  
	PR_ASSERT( NULL != pblock );  
	PR_ASSERT( NULL != value );  
	be = pblock->pb_backend;  
  
	switch ( arg ) {  
	case SLAPI_BACKEND:  
		(*(Slapi_Backend **)value) = be;  
		break;  
	case SLAPI_BACKEND_COUNT:  
		(*(int *)value) = pblock->pb_backend_count;  
		break;  
  
// https://github.com/389ds/389-ds-base/blob/d38ae06d3e43ee429e5128bca263187a0949a96b/ldap/servers/slapd/pblock.c#L1219-L1237  
  
	/* modify arguments */  
	case SLAPI_MODIFY_MODS:  
		PR_ASSERT(pblock->pb_op);  
		if(pblock->pb_op!=NULL)  
		{  
			if(pblock->pb_op->o_params.operation_type==SLAPI_OPERATION_MODIFY)  
			{  
				(*(LDAPMod ***)value) = pblock->pb_op->o_params.p.p_modify.modify_mods;  
			}  
			else if(pblock->pb_op->o_params.operation_type==SLAPI_OPERATION_MODRDN)  
			{  
				(*(LDAPMod ***)value) = pblock->pb_op->o_params.p.p_modrdn.modrdn_mods;  
			}  
			else  
			{  
				PR_ASSERT(0); /* JCM */  
			}  
		}  
		break;  
  
// https://github.com/389ds/389-ds-base/blob/d38ae06d3e43ee429e5128bca263187a0949a96b/ldap/servers/slapd/slap.h#L1433-L1579  
  
typedef struct slapi_pblock {  
	/* common */  
	Slapi_Backend		*pb_backend;  
	Connection	*pb_conn;  
	Operation	*pb_op;  
	struct slapdplugin	*pb_plugin;	/* plugin being called */  
	int		pb_opreturn;  
	void*		pb_object;	/* points to data private to plugin */  
	IFP		pb_destroy_fn;  
	int		pb_requestor_isroot;  
	/* config file */  
	char		*pb_config_fname;  
	int		pb_config_lineno;  
	int		pb_config_argc;  
	char		**pb_config_argv;  
  
	/* [pre|post]add arguments */  
	struct slapi_entry	*pb_target_entry; /* JCM - Duplicated */  
	struct slapi_entry	*pb_existing_dn_entry;  
	struct slapi_entry	*pb_existing_uniqueid_entry;  
	struct slapi_entry	*pb_parent_entry;  
	struct slapi_entry	*pb_newparent_entry;  
  
	/* state of entry before and after add/delete/modify/moddn/modrdn */  
	struct slapi_entry	*pb_pre_op_entry;  
	struct slapi_entry	*pb_post_op_entry;  
	/* seq access arguments */  
	int             pb_seq_type;  
	char            *pb_seq_attrname;  
	char            *pb_seq_val;  
	/* ldif2db arguments */  
	char		*pb_ldif_file;  
	int		pb_removedupvals;  
	char		**pb_db2index_attrs;  
	int		pb_ldif2db_noattrindexes;  
	/* db2ldif arguments */  
	int		pb_ldif_printkey;  
	/* ldif2db/db2ldif/db2bak/bak2db args */  
	char *pb_instance_name;  
	Slapi_Task      *pb_task;  
	int		pb_task_flags;  
	/* matching rule arguments */  
	mrFilterMatchFn	pb_mr_filter_match_fn;  
	IFP		pb_mr_filter_index_fn;  
	IFP		pb_mr_filter_reset_fn;  
	IFP		pb_mr_index_fn; /* values and keys are struct berval ** */  
	char*		pb_mr_oid;  
	char*		pb_mr_type;  
	struct berval*	pb_mr_value;  
	struct berval**	pb_mr_values;  
	struct berval**	pb_mr_keys;  
	unsigned int	pb_mr_filter_reusable;  
	int		pb_mr_query_operator;  
	unsigned int	pb_mr_usage;  
  
	/* arguments for password storage scheme (kexcoff) */  
	char *pb_pwd_storage_scheme_user_passwd;  
	char *pb_pwd_storage_scheme_db_passwd;  
  
	/* controls we know about */  
	int		pb_managedsait;  
  
    /* additional fields for plugin_internal_ldap_ops */  
	/* result code of internal ldap_operation */  
    int		pb_internal_op_result;  
	/* pointer to array of results returned on search */  
	Slapi_Entry	**pb_plugin_internal_search_op_entries;  
	char		**pb_plugin_internal_search_op_referrals;  
	void		*pb_plugin_identity; /* identifies plugin for internal operation */  
	void		*pb_parent_txn;	/* parent transaction ID */  
	void		*pb_txn;		/* transaction ID */  
  
	/* Size of the database on disk, in kilobytes */  
	unsigned int	pb_dbsize;  
  
	/* THINGS BELOW THIS LINE EXIST ONLY IN SLAPI v2 (slapd 4.0+) */  
  
	/* ldif2db: array of files to import all at once */  
	char **pb_ldif_files;  
  
	char		**pb_ldif_include;  
	char		**pb_ldif_exclude;  
	int		pb_ldif_dump_replica;  
	int		pb_ldif_dump_uniqueid;		/* dump uniqueid during db2ldif */  
	int		pb_ldif_generate_uniqueid;	/* generate uniqueid during db2ldif */  
	char*     pb_ldif_namespaceid;		/* used for name based uniqueid generation */   
	int     pb_ldif_encrypt;		/* used to enable encrypt/decrypt on import and export */   
	/*  
	 * notes to log with RESULT line in the access log  
	 * these are actually stored as a bitmap; see slapi-plugin.h for  
	 *	defined notes.  
	 */  
	unsigned int	pb_operation_notes;  
	/*  
	 * slapd command line arguments  
	 */  
	int pb_slapd_argc;  
	char** pb_slapd_argv;  
	char *pb_slapd_configdir; /* the config directory passed to slapd on the command line */  
	LDAPControl	**pb_ctrls_arg; /* allows to pass controls as arguments before  
								   operation object is created  */  
	int pb_dse_dont_add_write; /* if true, the dse is not written when an entry is added */  
	int pb_dse_add_merge; /* if true, if a duplicate entry is found when adding, the   
							 new values are merged into the old entry */  
	int pb_dse_dont_check_dups; /* if false, use the "enhanced" version of str2entry to catch  
								   more errors when adding dse entries; this can only be done  
								   after the schema and syntax and matching rule plugins are  
								   running */  
	int pb_dse_is_primary_file;	/* for read callbacks: non-zero for primary file */  
	int pb_schema_flags; 		/* schema flags */  
								/* . check/load info (schema reload task) */  
								/* . refresh user defined schema */  
  
	/* NEW in 5.0 for getting back the backend result in frontend */  
	int pb_result_code;			/* operation result code */  
	char * pb_result_text;		/* result text when available */  
	char * pb_result_matched;	/* macthed dn when NO SUCH OBJECT  error */  
	int pb_nentries;			/* number of entries to be returned */  
	struct berval **urls;		/* urls of referrals to be returned */  
  
    /*  
     * wire import (fast replica init) arguments  
     */  
    struct slapi_entry *pb_import_entry;  
    int pb_import_state;  
  
    int pb_destroy_content;     /* flag to indicate that pblock content should be  
                                   destroyed when pblock is destroyed */  
	int pb_dse_reapply_mods; /* if true, dse_modify will reapply mods after modify callback */  
	char * pb_urp_naming_collision_dn;	/* replication naming conflict removal */  
	char * pb_urp_tombstone_uniqueid;	/* replication change tombstone */  
	int		pb_server_running; /* indicate that server is running */  
	int		pb_backend_count;  /* instance count involved in the op */  
  
	/* For password policy control */  
	int		pb_pwpolicy_ctrl;  
	void	*pb_vattr_context;      /* hold the vattr_context for roles/cos */  
  
	int		*pb_substrlens; /* user specified minimum substr search key lengths:  
							 * nsSubStrBegin, nsSubStrMiddle, nsSubStrEnd  
							 */  
	int		pb_plugin_enabled; /* nsslapd-pluginEnabled: on|off */  
							   /* used in plugin init; pb_plugin is not ready, then */  
	LDAPControl	**pb_search_ctrls; /* for search operations, allows plugins to provide  
									  controls to pass for each entry or referral returned */  
	IFP		pb_mr_index_sv_fn; /* values and keys are Slapi_Value ** */  
} slapi_pblock;  
  
// https://github.com/389ds/389-ds-base/blob/1bcd2b438e0b12187d591470fe9e21806aecd797/ldap/servers/slapd/slap.h#L1539-L1582  
  
/*  
 * represents an operation pending from an ldap client  
 */  
typedef struct op  
{  
    BerElement *o_ber;             /* ber of the request */  
    ber_int_t o_msgid;             /* msgid of the request */  
    ber_tag_t o_tag;               /* tag of the request */  
    struct timespec o_hr_time_rel; /* internal system time op initiated */  
    struct timespec o_hr_time_utc; /* utc system time op initiated */  
    struct timespec o_hr_time_started_rel; /* internal system time op started */  
    int o_isroot;                  /* requestor is manager */  
    Slapi_DN o_sdn;                /* dn bound when op was initiated */  
    char *o_authtype;              /* auth method used to bind dn */  
    int o_ssf;                     /* ssf for this operation (highest between SASL and TLS/SSL) */  
    int o_opid;                    /* id of this operation */  
    PRUint64 o_connid;             /* id of conn initiating this op; for logging only */  
    void *o_handler_data;  
    result_handler o_result_handler;  
    search_entry_handler o_search_entry_handler;  
    search_referral_handler o_search_referral_handler;  
    csngen_handler o_csngen_handler;  
    replica_attr_handler o_replica_attr_handler;  
    struct op *o_next;                                         /* next operation pending      */  
    int o_status;                                              /* status (see SLAPI_OP_STATUS_... below */  
    char **o_searchattrs; /* original attr names requested  */ /* JCM - Search Param */  
    unsigned long o_flags;                                     /* flags for this operation      */  
    void *o_extension;                                         /* plugins are able to extend the Operation object */  
    Slapi_DN *o_target_spec;                                   /* used to decide which plugins should be called for the operation */  
    void *o_target_entry;                                      /* Only used for SEARCH operation  
                                                                * reference of search target entry (base search) in the entry cache  
                                                                * When it is set the refcnt (of the entry in the entry cache) as been increased  
                                                                */  
    u_int32_t o_target_entry_id;                               /* Only used for SEARCH operation  
                                                                * contains the ID of the o_target_entry. In send_result we have ID of the candidates, this  
                                                                * accelerates the tests as we have not to retrieve for each candidate the  
                                                                * ep_id inside the o_target_entry.  
                                                                */  
    unsigned long o_abandoned_op;                              /* operation abandoned by this operation - used to decide which plugins to invoke */  
    struct slapi_operation_parameters o_params;  
    struct slapi_operation_results o_results;  
    int o_pagedresults_sizelimit;  
    int o_reverse_search_state;  
} Operation;  
  
// https://github.com/389ds/389-ds-base/blob/07b5a79a3a9ec9c6d5575f2a893fd48bdcdd3c81/ldap/servers/slapd/slapi-private.h#L541-L611  
  
/*  
 * LDAP Operation input parameters.  
 */  
typedef struct slapi_operation_parameters  
{  
    unsigned long operation_type; /* SLAPI_OPERATION_ADD, SLAPI_OPERATION_MODIFY ... */  
    entry_address target_address; /* address of target entry */  
    CSN *csn;                     /* The Change Sequence Number assigned to this operation. */  
  
    LDAPControl **request_controls; /* array v3 LDAPMessage controls  */  
  
    union  
    {  
        struct add_parameters  
        {  
            struct slapi_entry *target_entry;  
            char *parentuniqueid;  
        } p_add;  
  
        struct bind_parameters  
        {  
            ber_tag_t bind_method;  
            struct berval *bind_creds;  
            char *bind_saslmechanism;          /* v3 sasl mechanism name */  
            struct berval *bind_ret_saslcreds; /* v3 serverSaslCreds */  
        } p_bind;  
  
        struct compare_parameters  
        {  
            struct ava compare_ava;  
        } p_compare;  
  
        struct modify_parameters  
        {  
            LDAPMod **modify_mods;  
        } p_modify;  
  
        struct modrdn_parameters  
        {  
            char *modrdn_newrdn;  
            int modrdn_deloldrdn;  
            entry_address modrdn_newsuperior_address; /* address of the superior entry */  
            LDAPMod **modrdn_mods;                    /* modifiers name and timestamp */  
        } p_modrdn;  
  
        struct search_parameters  
        {  
            int search_scope;  
            int search_deref;  
            int search_sizelimit;  
            int search_timelimit;  
            struct slapi_filter *search_filter;  
            char *search_strfilter;  
            char **search_attrs;  
            int search_attrsonly;  
            int search_is_and;  
            char **search_gerattrs;  
        } p_search;  
  
        struct abandon_parameters  
        {  
            int abandon_targetmsgid;  
        } p_abandon;  
  
        struct extended_parameters  
        {  
            char *exop_oid;  
            struct berval *exop_value;  
        } p_extended;  
    } p;  
} slapi_operation_parameters;  
  
  
// https://github.com/389ds/389-ds-base/blob/6160200187b5b5f7ee662762b997c5c55401fe77/ldap/servers/slapd/connection.c#L502-L645  
  
static void  
connection_dispatch_operation(Connection *conn, Operation *op, Slapi_PBlock *pb)  
{  
	/* OMIT FOR SIMPLICITY */  
  
	/* process the operation */  
	switch ( op->o_tag ) {  
	case LDAP_REQ_BIND:  
		operation_set_type(op,SLAPI_OPERATION_BIND);  
		do_bind( pb );  
		break;  
  
	case LDAP_REQ_UNBIND:  
		operation_set_type(op,SLAPI_OPERATION_UNBIND);  
		do_unbind( pb );  
		break;  
  
	case LDAP_REQ_ADD:  
		operation_set_type(op,SLAPI_OPERATION_ADD);  
		do_add( pb );  
		break;  
  
	case LDAP_REQ_DELETE:  
		operation_set_type(op,SLAPI_OPERATION_DELETE);  
		do_delete( pb );  
		break;  
  
	case LDAP_REQ_MODRDN:  
		operation_set_type(op,SLAPI_OPERATION_MODRDN);  
		do_modrdn( pb );  
		break;  
  
	case LDAP_REQ_MODIFY:  
		operation_set_type(op,SLAPI_OPERATION_MODIFY);  
		do_modify( pb );  
		break;  
  
	case LDAP_REQ_COMPARE:  
		operation_set_type(op,SLAPI_OPERATION_COMPARE);  
		do_compare( pb );  
		break;  
  
	case LDAP_REQ_SEARCH:  
		operation_set_type(op,SLAPI_OPERATION_SEARCH);  
		  
	/* OMIT FOR SIMPLICITY */  
}  
  
  
// https://github.com/389ds/389-ds-base/blob/6160200187b5b5f7ee662762b997c5c55401fe77/ldap/servers/slapd/connection.c#L2146-L2386  
  
static void  
connection_threadmain()  
{  
  
/* OMIT FOR SIMPLICITY */  
  
		/*  
		 * Call the do_<operation> function to process this request.  
		 */  
		connection_dispatch_operation(conn, op, pb);  
  
/* OMIT FOR SIMPLICITY */  
```  
