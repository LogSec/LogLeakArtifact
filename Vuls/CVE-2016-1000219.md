## Summary:  
Software: kibana  
## Fix:  
Commit: https://github.com/elastic/kibana/commit/00d0f493b91e3215703b8c8a64ec09966216ed95  
Change Size: +4 -3  
Fix Time (of the Last Commit): 2016-08-02  
Author: Lukas Olson  
Fix Pattern: Sanitization -> Redaction -> Enhancement (Corrective Change) -> Keyword/RegexBasedFiltration -> NoRedactionFunctionDefined  
  
Fixing-commits Count: 1  
Total Change Size: +4 -3  
## Sample logs: Yes  
```json  
  
{  
    "@timestamp": "2015-09-25T16:19:02+00:00",  
    "message": "GET /elasticsearch 200 5ms - 9.0B",  
    "method": "get",  
    "pid": 85866,  
    "req": {  
        "headers": {  
            "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",  
            "accept-encoding": "gzip, deflate, sdch",  
            "accept-language": "en-US,en;q=0.8",  
            "authorization": "Basic dGVzdDp0ZXN0",  
            "connection": "keep-alive",  
            "host": "localhost:5601",  
            "upgrade-insecure-requests": "1",  
            "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.99 Safari/537.36"  
        },  
        "method": "get",  
        "remoteAddress": "127.0.0.1",  
        "url": "/elasticsearch",  
        "userAgent": "127.0.0.1"  
    },  
    "res": {  
        "contentLength": 9,  
        "responseTime": 5,  
        "statusCode": 200  
    },  
    "statusCode": 200,  
    "tags": [],  
    "type": "response"  
}  
  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> HTTP basic auth credentials  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries  
Sensitiveness-Identifiable Source:  No  
Programming Language:JS  
```JavaScript  
  
// https://github.com/elastic/kibana/blob/251aa499ed063e7cf83ddbaa9437dbcc483f818d/src/server/logging/applyFilterToKey.js#L5-L23  
  
module.exports = function applyFilterToKey(obj, key, action) {  
  for (let k in obj)  {  
    if (obj.hasOwnProperty(k)) {  
      let val = obj[k];  
      if (typeof val === 'object') {  
        applyFilterToKey(val, key, action);  
      } else if (k === key) {  
        val = ''  + val;  
        if (action === 'remove') delete obj[k];  
        if (action === 'censor') {  
          obj[k] = val.replace(/./g, 'X');  
        };  
        if (action instanceof RegExp) {  
          obj[k] = val.replace(action, replacer);  
        }  
      }  
    }  
  }  
};  
  
// https://github.com/elastic/kibana/blob/251aa499ed063e7cf83ddbaa9437dbcc483f818d/src/server/logging/LogFormat.js#L29-L51  
  
module.exports = class TransformObjStream extends Stream.Transform {  
  constructor(config) {  
    super({  
      readableObjectMode: false,  
      writableObjectMode: true  
    });  
    this.config = config;  
  }  
  
  filter(data) {  
    if (this.config.filter) {  
      _.each(this.config.filter, (action, key) => {  
        applyFilterToKey(data, key, action);  
      });  
    }  
    return data;  
  }  
  
  _transform(event, enc, next) {  
    var data = this.filter(this.readEvent(event));  
    this.push(this.format(data) + '\n');  
    next();  
  }  
  
// https://github.com/elastic/kibana/blob/251aa499ed063e7cf83ddbaa9437dbcc483f818d/src/server/logging/LogReporter.js#L8-L33  
  
module.exports = class KbnLogger {  
  constructor(events, config) {  
    this.squeeze = new Squeeze(events);  
    this.format = config.json ? new LogFormatJson(config) : new LogFormatString(config);  
  
    if (config.dest === 'stdout') {  
      this.dest = process.stdout;  
    } else {  
      this.dest = writeStr(config.dest, {  
        flags: 'a',  
        encoding: 'utf8'  
      });  
    }  
  }  
  
  init(readstream, emitter, callback) {  
    readstream  
    .pipe(this.squeeze)  
    .pipe(this.format)  
    .pipe(this.dest);  
  
    emitter.on('stop', _.noop);  
  
    callback();  
  }  
};  
  
// https://github.com/elastic/kibana/blob/251aa499ed063e7cf83ddbaa9437dbcc483f818d/src/server/logging/index.js#L4-L59  
module.exports = function (kbnServer, server, config) {  // HERE IS THE FLOW  
  return fromNode(function (cb) {  
    let events = config.get('logging.events');  
  
    if (config.get('logging.silent')) {  
      _.defaults(events, {});  
    }  
    else if (config.get('logging.quiet')) {  
      _.defaults(events, {  
        log: ['listening', 'error', 'fatal'],  
        error: '*'  
      });  
    }  
    else if (config.get('logging.verbose')) {  
      _.defaults(events, {  
        log: '*',  
        ops: '*',  
        request: '*',  
        response: '*',  
        error: '*'  
      });  
    }  
    else {  
      _.defaults(events, {  
        log: ['info', 'warning', 'error', 'fatal'],  
        response: config.get('logging.json') ? '*' : '!',  
        error: '*'  
      });  
    }  
  
    server.register({  // HERE IS THE FLOW  
      register: require('good'),  
      options: {  
        opsInterval: 5000,  
        requestHeaders: true,  
        requestPayload: true,  
        reporters: [  
          {  
            reporter: require('./LogReporter'),  
            config: {  
              json: config.get('logging.json'),  
              dest: config.get('logging.dest'),  
              filter: {  
                authorization: 'remove'  
              }  
            },  
            events: _.transform(events, function (filtered, val, key) {  
              // provide a string compatible way to remove events  
              if (val !== '!') filtered[key] = val;  
            }, {})  
          }  
        ]  
      }  
    }, cb);  
  });  
};  
  
// https://github.com/elastic/kibana/blob/00d0f493b91e3215703b8c8a64ec09966216ed95/src/server/KbnServer.js#L9-L64  
module.exports = class KbnServer {  
  constructor(settings) {  
    this.name = pkg.name;  
    this.version = pkg.version;  
    this.build = pkg.build || false;  
    this.rootDir = rootDir;  
    this.settings = settings || {};  
  
    this.ready = constant(this.mixin(  
      require('./config/setup'), // sets this.config, reads this.settings  
      require('./http'), // sets this.server  
      require('./logging'),  // HERE IS THE FLOW  
      require('./status'),  
  
      // find plugins and set this.plugins  
      require('./plugins/scan'),  
  
      // tell the config we are done loading plugins  
      require('./config/complete'),  
  
      // setup this.uiExports and this.bundles  
      require('../ui'),  
  
      // ensure that all bundles are built, or that the  
      // lazy bundle server is running  
      require('../optimize'),  
  
      // finally, initialize the plugins  
      require('./plugins/initialize'),  
  
      () => {  
        if (this.config.get('server.autoListen')) {  
          this.ready = constant(resolve());  
          return this.listen();  
        }  
      }  
    ));  
  
    this.listen = once(this.listen);  
  }  
  
  /**  
   * Extend the KbnServer outside of the constraits of a plugin. This allows access  
   * to APIs that are not exposed (intentionally) to the plugins and should only  
   * be used when the code will be kept up to date with Kibana.  
   *  
   * @param {...function} - functions that should be called to mixin functionality.  
   *                         They are called with the arguments (kibana, server, config)  
   *                         and can return a promise to delay execution of the next mixin  
   * @return {Promise} - promise that is resolved when the final mixin completes.  
   */  
  async mixin(...fns) {  
    for (let fn of compact(flatten(fns))) {  
      await fn.call(this, this, this.server, this.config);  // HERE IS THE FLOW  
    }  
  }  
  
  
// https://github.com/bevacqua/even-better/blob/master/lib/monitor.js#L124-L183  
    Items.serial(this.settings.reporters, function (item, next) {  
  
        var reporter;  
  
        // If it has a reporter constructor, then create a new one, otherwise, assume it is  
        // a valid pre-constructed reporter  
        if (item.reporter) {  
  
            // If the supply a path or module node, try to load it  
            if (typeof item.reporter === 'string') {  
                item.reporter = require(item.reporter);  
            }  
  
            Hoek.assert(typeof item.reporter === 'function', 'reporter key must be a constructor function');  
            Hoek.assert(typeof item.events === 'object', 'reporter must specify events to filter on');  
  
            var Reporter = item.reporter;  
  
            reporter = new Reporter(item.events, item.config);  
        }  
        else {  
            reporter = item;  
        }  
  
        Hoek.assert(reporter.init, 'Every reporter object must have an init method');  
        reporter.init(self._dataStream, self, next); // HERE IS THE FLOW  
    }, function (error) {  
  
        if (error) {  
            return callback(error);  
        }  
  
        self._state.opsInterval = setInterval(setupOpsMonitoring(), self.settings.opsInterval);  
        self._state.opsHandler = self._opsHandler.bind(self);  
        self._state.wreckHandler = self._wreckHandler.bind(self);  
  
        self._state.handlers.log = self._logHandler.bind(self);  
        self._state.handlers['request-error'] = self._errorHandler.bind(self);  
        self._state.handlers[self.settings.responseEvent] = self._responseHandler.bind(self);  
        self._state.handlers.request = self._requestLogHandler.bind(self);  
  
        // Initialize Events  
        internals.iterateOverEventHash(self._state.handlers, function (event, handler) {  
  
            self._server.on(event, handler); // HERE IS THE FLOW  
        });  
  
        self.on('ops', self._state.opsHandler);  
        Wreck.on('response', self._state.wreckHandler);  
  
        // Events can not be any of ['log', 'request-error', 'ops', 'request', 'response', 'tail']  
        for (var i = 0, il = self.settings.extensions.length; i < il; ++i) {  
            var event = self.settings.extensions[i];  
  
            self._state.extensions[event] = self._extensionHandler.bind(self, event);  
            self._server.on(self.settings.extensions[i], self._state.extensions[event]);  
        }  
  
        return callback();  
    });  
  
  
// https://github.com/hapijs/hapi/blob/bc722ef68407c398178e72b104c4ee7e8eb4c696/lib/request.js#L190-L199  
  
    // Log request  
  
    var about = {  
        id: this.id,  
        method: this.method,  
        url: this.url.href,  
        agent: this.raw.req.headers['user-agent']  
    };  
  
    this._log(['received'], about, now);     // Must be last for object to be fully constructed // HERE IS THE SINK 1  
  
  
// https://github.com/hapijs/hapi/blob/bc722ef68407c398178e72b104c4ee7e8eb4c696/lib/request.js#L231-L263  
  
internals.Request.prototype.log = function (tags, data, timestamp, _internal) {  
  
    tags = (Array.isArray(tags) ? tags : [tags]);  
    var now = (timestamp ? (timestamp instanceof Date ? timestamp.getTime() : timestamp) : Date.now());  
  
    var event = {  
        request: this.id,  
        timestamp: now,  
        tags: tags,  
        data: data,  
        internal: !!_internal  
    };  
  
    var tagsMap = Hoek.mapToObject(event.tags);  
  
    // Add to request array  
  
    this._logger.push(event);  
    this.connection.emit(_internal ? 'request-internal' : 'request', this, event, tagsMap);  
  
    if (this.server._settings.debug &&  
        this.server._settings.debug.request &&  
        Hoek.intersect(tagsMap, this.server._settings.debug.request, true)) {  
  
        console.error('Debug:', event.tags.join(', '), (data ? '\n    ' + (data.stack || (typeof data === 'object' ? Hoek.stringify(data) : data)) : ''));  
    }  
};  
  
  
internals.Request.prototype._log = function (tags, data) {  
  
    return this.log(tags, data, null, true);  
};  
```  
