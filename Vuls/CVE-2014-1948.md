## Summary:  
Software: openstack/glance  
## Fix:  
Commit: https://github.com/openstack/glance/commit/f6e41e9c0ff3aa9ee57b8c8ed8c789f1aff019bc  
Change Size: +3 -3  
Author: Nikhil Komawar  
Fix Time (of the Last Commit): 2014-02-07  
Fix Pattern: Remove -> Logging Variables  
Fixing-commits Count: 1  
Total Change Size: +3 -3  
## Sample logs: Yes  
```  
19:13:05.027 WARNING glance.store [-] Get image <UUID> data from {'url': u'swift+https://XXXXX@my_auth_url.com/v2.0/my-images/<uuid>, 'metadata': {}} failed: Auth GET failed: https://my_auth_url.com RESP_CODE  
  
19:13:05.027 ERROR glance.store [-] Glance tried all locations to get data for image <UUID> but all have failed.  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> a URL containing the Swift store backend password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（ContextAdapter.warn）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L112） -> Variable Names（credstring）|Method Names（_get_credstring）  
Programming Language:Python  
```Python  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L105-L118  
    def get_uri(self):  
        auth_or_store_url = self.auth_or_store_url  
        if auth_or_store_url.startswith('http://'):  
            auth_or_store_url = auth_or_store_url[len('http://'):]  
        elif auth_or_store_url.startswith('https://'):  
            auth_or_store_url = auth_or_store_url[len('https://'):]  
  
        credstring = self._get_credstring() # HERE IS THE SOURCE  
        auth_or_store_url = auth_or_store_url.strip('/')  
        container = self.container.strip('/')  
        obj = self.obj.strip('/')  
  
        return '%s://%s%s/%s/%s' % (self.scheme, credstring, auth_or_store_url,  
                                    container, obj)  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L280-L383  
    def add(self, image_id, image_file, image_size, connection=None):  
        location = self.create_location(image_id)  
        if not connection:  
            connection = self.get_connection(location)  
  
        self._create_container_if_missing(location.container, connection)  
  
        LOG.debug(_("Adding image object '%(obj_name)s' "  
                    "to Swift") % dict(obj_name=location.obj))  
        try:  
            if image_size > 0 and image_size < self.large_object_size:  
                # Image size is known, and is less than large_object_size.  
                # Send to Swift with regular PUT.  
                obj_etag = connection.put_object(location.container,  
                                                 location.obj, image_file,  
                                                 content_length=image_size)  
            else:  
                # Write the image into Swift in chunks.  
                chunk_id = 1  
                if image_size > 0:  
                    total_chunks = str(int(  
                        math.ceil(float(image_size) /  
                                  float(self.large_object_chunk_size))))  
                else:  
                    # image_size == 0 is when we don't know the size  
                    # of the image. This can occur with older clients  
                    # that don't inspect the payload size.  
                    LOG.debug(_("Cannot determine image size. Adding as a "  
                                "segmented object to Swift."))  
                    total_chunks = '?'  
  
                checksum = hashlib.md5()  
                combined_chunks_size = 0  
                while True:  
                    chunk_size = self.large_object_chunk_size  
                    if image_size == 0:  
                        content_length = None  
                    else:  
                        left = image_size - combined_chunks_size  
                        if left == 0:  
                            break  
                        if chunk_size > left:  
                            chunk_size = left  
                        content_length = chunk_size  
  
                    chunk_name = "%s-%05d" % (location.obj, chunk_id)  
                    reader = ChunkReader(image_file, checksum, chunk_size)  
                    chunk_etag = connection.put_object(  
                        location.container, chunk_name, reader,  
                        content_length=content_length)  
                    bytes_read = reader.bytes_read  
                    msg = _("Wrote chunk %(chunk_name)s (%(chunk_id)d/"  
                            "%(total_chunks)s) of length %(bytes_read)d "  
                            "to Swift returning MD5 of content: "  
                            "%(chunk_etag)s")  
                    LOG.debug(msg % locals())  
  
                    if bytes_read == 0:  
                        # Delete the last chunk, because it's of zero size.  
                        # This will happen if size == 0.  
                        LOG.debug(_("Deleting final zero-length chunk"))  
                        connection.delete_object(location.container,  
                                                 chunk_name)  
                        break  
  
                    chunk_id += 1  
                    combined_chunks_size += bytes_read  
  
                # In the case we have been given an unknown image size,  
                # set the size to the total size of the combined chunks.  
                if image_size == 0:  
                    image_size = combined_chunks_size  
  
                # Now we write the object manifest and return the  
                # manifest's etag...  
                manifest = "%s/%s" % (location.container, location.obj)  
                headers = {'ETag': hashlib.md5("").hexdigest(),  
                           'X-Object-Manifest': manifest}  
  
                # The ETag returned for the manifest is actually the  
                # MD5 hash of the concatenated checksums of the strings  
                # of each chunk...so we ignore this result in favour of  
                # the MD5 of the entire image file contents, so that  
                # users can verify the image file contents accordingly  
                connection.put_object(location.container, location.obj,  
                                      None, headers=headers)  
                obj_etag = checksum.hexdigest()  
  
            # NOTE: We return the user and key here! Have to because  
            # location is used by the API server to return the actual  
            # image data. We *really* should consider NOT returning  
            # the location attribute from GET /images/<ID> and  
            # GET /images/details  
  
            return (location.get_uri(), image_size, obj_etag) # HERE IS THE FLOW  
        except swiftclient.ClientException, e:  
            if e.http_status == httplib.CONFLICT:  
                raise exception.Duplicate(_("Swift already has an image at "  
                                            "location %s") %  
                                          location.get_uri())  
            msg = (_("Failed to add object to Swift.\n"  
                     "Got error from Swift: %(e)s") % locals())  
            LOG.error(msg)  
            raise glance.store.BackendException(msg)  
  
# https://github.com/openstack/glance/blob/fd99958b333a234f01fe0dbca3b1520e076d06e0/glance/store/__init__.py#L352-L393  
def store_add_to_backend(image_id, data, size, store):  
    """  
    A wrapper around a call to each stores add() method.  This gives glance  
    a common place to check the output  
    :param image_id:  The image add to which data is added  
    :param data: The data to be stored  
    :param size: The length of the data in bytes  
    :param store: The store to which the data is being added  
    :return: The url location of the file,  
             the size amount of data,  
             the checksum of the data  
             the storage systems metadata dictionary for the location  
    """  
    (location, size, checksum, metadata) = store.add(image_id, data, size)  # HERE IS THE FLOW  
    if metadata is not None:  
        if not isinstance(metadata, dict):  
            msg = (_("The storage driver %(store)s returned invalid metadata "  
                     "%(metadata)s. This must be a dictionary type") %  
                   {'store': store,  
                    'metadata': metadata})  
            LOG.error(msg)  
            raise BackendException(msg)  
        try:  
            check_location_metadata(metadata)  
        except BackendException as e:  
            e_msg = (_("A bad metadata structure was returned from the "  
                       "%(store)s storage driver: %(metadata)s.  %(error)s.") %  
                     {'store': store,  
                      'metadata': metadata,  
                      'error': e})  
            LOG.error(e_msg)  
            raise BackendException(e_msg)  
    return (location, size, checksum, metadata)  
  
  
def add_to_backend(context, scheme, image_id, data, size):  
    store = get_store_from_scheme(context, scheme)  
    try:  
        return store_add_to_backend(image_id, data, size, store)  # HERE IS THE FLOW  
    except NotImplementedError:  
        raise exception.StoreAddNotSupported  
  
# https://github.com/openstack/glance/blob/fd99958b333a234f01fe0dbca3b1520e076d06e0/glance/store/__init__.py#L668-L723  
  
class ImageProxy(glance.domain.proxy.Image):  
  
    locations = _locations_proxy('image', 'locations')  
  
    def __init__(self, image, context, store_api):  
        self.image = image  
        self.context = context  
        self.store_api = store_api  
        proxy_kwargs = {  
            'context': context,  
            'image': self,  
            'store_api': store_api,  
        }  
        super(ImageProxy, self).__init__(  
            image, member_repo_proxy_class=ImageMemberRepoProxy,  
            member_repo_proxy_kwargs=proxy_kwargs)  
  
    def delete(self):  
        self.image.delete()  
        if self.image.locations:  
            for location in self.image.locations:  
                self.store_api.delete_image_from_backend(self.context,  
                                                         self.store_api,  
                                                         self.image.image_id,  
                                                         location['url'])  
  
    def set_data(self, data, size=None):  
        if size is None:  
            size = 0  # NOTE(markwash): zero -> unknown size  
        location, size, checksum, loc_meta = self.store_api.add_to_backend(  
            self.context, CONF.default_store,  
            self.image.image_id, utils.CooperativeReader(data), size) # HERE IS THE FLOW  
        self.image.locations = [{'url': location, 'metadata': loc_meta}]  
        self.image.size = size  
        self.image.checksum = checksum  
        self.image.status = 'active'  
  
    def get_data(self):  
        if not self.image.locations:  
            raise exception.NotFound(_("No image data could be found"))  
        err = None  
        for loc in self.image.locations:  
            try:  
                data, size = self.store_api.get_from_backend(self.context,  
                                                             loc['url'])  
  
                return data  
            except Exception as e:  
                LOG.warn(_('Get image %(id)s data from %(loc)s '  
                           'failed: %(err)s.') % {'id': self.image.image_id,  
                                                  'loc': loc, 'err': e}) # HERE IS THE SINK 1  
                err = e  
        # tried all locations  
        LOG.error(_('Glance tried all locations to get data for image %s '  
                    'but all have failed.') % self.image.image_id)  
        raise err  
  
```  
