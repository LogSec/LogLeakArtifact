## Summary:  
Software: firefox  
## Fix:  
https://hg.mozilla.org/mozilla-central/rev/1cf4808e78d9  
Author: Mark Finkle <mfinkle@mozilla.com>  
Fix Time (of the Last Commit): 2015-04-06  
Fix Pattern: Remove -> Logging Calls    
Fixing-commits Count: 1  
Total Change Size: +1 -1  

## Sample logs: Yes  
```  
W/GeckoConsole( 1364): [JavaScript Warning: "Loading mixed (insecure) display content "http://ie.microsoft.com/testdrive/browser/mixedcontent/assets/images/small_biz.png" on a secure page" {file: "https://ie.microsoft.com/testdrive/browser/mixedcontent/assets/woodgrove.htm?SECRET#SECRET" line: 0}]  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:Unspecified -> sensitive information  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（__android_log_print）  
Sensitiveness-Identifiable Source:  No  
Programming Language:C/C++  
```C++  
// https://hg.mozilla.org/mozilla-central/file/1cf4808e78d93df99eb983ff8119d724db516be8/xpcom/base/nsConsoleService.cpp#l243  
  
// nsIConsoleService methods  
+  
−NS_IMETHODIMP  
nsConsoleService::LogMessage(nsIConsoleMessage* aMessage)  
{  
  return LogMessageWithMode(aMessage, OutputToLog);  
}  
  
nsresult  
nsConsoleService::LogMessageWithMode(nsIConsoleMessage* aMessage,  
                                     nsConsoleService::OutputMode aOutputMode)  
{  
  if (!aMessage) {  
    return NS_ERROR_INVALID_ARG;  
  }  
  
  if (!sLoggingEnabled) {  
    return NS_OK;  
  }  
  
  if (NS_IsMainThread() && mDeliveringMessage) {  
    nsCString msg;  
    aMessage->ToString(msg);  
    NS_WARNING(nsPrintfCString("Reentrancy error: some client attempted "  
      "to display a message to the console while in a console listener. "  
      "The following message was discarded: \"%s\"", msg.get()).get());  
    return NS_ERROR_FAILURE;  
  }  
  
  nsRefPtr<LogMessageRunnable> r;  
  nsIConsoleMessage* retiredMessage;  
  
  if (sLoggingBuffered) {  
    NS_ADDREF(aMessage); // early, in case it's same as replaced below.  
  }  
  
  /*  
   * Lock while updating buffer, and while taking snapshot of  
   * listeners array.  
   */  
  {  
    MutexAutoLock lock(mLock);  
  
#if defined(ANDROID) && !defined(RELEASE_BUILD)  
    if (aOutputMode == OutputToLog) {  
      nsCString msg;  
      aMessage->ToString(msg);  
  
      /** Attempt to use the process name as the log tag. */  
      mozilla::dom::ContentChild* child =  
          mozilla::dom::ContentChild::GetSingleton();  
      nsCString appName;  
      if (child) {  
        child->GetProcessName(appName);  
      } else {  
        appName = "GeckoConsole";  
      }  
  
      uint32_t logLevel = 0;  
      aMessage->GetLogLevel(&logLevel);  
  
      android_LogPriority logPriority = ANDROID_LOG_INFO;  
      switch (logLevel) {  
        case nsIConsoleMessage::debug:  
          logPriority = ANDROID_LOG_DEBUG;  
          break;  
        case nsIConsoleMessage::info:  
          logPriority = ANDROID_LOG_INFO;  
          break;  
        case nsIConsoleMessage::warn:  
          logPriority = ANDROID_LOG_WARN;  
          break;  
        case nsIConsoleMessage::error:  
          logPriority = ANDROID_LOG_ERROR;  
          break;  
      }  
  
      __android_log_print(logPriority, appName.get(), "%s", msg.get()); // HERE IS THE SINK 1  
    }  
#endif  
#ifdef XP_WIN  
    if (IsDebuggerPresent()) {  
      nsString msg;  
      aMessage->GetMessageMoz(getter_Copies(msg));  
      msg.Append('\n');  
      OutputDebugStringW(msg.get());  
    }  
#endif  
#ifdef MOZ_TASK_TRACER  
    {  
      nsCString msg;  
      aMessage->ToString(msg);  
      int prefixPos = msg.Find(GetJSLabelPrefix());  
      if (prefixPos >= 0) {  
        nsDependentCSubstring submsg(msg, prefixPos);  
        AddLabel("%s", submsg.BeginReading());  
      }  
    }  
#endif  
  
    /*  
     * If there's already a message in the slot we're about to replace,  
     * we've wrapped around, and we need to release the old message.  We  
     * save a pointer to it, so we can release below outside the lock.  
     */  
    retiredMessage = mMessages[mCurrent];  
  
    if (sLoggingBuffered) {  
      mMessages[mCurrent++] = aMessage;  
      if (mCurrent == mBufferSize) {  
        mCurrent = 0; // wrap around.  
        mFull = true;  
      }  
    }  
  
    if (mListeners.Count() > 0) {  
      r = new LogMessageRunnable(aMessage, this);  
    }  
  }  
  
  if (retiredMessage) {  
    NS_RELEASE(retiredMessage);  
  }  
  
  if (r) {  
    NS_DispatchToMainThread(r);  
  }  
  
  return NS_OK;  
}  
  
  
NS_IMETHODIMP  
nsConsoleService::LogStringMessage(const char16_t* aMessage)  
{  
  if (!sLoggingEnabled) {  
    return NS_OK;  
  }  
  
  nsRefPtr<nsConsoleMessage> msg(new nsConsoleMessage(aMessage));  
  return this->LogMessage(msg);  
}  
  
  
  
#endif  
  
```  
