## Summary:  
Software: ambari  
## Fix:  
Commit: https://github.com/rlevas/ambari/commit/f51977ce085face91b3c4e646127efe0a0144f5c  
Author: Robert Levas  
Fix Time (of the Last Commit): 2018-07-09  
  
Fix Pattern: Disable Logging in Default  
  
Fixing-commits Count: 1  
Total Change Size: +2 -2  
  
========  
PR: https://github.com/apache/ambari/pull/1711  
Commit: https://github.com/rlevas/ambari/commit/f51977ce085face91b3c4e646127efe0a0144f5c  
Change Size: +2 -2  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> passwords for Hadoop credential stores  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（log_function_call）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/rlevas/ambari/blob/f51977ce/ambari-common/src/main/python/ambari_commons/credential_store_helper.py#L47） -> Method Names（get_password_from_credential_store）  
Programming Language:Python  
```Python  
  
# https://github.com/rlevas/ambari/blob/f51977ce085face91b3c4e646127efe0a0144f5c/ambari-common/src/main/python/ambari_commons/credential_store_helper.py#L47-L55  
  
def get_password_from_credential_store(alias, provider_path, cs_lib_path, java_home, jdk_location):  
    downloadjar(cs_lib_path, jdk_location)  
  
    # Execute a get command on the CredentialUtil CLI to get the password for the specified alias  
    java_bin = '{java_home}/bin/java'.format(java_home=java_home)  
    cmd = (java_bin, '-cp', cs_lib_path, credential_util_cmd, 'get', alias, '-provider', provider_path)  
    cmd_result, std_out_msg  = checked_call(cmd, quite=True)  
    std_out_lines = std_out_msg.split('\n')  
    return(std_out_lines[-1]) # Get the last line of the output, to skip warnings if any.  
  
  
# https://github.com/apache/ambari/blob/24dbed27b97f4c82835273758f0bceb3334b4ef2/ambari-common/src/main/python/resource_management/core/shell.py#L51-L80  
  
def log_function_call(function):  
  def inner(command, **kwargs):  
    caller_filename = sys._getframe(1).f_code.co_filename  
    # quiet = can be False/True or None -- which means undefined yet  
    quiet = kwargs['quiet'] if 'quiet' in kwargs else None  
    is_internal_call = NOT_LOGGED_FOLDER in caller_filename  
      
    if quiet == False or (quiet == None and not is_internal_call):  
      command_repr = Logger._get_resource_name_repr(command)  
      log_msg = Logger.get_function_repr("{0}[{1}]".format(function.__name__, command_repr), kwargs)  
      Logger.info(log_msg) # HERE IS THE INNER SINK  
        
    # logoutput=False - never log  
    # logoutput=True - log in INFO level  
    # logouput=None - log in DEBUG level  
    # logouput=not-specified - log in DEBUG level, not counting internal calls  
    if 'logoutput' in function.func_code.co_varnames:  
      kwargs['logoutput'] = ('logoutput' in kwargs and kwargs['logoutput'] and Logger.isEnabledFor(logging.INFO)) or \  
        ('logoutput' in kwargs and kwargs['logoutput']==None and Logger.isEnabledFor(logging.DEBUG)) or \  
        (not 'logoutput' in kwargs and not is_internal_call and Logger.isEnabledFor(logging.DEBUG))  
         
    result = function(command, **kwargs)  
      
    if quiet == False or (quiet == None and not is_internal_call):  
      log_msg = "{0} returned {1}".format(function.__name__, result)  
      Logger.info(log_msg) # HERE IS THE INNER SINK  
        
    return result  
      
  return inner  
  
# https://github.com/apache/ambari/blob/24dbed27b97f4c82835273758f0bceb3334b4ef2/ambari-common/src/main/python/resource_management/core/shell.py#L90-L102  
  
@log_function_call # HERE IS THE SINK 1  
def checked_call(command, quiet=False, logoutput=None, stdout=subprocess32.PIPE,stderr=subprocess32.STDOUT,  
         cwd=None, env=None, preexec_fn=preexec_fn, user=None, wait_for_finish=True, timeout=None, on_timeout=None,  
         path=None, sudo=False, on_new_line=None, tries=1, try_sleep=0, timeout_kill_strategy=TerminateStrategy.TERMINATE_PARENT, returns=[0]):  
  """  
  Execute the shell command and throw an exception on failure.  
  @throws Fail  
  @return: return_code, output  
  """  
  return _call_wrapper(command, logoutput=logoutput, throw_on_failure=True, stdout=stdout, stderr=stderr,  
                              cwd=cwd, env=env, preexec_fn=preexec_fn, user=user, wait_for_finish=wait_for_finish,   
                              on_timeout=on_timeout, timeout=timeout, path=path, sudo=sudo, on_new_line=on_new_line,  
                              tries=tries, try_sleep=try_sleep, timeout_kill_strategy=timeout_kill_strategy, returns=returns)  
  
```  
