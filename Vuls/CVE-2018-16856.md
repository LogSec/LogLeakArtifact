## Summary:  
Software: openstack/octavia  
## Fix:  
Commit: https://github.com/openstack/octavia/commit/f8e7a15695acb82949f73775b2f0a1e762bd3c5f  
Author: Nir Magnezi  
Fix Time (of the Last Commit): 2019-03-06  
Fix Pattern: Encrypt  
Fix   
  
Fixing-commits Count: 2  
Total Change Size: +118 -80  
  
========  
Commit: https://github.com/openstack/octavia/commit/2bd9b68dd1a77723f0d62ac170172333a356aace  
Change Size: +13 -1  
Commit: https://github.com/openstack/octavia/commit/f8e7a15695acb82949f73775b2f0a1e762bd3c5f  
Change Size: +105 -79  
## Sample logs: Yes  
```  
2019-08-24 16:23:43.013 675855 WARNING octavia.controller.worker.controller_worker [-] Task 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-amp-compute-connectivity-wait' (1858607d-f808-494f-8ead-8e4bc012a3e2) transitioned into state 'FAILURE' from state 'RUNNING'  
19 predecessors (most recent first):  
  Atom 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-update-amphora-info' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'amphora_id': '83c91d18-4a47-4316-ac14-4d352d92b155', 'compute_obj': <octavia.common.data_models.Amphora object at 0x7fbc2554a4a8>}, 'provides': <octavia.common.data_models.Amphora object at 0x7fbc2553fda0>}  
  |__Atom 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-compute-wait' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'compute_id': '5adb2815-aeb5-4a48-be84-718023ce894d', 'amphora_id': '83c91d18-4a47-4316-ac14-4d352d92b155'}, 'provides': <octavia.common.data_models.Amphora object at 0x7fbc2554a4a8>}  
     |__Atom 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-mark-amphora-booting-indb' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'amphora_id': '83c91d18-4a47-4316-ac14-4d352d92b155', 'compute_id': '5adb2815-aeb5-4a48-be84-718023ce894d'}, 'provides': None}  
        |__Atom 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-update-amphora-computeid' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'amphora_id': '83c91d18-4a47-4316-ac14-4d352d92b155', 'compute_id': '5adb2815-aeb5-4a48-be84-718023ce894d'}, 'provides': None}  
           |__Atom 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-cert-compute-create' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'amphora_id': '83c91d18-4a47-4316-ac14-4d352d92b155', 'server_pem': b'gAAAAABdYWRcWssCzvjluRkDw37iWz_Bt88UdyE5AFTwPPN9lrTFQfzpaqlkk8iJD6stpZuYAuw6K7ddb95TUPi18lyBiz_uqfwEXSXwl-tWiaezf_MZE4GbIYER7RNDm2KYMDJb73M-4hBBoGyKQroeGSrtIYAmJpkWhPF_IZUFCyq8TB_X6LfL7k_mldJiylqY8nlVTSS4lICkzlts4WsFOOU7oRkGix21jES9hYP-Uno82iafeLcPQd8T9bC-p4J8xtg8a3CUvTb3rb85iUo8iuIfeA8jkr-oe4hLbYF4vbO2LT53oQvtjl8WjAqjidUEPummy-gsB7iRlhotMoa0XgpQsP3fSiItsqnOs7Q6XWgezGRACrBkQqX6M3NXKhzIXr-fkPAmf53LNyCvhBTzn_zd-D3hM3kjBfyw8KWCvlLmw1ea42FsBhxZFEmTfOw3er-QqAacLYmfABvIT1Ylwfv8X3zCndE8CqrED1hXCwD-14tB3RuZ8T45C274ldINC7I64Tmd6M5z-9oZ8hxRHY12njQh8GgHO1489ijBw4mLy_PF0IxLwpK0VJrWeaDXzPw6EvgiXCbdZppCfbkq4hTZ-YPuiDcn2TYcylwmF9MJWQhZfBE4ygDqHhacXZu5tAe3vmaQgfd3_Bmn8fPzaU-_8moeelRHE3mOpp_h-A7DRWIE344zdd2ZjIq8cUYYxnVuwzwIhsYBfRbJGy7_2X3Gf32HNOGGLX_iHlYZubWUu9p_qx-V1WNgOt9sX6C5n6t-bDtgEOkt6JV7KZQEsnbYxx76ZTw352AN9JiK1ra9Cxu37usdwvKvYLgf_kA1AWdSHHTBLloQhAYiBzUowQt5q7D2kzkL1W_N2Oo3bz-bIJFCiUC3ST4OE5ytaN399HOqcO_Pu0E-Fv-PmhCSiZ8mUmSEnLqJVSIpXD0W9BwkTwbhr5Lsg2ay6rvIozzDoLsfkfquhDnonFBvVz3ZkGCPharp7I5VMpfKQnE4rqlQjUfgicgB7t9iAJ9flBKTQfDCcYGHtZcroVgl21GUF9W9nOGp7mu_tbx93YUJkNN_oVSQCjbJc388serm5OjhrZ3jG--FzigLKnv9W6oyt8ATW_UUfBkSVkCuj3lvJJMmfV5MA3yVoCU9g9i5dvbVVAGfraCazZre1WrTQ7DFHus7xPHOzsLE45GHvUwlnlx6l7im0LVIQ2OwUWIDWA4dgfgK6OqDFOfTyhMfSTQ5iJOX1wBa4W8LXYCq17H_vkutKm8hrDJ-D5e3qrePYD6EQpSLSxyGFxRbRcFKWzTQM-0MO2GTpH8HVht07XCDa_387PHfwsp2NOS9hfGU6alswJpQN73x34I4WCtRSpG1_1e7owdw3ReUTJeYviDNKJuQx32aHp5eJt_neEAtpLdvWBROPFp7NDt8UFMPeb2JAJwolvhQoQoI3BhP0MLQ8k9cc1GB2amncCwC4zqVrrAz7XmAT4tQ_cD573Vn2udLXbXHlOXCz3b_0BSO9LwdTa0R8wMi_RAgk79TYquakc2DFk3YeoGAbJaiha3p_NjvH9HVp9xEAxKdSuUZp_FYvYLEggEsT35R7jVNP6omdtpntVztTB-BEQKioOeQXA9wOq85Hz3KtvYVjFha3z8dDaunDIe6IDG7WGF38JeFeRLi0WHxXv_vT7V4hJs5cUpx087uMy-ovIBf67keEG2iwc56uIJg6m-gGCWCBuoDcZDWVqsn1A3DI1XomQrgJXwctUwtJbd6xH0ohwib0F-e7ei32YonYN-Mp3sbQjjdiz4r2_sRA4p9Wwp_d7NpubZm9im7cRiRU5wfd-V8zmeyNQNkTXJMTAruAqpeoXG3fLUqiU_ICrhojyPqs5My7Z5PZApplX55h2mdKLUC_HtCJV1oACVwaGfiCaJbAu0Q0NAGxONfft5p7Ow4dd1xY5kqgY7ZNuMnxNnR6lBvoNZy_PEb_09SZePSo8Ers8pfZgPM1veF0KR1PBjzVlf9mHAXwG2lQ6_VKJzasyPHekMWpJW69Uep96a_hc76IsPo6F3tcirRSFRSXE4gWvItLQDxbCEr21ADrVat483H8aABM82dVKNzpOSy4oXR6-Vi4Oufd9mVRs3WmA3pvWWQRkgRsgAjzVvEvh8zlUIkS5Fvnxo73SM6_eSn__C1M_iIUYLdVzIgyQ4drJsdAg_-4-bx0seP8nlY20GDqA2SfhM56lPB5XhrhugfiaxaEXu1fD5kdb47TZRk2t9hfhfFFheS-6W3-xzBbbS_6N4dxN7Itb4hgt7cGb0Ey0BfjjGfdpqPL0bTwme5KY4Ryocl9x6opzHxOxSeVEjA85BJudhfJgQDRFqjNO7d67wEEO7j03hQX67hqnwmqG1FdFjENIygPkv_iUm6D5FLCh-fdLeM3ejRcp0_r1FazysBiMbQ9Mxf213k6LMUd2O1mUQ2y4K0ZWYWtE07TtB46opUvzwrOFE74xudsFprefQdvP7OLu1PlI_ODi0G3hLhRtGqTTo8aIFl7H-_1pVTy-DnKLgIt1yz__7A5gtxHeKghtymQrRbAhLKZNKbZoyjliwZSmCWuPA959RSI3gVx1No10tydN2ZDUqcfKqGmfT-tUQkjr2x6kzPh_C87NcSlsmjweHaDmzwqGhIzarIljEAB5P6vGEzoKsVn2soY2VOUQdWPotdqjqf8P1YIuB3b1lMHUYvljIYR4ceuhvol8sR2xWMkp9Md-XUPxTT1AtqsU3sKwAInQviYcpywDB6aSrH8ZIZRYC3f1oHoO6k9wQ73zVDiQPXLqpDNvylEB5x9Hgrb8SQPGTcaywtT_PBkUQZXG_F7RDqABbRpY7FaYpk_xGkyv_j_caJdgP7wR1yWabas8RtCm0d9leN6nVaP4lstxsdBAMkPucY5M-WtOdobvnbuf9Y-Lnz8wLInNVkyFgOD_uFeJPRTe_7N6isP0m1175GHHVZn_8sWH9LA0buyx3iLcmNdVTMnkGIzXtr4h_d89-oflxc-1O97KiCaRE3fMFNIlUTKpMo_qc1FggTYtYAnL-WkG1nNdk_KXaAjG7dvLund0O8LSpB0AlLAyRcHcx-3i52jXh1VlRvkTo1tC3CjLf0ocZs7TNYXf8Liq9VfRJlFnrv_R-tl00arzWxioyIk5O1A_qAe_Yv6HaF7O_91zsdgViPBCWHNlFY4E54ZduhwDnPpU_UKQjzpvCMCJuxJZW9waGSuhsdDt4MjZHVk50LWuo3PB4EA0GgUsmu7mW21cNAFJutj1EL6fN8QspHELuHGNCGjWzCziGJb7Qn8lSHBT2D2_u870FSdBU6Pl3E_o8EZ5BFT_5VuirkNF0lm0ZQD5g9woXdYwaEjQU3RIJCbVhPTH9nrcJsV8BZLh_CYnfMtVqRa48snqJ1wotdk6M5qA0Fq6YEND05Vyth1irb6m2uLaeq0S9zzpx3HFjj_wRso7LvMgw3sI4VotjJVeY0tHmXXSMbPe74RkcKPzd0_ISwz_X2JLq1J8ZDzwt5s237KAjWTF02Kc3Yv47aysYMXIPoc4F1EF_VLc-ydS_pg2-pJuN3vxAvEjLjAivZPJok3u7IYsNm0ra8r0iZmTyOC2opgyN7Oq1_AEiPdNy1gnh50u24vJmSVe4zt2-27Ep48oitjlElX6vHtlrJCt7vnl0iML5d7NNilhPZUY2DVaFLwJP3Mpi1LcWadNoXluge0VmausBnRcXpYXhQ9R3KtH0h_d1t-Eq8y8inFLKWUzGIIeEWmuk9_CqsrqDOfINPbfIKO72U1TOuxBFRBmC7JwIx8yIjKAtYwMR_G4eWTjvNnVEo_oEAEShJKGcdvMZQNbtbGNHc2Uw7AV25BabEncrFf2tYgR6DmRB0xcZPzldA7-Fprsq_GcgLiEJkzHFoE6U_vO05Vq45-8pfjHJsKVU20W3hXH57bj7tN22PwYk7wZ4EZRfVXPIix73_2KZ9SLRUw3B8d4zwjkxpg3HgX6Sl2w==', 'build_type_priority': 40, 'flavor': {}}, 'provides': '5adb2815-aeb5-4a48-be84-718023ce894d'}  
              |__Atom 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-update-cert-expiration' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'amphora_id': '83c91d18-4a47-4316-ac14-4d352d92b155', 'server_pem': b'gAAAAABdYWRcWssCzvjluRkDw37iWz_Bt88UdyE5AFTwPPN9lrTFQfzpaqlkk8iJD6stpZuYAuw6K7ddb95TUPi18lyBiz_uqfwEXSXwl-tWiaezf_MZE4GbIYER7RNDm2KYMDJb73M-4hBBoGyKQroeGSrtIYAmJpkWhPF_IZUFCyq8TB_X6LfL7k_mldJiylqY8nlVTSS4lICkzlts4WsFOOU7oRkGix21jES9hYP-Uno82iafeLcPQd8T9bC-p4J8xtg8a3CUvTb3rb85iUo8iuIfeA8jkr-oe4hLbYF4vbO2LT53oQvtjl8WjAqjidUEPummy-gsB7iRlhotMoa0XgpQsP3fSiItsqnOs7Q6XWgezGRACrBkQqX6M3NXKhzIXr-fkPAmf53LNyCvhBTzn_zd-D3hM3kjBfyw8KWCvlLmw1ea42FsBhxZFEmTfOw3er-QqAacLYmfABvIT1Ylwfv8X3zCndE8CqrED1hXCwD-14tB3RuZ8T45C274ldINC7I64Tmd6M5z-9oZ8hxRHY12njQh8GgHO1489ijBw4mLy_PF0IxLwpK0VJrWeaDXzPw6EvgiXCbdZppCfbkq4hTZ-YPuiDcn2TYcylwmF9MJWQhZfBE4ygDqHhacXZu5tAe3vmaQgfd3_Bmn8fPzaU-_8moeelRHE3mOpp_h-A7DRWIE344zdd2ZjIq8cUYYxnVuwzwIhsYBfRbJGy7_2X3Gf32HNOGGLX_iHlYZubWUu9p_qx-V1WNgOt9sX6C5n6t-bDtgEOkt6JV7KZQEsnbYxx76ZTw352AN9JiK1ra9Cxu37usdwvKvYLgf_kA1AWdSHHTBLloQhAYiBzUowQt5q7D2kzkL1W_N2Oo3bz-bIJFCiUC3ST4OE5ytaN399HOqcO_Pu0E-Fv-PmhCSiZ8mUmSEnLqJVSIpXD0W9BwkTwbhr5Lsg2ay6rvIozzDoLsfkfquhDnonFBvVz3ZkGCPharp7I5VMpfKQnE4rqlQjUfgicgB7t9iAJ9flBKTQfDCcYGHtZcroVgl21GUF9W9nOGp7mu_tbx93YUJkNN_oVSQCjbJc388serm5OjhrZ3jG--FzigLKnv9W6oyt8ATW_UUfBkSVkCuj3lvJJMmfV5MA3yVoCU9g9i5dvbVVAGfraCazZre1WrTQ7DFHus7xPHOzsLE45GHvUwlnlx6l7im0LVIQ2OwUWIDWA4dgfgK6OqDFOfTyhMfSTQ5iJOX1wBa4W8LXYCq17H_vkutKm8hrDJ-D5e3qrePYD6EQpSLSxyGFxRbRcFKWzTQM-0MO2GTpH8HVht07XCDa_387PHfwsp2NOS9hfGU6alswJpQN73x34I4WCtRSpG1_1e7owdw3ReUTJeYviDNKJuQx32aHp5eJt_neEAtpLdvWBROPFp7NDt8UFMPeb2JAJwolvhQoQoI3BhP0MLQ8k9cc1GB2amncCwC4zqVrrAz7XmAT4tQ_cD573Vn2udLXbXHlOXCz3b_0BSO9LwdTa0R8wMi_RAgk79TYquakc2DFk3YeoGAbJaiha3p_NjvH9HVp9xEAxKdSuUZp_FYvYLEggEsT35R7jVNP6omdtpntVztTB-BEQKioOeQXA9wOq85Hz3KtvYVjFha3z8dDaunDIe6IDG7WGF38JeFeRLi0WHxXv_vT7V4hJs5cUpx087uMy-ovIBf67keEG2iwc56uIJg6m-gGCWCBuoDcZDWVqsn1A3DI1XomQrgJXwctUwtJbd6xH0ohwib0F-e7ei32YonYN-Mp3sbQjjdiz4r2_sRA4p9Wwp_d7NpubZm9im7cRiRU5wfd-V8zmeyNQNkTXJMTAruAqpeoXG3fLUqiU_ICrhojyPqs5My7Z5PZApplX55h2mdKLUC_HtCJV1oACVwaGfiCaJbAu0Q0NAGxONfft5p7Ow4dd1xY5kqgY7ZNuMnxNnR6lBvoNZy_PEb_09SZePSo8Ers8pfZgPM1veF0KR1PBjzVlf9mHAXwG2lQ6_VKJzasyPHekMWpJW69Uep96a_hc76IsPo6F3tcirRSFRSXE4gWvItLQDxbCEr21ADrVat483H8aABM82dVKNzpOSy4oXR6-Vi4Oufd9mVRs3WmA3pvWWQRkgRsgAjzVvEvh8zlUIkS5Fvnxo73SM6_eSn__C1M_iIUYLdVzIgyQ4drJsdAg_-4-bx0seP8nlY20GDqA2SfhM56lPB5XhrhugfiaxaEXu1fD5kdb47TZRk2t9hfhfFFheS-6W3-xzBbbS_6N4dxN7Itb4hgt7cGb0Ey0BfjjGfdpqPL0bTwme5KY4Ryocl9x6opzHxOxSeVEjA85BJudhfJgQDRFqjNO7d67wEEO7j03hQX67hqnwmqG1FdFjENIygPkv_iUm6D5FLCh-fdLeM3ejRcp0_r1FazysBiMbQ9Mxf213k6LMUd2O1mUQ2y4K0ZWYWtE07TtB46opUvzwrOFE74xudsFprefQdvP7OLu1PlI_ODi0G3hLhRtGqTTo8aIFl7H-_1pVTy-DnKLgIt1yz__7A5gtxHeKghtymQrRbAhLKZNKbZoyjliwZSmCWuPA959RSI3gVx1No10tydN2ZDUqcfKqGmfT-tUQkjr2x6kzPh_C87NcSlsmjweHaDmzwqGhIzarIljEAB5P6vGEzoKsVn2soY2VOUQdWPotdqjqf8P1YIuB3b1lMHUYvljIYR4ceuhvol8sR2xWMkp9Md-XUPxTT1AtqsU3sKwAInQviYcpywDB6aSrH8ZIZRYC3f1oHoO6k9wQ73zVDiQPXLqpDNvylEB5x9Hgrb8SQPGTcaywtT_PBkUQZXG_F7RDqABbRpY7FaYpk_xGkyv_j_caJdgP7wR1yWabas8RtCm0d9leN6nVaP4lstxsdBAMkPucY5M-WtOdobvnbuf9Y-Lnz8wLInNVkyFgOD_uFeJPRTe_7N6isP0m1175GHHVZn_8sWH9LA0buyx3iLcmNdVTMnkGIzXtr4h_d89-oflxc-1O97KiCaRE3fMFNIlUTKpMo_qc1FggTYtYAnL-WkG1nNdk_KXaAjG7dvLund0O8LSpB0AlLAyRcHcx-3i52jXh1VlRvkTo1tC3CjLf0ocZs7TNYXf8Liq9VfRJlFnrv_R-tl00arzWxioyIk5O1A_qAe_Yv6HaF7O_91zsdgViPBCWHNlFY4E54ZduhwDnPpU_UKQjzpvCMCJuxJZW9waGSuhsdDt4MjZHVk50LWuo3PB4EA0GgUsmu7mW21cNAFJutj1EL6fN8QspHELuHGNCGjWzCziGJb7Qn8lSHBT2D2_u870FSdBU6Pl3E_o8EZ5BFT_5VuirkNF0lm0ZQD5g9woXdYwaEjQU3RIJCbVhPTH9nrcJsV8BZLh_CYnfMtVqRa48snqJ1wotdk6M5qA0Fq6YEND05Vyth1irb6m2uLaeq0S9zzpx3HFjj_wRso7LvMgw3sI4VotjJVeY0tHmXXSMbPe74RkcKPzd0_ISwz_X2JLq1J8ZDzwt5s237KAjWTF02Kc3Yv47aysYMXIPoc4F1EF_VLc-ydS_pg2-pJuN3vxAvEjLjAivZPJok3u7IYsNm0ra8r0iZmTyOC2opgyN7Oq1_AEiPdNy1gnh50u24vJmSVe4zt2-27Ep48oitjlElX6vHtlrJCt7vnl0iML5d7NNilhPZUY2DVaFLwJP3Mpi1LcWadNoXluge0VmausBnRcXpYXhQ9R3KtH0h_d1t-Eq8y8inFLKWUzGIIeEWmuk9_CqsrqDOfINPbfIKO72U1TOuxBFRBmC7JwIx8yIjKAtYwMR_G4eWTjvNnVEo_oEAEShJKGcdvMZQNbtbGNHc2Uw7AV25BabEncrFf2tYgR6DmRB0xcZPzldA7-Fprsq_GcgLiEJkzHFoE6U_vO05Vq45-8pfjHJsKVU20W3hXH57bj7tN22PwYk7wZ4EZRfVXPIix73_2KZ9SLRUw3B8d4zwjkxpg3HgX6Sl2w=='}, 'provides': None}  
                 |__Atom 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-generate-serverpem' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'amphora_id': '83c91d18-4a47-4316-ac14-4d352d92b155'}, 'provides': b'gAAAAABdYWRcWssCzvjluRkDw37iWz_Bt88UdyE5AFTwPPN9lrTFQfzpaqlkk8iJD6stpZuYAuw6K7ddb95TUPi18lyBiz_uqfwEXSXwl-tWiaezf_MZE4GbIYER7RNDm2KYMDJb73M-4hBBoGyKQroeGSrtIYAmJpkWhPF_IZUFCyq8TB_X6LfL7k_mldJiylqY8nlVTSS4lICkzlts4WsFOOU7oRkGix21jES9hYP-Uno82iafeLcPQd8T9bC-p4J8xtg8a3CUvTb3rb85iUo8iuIfeA8jkr-oe4hLbYF4vbO2LT53oQvtjl8WjAqjidUEPummy-gsB7iRlhotMoa0XgpQsP3fSiItsqnOs7Q6XWgezGRACrBkQqX6M3NXKhzIXr-fkPAmf53LNyCvhBTzn_zd-D3hM3kjBfyw8KWCvlLmw1ea42FsBhxZFEmTfOw3er-QqAacLYmfABvIT1Ylwfv8X3zCndE8CqrED1hXCwD-14tB3RuZ8T45C274ldINC7I64Tmd6M5z-9oZ8hxRHY12njQh8GgHO1489ijBw4mLy_PF0IxLwpK0VJrWeaDXzPw6EvgiXCbdZppCfbkq4hTZ-YPuiDcn2TYcylwmF9MJWQhZfBE4ygDqHhacXZu5tAe3vmaQgfd3_Bmn8fPzaU-_8moeelRHE3mOpp_h-A7DRWIE344zdd2ZjIq8cUYYxnVuwzwIhsYBfRbJGy7_2X3Gf32HNOGGLX_iHlYZubWUu9p_qx-V1WNgOt9sX6C5n6t-bDtgEOkt6JV7KZQEsnbYxx76ZTw352AN9JiK1ra9Cxu37usdwvKvYLgf_kA1AWdSHHTBLloQhAYiBzUowQt5q7D2kzkL1W_N2Oo3bz-bIJFCiUC3ST4OE5ytaN399HOqcO_Pu0E-Fv-PmhCSiZ8mUmSEnLqJVSIpXD0W9BwkTwbhr5Lsg2ay6rvIozzDoLsfkfquhDnonFBvVz3ZkGCPharp7I5VMpfKQnE4rqlQjUfgicgB7t9iAJ9flBKTQfDCcYGHtZcroVgl21GUF9W9nOGp7mu_tbx93YUJkNN_oVSQCjbJc388serm5OjhrZ3jG--FzigLKnv9W6oyt8ATW_UUfBkSVkCuj3lvJJMmfV5MA3yVoCU9g9i5dvbVVAGfraCazZre1WrTQ7DFHus7xPHOzsLE45GHvUwlnlx6l7im0LVIQ2OwUWIDWA4dgfgK6OqDFOfTyhMfSTQ5iJOX1wBa4W8LXYCq17H_vkutKm8hrDJ-D5e3qrePYD6EQpSLSxyGFxRbRcFKWzTQM-0MO2GTpH8HVht07XCDa_387PHfwsp2NOS9hfGU6alswJpQN73x34I4WCtRSpG1_1e7owdw3ReUTJeYviDNKJuQx32aHp5eJt_neEAtpLdvWBROPFp7NDt8UFMPeb2JAJwolvhQoQoI3BhP0MLQ8k9cc1GB2amncCwC4zqVrrAz7XmAT4tQ_cD573Vn2udLXbXHlOXCz3b_0BSO9LwdTa0R8wMi_RAgk79TYquakc2DFk3YeoGAbJaiha3p_NjvH9HVp9xEAxKdSuUZp_FYvYLEggEsT35R7jVNP6omdtpntVztTB-BEQKioOeQXA9wOq85Hz3KtvYVjFha3z8dDaunDIe6IDG7WGF38JeFeRLi0WHxXv_vT7V4hJs5cUpx087uMy-ovIBf67keEG2iwc56uIJg6m-gGCWCBuoDcZDWVqsn1A3DI1XomQrgJXwctUwtJbd6xH0ohwib0F-e7ei32YonYN-Mp3sbQjjdiz4r2_sRA4p9Wwp_d7NpubZm9im7cRiRU5wfd-V8zmeyNQNkTXJMTAruAqpeoXG3fLUqiU_ICrhojyPqs5My7Z5PZApplX55h2mdKLUC_HtCJV1oACVwaGfiCaJbAu0Q0NAGxONfft5p7Ow4dd1xY5kqgY7ZNuMnxNnR6lBvoNZy_PEb_09SZePSo8Ers8pfZgPM1veF0KR1PBjzVlf9mHAXwG2lQ6_VKJzasyPHekMWpJW69Uep96a_hc76IsPo6F3tcirRSFRSXE4gWvItLQDxbCEr21ADrVat483H8aABM82dVKNzpOSy4oXR6-Vi4Oufd9mVRs3WmA3pvWWQRkgRsgAjzVvEvh8zlUIkS5Fvnxo73SM6_eSn__C1M_iIUYLdVzIgyQ4drJsdAg_-4-bx0seP8nlY20GDqA2SfhM56lPB5XhrhugfiaxaEXu1fD5kdb47TZRk2t9hfhfFFheS-6W3-xzBbbS_6N4dxN7Itb4hgt7cGb0Ey0BfjjGfdpqPL0bTwme5KY4Ryocl9x6opzHxOxSeVEjA85BJudhfJgQDRFqjNO7d67wEEO7j03hQX67hqnwmqG1FdFjENIygPkv_iUm6D5FLCh-fdLeM3ejRcp0_r1FazysBiMbQ9Mxf213k6LMUd2O1mUQ2y4K0ZWYWtE07TtB46opUvzwrOFE74xudsFprefQdvP7OLu1PlI_ODi0G3hLhRtGqTTo8aIFl7H-_1pVTy-DnKLgIt1yz__7A5gtxHeKghtymQrRbAhLKZNKbZoyjliwZSmCWuPA959RSI3gVx1No10tydN2ZDUqcfKqGmfT-tUQkjr2x6kzPh_C87NcSlsmjweHaDmzwqGhIzarIljEAB5P6vGEzoKsVn2soY2VOUQdWPotdqjqf8P1YIuB3b1lMHUYvljIYR4ceuhvol8sR2xWMkp9Md-XUPxTT1AtqsU3sKwAInQviYcpywDB6aSrH8ZIZRYC3f1oHoO6k9wQ73zVDiQPXLqpDNvylEB5x9Hgrb8SQPGTcaywtT_PBkUQZXG_F7RDqABbRpY7FaYpk_xGkyv_j_caJdgP7wR1yWabas8RtCm0d9leN6nVaP4lstxsdBAMkPucY5M-WtOdobvnbuf9Y-Lnz8wLInNVkyFgOD_uFeJPRTe_7N6isP0m1175GHHVZn_8sWH9LA0buyx3iLcmNdVTMnkGIzXtr4h_d89-oflxc-1O97KiCaRE3fMFNIlUTKpMo_qc1FggTYtYAnL-WkG1nNdk_KXaAjG7dvLund0O8LSpB0AlLAyRcHcx-3i52jXh1VlRvkTo1tC3CjLf0ocZs7TNYXf8Liq9VfRJlFnrv_R-tl00arzWxioyIk5O1A_qAe_Yv6HaF7O_91zsdgViPBCWHNlFY4E54ZduhwDnPpU_UKQjzpvCMCJuxJZW9waGSuhsdDt4MjZHVk50LWuo3PB4EA0GgUsmu7mW21cNAFJutj1EL6fN8QspHELuHGNCGjWzCziGJb7Qn8lSHBT2D2_u870FSdBU6Pl3E_o8EZ5BFT_5VuirkNF0lm0ZQD5g9woXdYwaEjQU3RIJCbVhPTH9nrcJsV8BZLh_CYnfMtVqRa48snqJ1wotdk6M5qA0Fq6YEND05Vyth1irb6m2uLaeq0S9zzpx3HFjj_wRso7LvMgw3sI4VotjJVeY0tHmXXSMbPe74RkcKPzd0_ISwz_X2JLq1J8ZDzwt5s237KAjWTF02Kc3Yv47aysYMXIPoc4F1EF_VLc-ydS_pg2-pJuN3vxAvEjLjAivZPJok3u7IYsNm0ra8r0iZmTyOC2opgyN7Oq1_AEiPdNy1gnh50u24vJmSVe4zt2-27Ep48oitjlElX6vHtlrJCt7vnl0iML5d7NNilhPZUY2DVaFLwJP3Mpi1LcWadNoXluge0VmausBnRcXpYXhQ9R3KtH0h_d1t-Eq8y8inFLKWUzGIIeEWmuk9_CqsrqDOfINPbfIKO72U1TOuxBFRBmC7JwIx8yIjKAtYwMR_G4eWTjvNnVEo_oEAEShJKGcdvMZQNbtbGNHc2Uw7AV25BabEncrFf2tYgR6DmRB0xcZPzldA7-Fprsq_GcgLiEJkzHFoE6U_vO05Vq45-8pfjHJsKVU20W3hXH57bj7tN22PwYk7wZ4EZRfVXPIix73_2KZ9SLRUw3B8d4zwjkxpg3HgX6Sl2w=='}  
                    |__Atom 'STANDALONE-octavia-create-amp-for-lb-subflow-octavia-create-amphora-indb' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {}, 'provides': '83c91d18-4a47-4316-ac14-4d352d92b155'}  
                       |__Flow 'STANDALONE-octavia-create-amp-for-lb-subflow'  
                          |__Atom 'STANDALONE-octavia-get-amphora-for-lb-subflow-octavia-mapload-balancer-to-amphora' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'loadbalancer_id': '9e09a705-c050-4d30-a32b-e4d8c152c06f', 'flavor': {}}, 'provides': None}  
                             |__Flow 'STANDALONE-octavia-get-amphora-for-lb-subflow'  
                                |__Flow 'STANDALONE-octavia-plug-net-subflow'  
                                   |__Atom 'octavia.controller.worker.tasks.network_tasks.GetSubnetFromVIP' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'loadbalancer': <octavia.common.data_models.LoadBalancer object at 0x7fbc25566e48>}, 'provides': <octavia.network.data_models.Subnet object at 0x7fbc26054f60>}  
                                      |__Atom 'octavia.controller.worker.tasks.network_tasks.UpdateVIPSecurityGroup' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'loadbalancer': <octavia.common.data_models.LoadBalancer object at 0x7fbc25566e48>}, 'provides': None}  
                                         |__Atom 'octavia.controller.worker.tasks.database_tasks.UpdateVIPAfterAllocation' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'loadbalancer_id': '9e09a705-c050-4d30-a32b-e4d8c152c06f', 'vip': <octavia.common.data_models.Vip object at 0x7fbc25654b38>}, 'provides': <octavia.common.data_models.LoadBalancer object at 0x7fbc25566e48>}  
                                            |__Atom 'octavia.controller.worker.tasks.network_tasks.AllocateVIP' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'loadbalancer': <octavia.common.data_models.LoadBalancer object at 0x7fbc255c59b0>}, 'provides': <octavia.common.data_models.Vip object at 0x7fbc25654b38>}  
                                               |__Atom 'reload-lb-before-allocate-vip' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'loadbalancer_id': '9e09a705-c050-4d30-a32b-e4d8c152c06f'}, 'provides': <octavia.common.data_models.LoadBalancer object at 0x7fbc255c59b0>}  
                                                  |__Atom 'octavia.controller.worker.tasks.lifecycle_tasks.LoadBalancerIDToErrorOnRevertTask' {'intention': 'EXECUTE', 'state': 'SUCCESS', 'requires': {'loadbalancer_id': '9e09a705-c050-4d30-a32b-e4d8c152c06f'}, 'provides': None}  
                                                     |__Flow 'octavia-create-loadbalancer-flow': octavia.amphorae.drivers.haproxy.exceptions.NotFound: Not Found  
  
  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> Sensitive information such as private keys  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（DynamicLoggingListener）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/openstack/octavia/blob/2bd9b68dd1a77723f/octavia/controller/worker/flows/amphora_flows.py#L50） -> Variable Names（SERVER_PEM）  
Programming Language:Python  
```Python  
  
# https://github.com/openstack/octavia/blob/2bd9b68dd1a77723f0d62ac170172333a356aace/octavia/controller/worker/controller_worker.py#L81-L99  
  
    def create_amphora(self):  
        """Creates an Amphora.  
        This is used to create spare amphora.  
        :returns: amphora_id  
        """  
        create_amp_tf = self._taskflow_load(  
            self._amphora_flows.get_create_amphora_flow(),  
            store={constants.BUILD_TYPE_PRIORITY:  
                   constants.LB_CREATE_SPARES_POOL_PRIORITY}  
        )  
        with tf_logging.DynamicLoggingListener(  
                create_amp_tf, log=LOG,  
                hide_inputs_outputs_of=self._exclude_result_logging_tasks): # HERE IS THE SINK 1  
  
            create_amp_tf.run()  
  
        return create_amp_tf.storage.fetch('amphora')  
  
# https://github.com/openstack/taskflow/blob/1877565d4dc1582771d677954f40fe8e60bdc590/taskflow/listeners/base.py#L81-L161  
class Listener(object):  
    """Base class for listeners.  
    A listener can be attached to an engine to do various actions on flow and  
    atom state transitions. It implements the context manager protocol to be  
    able to register and unregister with a given engine automatically when a  
    context is entered and when it is exited.  
    To implement a listener, derive from this class and override  
    ``_flow_receiver`` and/or ``_task_receiver`` and/or ``_retry_receiver``  
    methods (in this class, they do nothing).  
    """  
# OMIT FOR SIMPLICITY  
    def register(self):  
        if 'task' not in self._registered:  
            self._registered['task'] = _bulk_register(  
                self._listen_for['task'], self._engine.atom_notifier,  
                self._task_receiver, details_filter=_task_matcher)  
        if 'retry' not in self._registered:  
            self._registered['retry'] = _bulk_register(  
                self._listen_for['retry'], self._engine.atom_notifier,  
                self._retry_receiver, details_filter=_retry_matcher)  
        if 'flow' not in self._registered:  
            self._registered['flow'] = _bulk_register(  
                self._listen_for['flow'], self._engine.notifier,  
                self._flow_receiver)  
  
    def __enter__(self):  
        self.register()  
        return self  
  
    def __exit__(self, type, value, tb):  
        try:  
            self.deregister()  
        except Exception:  
            # Don't let deregistering throw exceptions  
            LOG.warning("Failed deregistering listeners from engine %s",  
                        self._engine, exc_info=True)  
  
# https://github.com/openstack/taskflow/blob/1877565d4dc1582771d677954f40fe8e60bdc590/taskflow/listeners/base.py#L63-L78  
def _bulk_register(watch_states, notifier, cb, details_filter=None):  
    """Bulk registers a callback associated with many states."""  
    registered = []  
    try:  
        for state in watch_states:  
            if not notifier.is_registered(state, cb,  
                                          details_filter=details_filter):  
                notifier.register(state, cb,  
                                  details_filter=details_filter)  
                registered.append((state, cb))  
    except ValueError:  
        with excutils.save_and_reraise_exception():  
            _bulk_deregister(notifier, registered,  
                             details_filter=details_filter)  
    else:  
        return registered  
  
  
# https://github.com/openstack/taskflow/blob/1877565d4dc1582771d677954f40fe8e60bdc590/taskflow/types/notifier.py#L130-L217  
class Notifier(object):  
    """A notification (`pub/sub`_ *like*) helper class.  
    It is intended to be used to subscribe to notifications of events  
    occurring as well as allow a entity to post said notifications to any  
    associated subscribers without having either entity care about how this  
    notification occurs.  
    **Not** thread-safe when a single notifier is mutated at the same  
    time by multiple threads. For example having multiple threads call  
    into :py:meth:`.register` or :py:meth:`.reset` at the same time could  
    potentially end badly. It is thread-safe when  
    only :py:meth:`.notify` calls or other read-only actions (like calling  
    into :py:meth:`.is_registered`) are occurring at the same time.  
    .. _pub/sub: http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern  
    """  
  
# OMIT FOR SIMPLICITY  
  
    def notify(self, event_type, details):  
        """Notify about event occurrence.  
        All callbacks registered to receive notifications about given  
        event type will be called. If the provided event type can not be  
        used to emit notifications (this is checked via  
        the :meth:`.can_be_registered` method) then it will silently be  
        dropped (notification failures are not allowed to cause or  
        raise exceptions).  
        :param event_type: event type that occurred  
        :param details: additional event details *dictionary* passed to  
                        callback keyword argument with the same name  
        :type details: dictionary  
        """  
        if not self.can_trigger_notification(event_type):  
            LOG.debug("Event type '%s' is not allowed to trigger"  
                      " notifications", event_type)  
            return  
        listeners = list(self._topics.get(self.ANY, []))  
        listeners.extend(self._topics.get(event_type, []))  
        if not listeners:  
            return  
        if not details:  
            details = {}  
        for listener in listeners:  
            try:  
                listener(event_type, details.copy()) # HERE IS THE FLOW  
            except Exception:  
                LOG.warning("Failure calling listener %s to notify about event"  
                            " %s, details: %s", listener, event_type,  
                            details, exc_info=True)  
  
  
# OMIT FOR SIMPLICITY  
  
  
# https://github.com/openstack/taskflow/blob/1877565d4dc1582771d677954f40fe8e60bdc590/taskflow/listeners/logging.py#L107-L136  
  
    def __init__(self, engine,  
                 task_listen_for=base.DEFAULT_LISTEN_FOR,  
                 flow_listen_for=base.DEFAULT_LISTEN_FOR,  
                 retry_listen_for=base.DEFAULT_LISTEN_FOR,  
                 log=None, failure_level=logging.WARNING,  
                 level=logging.DEBUG, hide_inputs_outputs_of=(),  
                 fail_formatter=None):  
        super(DynamicLoggingListener, self).__init__(  
            engine, task_listen_for=task_listen_for,  
            flow_listen_for=flow_listen_for, retry_listen_for=retry_listen_for)  
        self._failure_level = failure_level  
        self._level = level  
        self._task_log_levels = {  
            states.FAILURE: self._failure_level,  
            states.REVERTED: self._failure_level,  
            states.RETRYING: self._failure_level,  
            states.REVERT_FAILURE: self._failure_level,  
        }  
        self._flow_log_levels = {  
            states.FAILURE: self._failure_level,  
            states.REVERTED: self._failure_level,  
        }  
        self._hide_inputs_outputs_of = frozenset(hide_inputs_outputs_of)  
        self._logger = misc.pick_first_not_none(log, self._LOGGER, LOG)  
        if fail_formatter is None:  
            self._fail_formatter = formatters.FailureFormatter(  
                self._engine,  
                hide_inputs_outputs_of=self._hide_inputs_outputs_of)  
        else:  
            self._fail_formatter = fail_formatter  
  
  
# https://github.com/openstack/taskflow/blob/1877565d4dc1582771d677954f40fe8e60bdc590/taskflow/listeners/logging.py#L145-L192  
  
    def _task_receiver(self, state, details):  
        """Gets called on task state changes."""  
        task_name = details['task_name']  
        task_uuid = details['task_uuid']  
        if 'result' in details and state in base.FINISH_STATES:  
            # If the task failed, it's useful to show the exception traceback  
            # and any other available exception information.  
            result = details.get('result')  
            if isinstance(result, failure.Failure):  
                exc_info, fail_details = self._fail_formatter.format(  
                    result, _make_matcher(task_name))  
                if fail_details:  
                    self._logger.log(self._failure_level,  
                                     "Task '%s' (%s) transitioned into state"  
                                     " '%s' from state '%s'%s%s",  
                                     task_name, task_uuid, state,  
                                     details['old_state'], os.linesep,  
                                     fail_details, exc_info=exc_info)  # HERE IS THE INNER SINK  
                else:  
                    self._logger.log(self._failure_level,  
                                     "Task '%s' (%s) transitioned into state"  
                                     " '%s' from state '%s'", task_name,  
                                     task_uuid, state, details['old_state'],  
                                     exc_info=exc_info) # HERE IS THE INNER SINK  
            else:  
                # Otherwise, depending on the enabled logging level/state we  
                # will show or hide results that the task may have produced  
                # during execution.  
                level = self._task_log_levels.get(state, self._level)  
                show_result = (self._logger.isEnabledFor(self._level)  
                               or state == states.FAILURE)  
                if show_result and \  
                   task_name not in self._hide_inputs_outputs_of:  
                    self._logger.log(level, "Task '%s' (%s) transitioned into"  
                                     " state '%s' from state '%s' with"  
                                     " result '%s'", task_name, task_uuid,  
                                     state, details['old_state'], result)  
                else:  
                    self._logger.log(level, "Task '%s' (%s) transitioned into"  
                                     " state '%s' from state '%s'",  
                                     task_name, task_uuid, state,  
                                     details['old_state'])  
        else:  
            # Just a intermediary state, carry on!  
            level = self._task_log_levels.get(state, self._level)  
            self._logger.log(level, "Task '%s' (%s) transitioned into state"  
                             " '%s' from state '%s'", task_name, task_uuid,  
                             state, details['old_state'])  
  
# https://github.com/openstack/taskflow/blob/1877565d4dc1582771d677954f40fe8e60bdc590/taskflow/formatters.py#L61-L169  
  
class FailureFormatter(object):  
    """Formats a failure and connects it to associated atoms & engine."""  
  
    _BUILDERS = {  
        states.EXECUTE: (_fetch_predecessor_tree, 'predecessors'),  
    }  
  
    def __init__(self, engine, hide_inputs_outputs_of=()):  
        self._hide_inputs_outputs_of = hide_inputs_outputs_of  
        self._engine = engine  
  
    def _format_node(self, storage, cache, node):  
        """Formats a single tree node into a string version."""  
        if node.metadata['kind'] == compiler.FLOW:  
            flow = node.item  
            flow_name = flow.name  
            return "Flow '%s'" % (flow_name)  
        elif node.metadata['kind'] in compiler.ATOMS:  
            atom = node.item  
            atom_name = atom.name  
            atom_attrs = {}  
            intention, intention_found = _cached_get(  
                cache, 'intentions', atom_name, storage.get_atom_intention,  
                atom_name)  
            if intention_found:  
                atom_attrs['intention'] = intention  
            state, state_found = _cached_get(cache, 'states', atom_name,  
                                             storage.get_atom_state,  
                                             atom_name)  
            if state_found:  
                atom_attrs['state'] = state  
            if atom_name not in self._hide_inputs_outputs_of:  
                # When the cache does not exist for this atom this  
                # will be called with the rest of these arguments  
                # used to populate the cache.  
                fetch_mapped_args = functools.partial(  
                    storage.fetch_mapped_args, atom.rebind,  
                    atom_name=atom_name, optional_args=atom.optional)  
                requires, requires_found = _cached_get(cache, 'requires',  
                                                       atom_name,  
                                                       fetch_mapped_args)  
                if requires_found:  
                    atom_attrs['requires'] = requires  
                provides, provides_found = _cached_get(  
                    cache, 'provides', atom_name,  
                    storage.get_execute_result, atom_name)  
                if provides_found:  
                    atom_attrs['provides'] = provides  
            if atom_attrs:  
                return "Atom '%s' %s" % (atom_name, atom_attrs)  
            else:  
                return "Atom '%s'" % (atom_name)  
        else:  
            raise TypeError("Unable to format node, unknown node"  
                            " kind '%s' encountered" % node.metadata['kind'])  
  
    def format(self, fail, atom_matcher):  
        """Returns a (exc_info, details) tuple about the failure.  
        The ``exc_info`` tuple should be a standard three element  
        (exctype, value, traceback) tuple that will be used for further  
        logging. A non-empty string is typically returned for ``details``; it  
        should contain any string info about the failure (with any specific  
        details the ``exc_info`` may not have/contain).  
        """  
        buff = misc.StringIO()  
        storage = self._engine.storage  
        compilation = self._engine.compilation  
        if fail.exc_info is None:  
            # Remote failures will not have a 'exc_info' tuple, so just use  
            # the captured traceback that was captured by the creator when it  
            # failed...  
            buff.write_nl(fail.pformat(traceback=True))  
        if storage is None or compilation is None:  
            # Somehow we got called before prepared and/or compiled; ok  
            # that's weird, skip doing the rest...  
            return (fail.exc_info, buff.getvalue())  
        hierarchy = compilation.hierarchy  
        graph = compilation.execution_graph  
        atom_node = hierarchy.find_first_match(atom_matcher)  
        atom = None  
        atom_intention = None  
        if atom_node is not None:  
            atom = atom_node.item  
            atom_intention = storage.get_atom_intention(atom.name)  
        if atom is not None and atom_intention in self._BUILDERS:  
            # Cache as much as we can, since the path of various atoms  
            # may cause the same atom to be seen repeatedly depending on  
            # the graph structure...  
            cache = {  
                'intentions': {},  
                'provides': {},  
                'requires': {},  
                'states': {},  
            }  
            builder, kind = self._BUILDERS[atom_intention]  
            rooted_tree = builder(graph, atom)  
            child_count = rooted_tree.child_count(only_direct=False)  
            buff.write_nl('%s %s (most recent first):' % (child_count, kind))  
            formatter = functools.partial(self._format_node, storage, cache)  
            direct_child_count = rooted_tree.child_count(only_direct=True)  
            for i, child in enumerate(rooted_tree, 1):  
                if i == direct_child_count:  
                    buff.write(child.pformat(stringify_node=formatter,  
                                             starting_prefix="  "))  
                else:  
                    buff.write_nl(child.pformat(stringify_node=formatter,  
                                                starting_prefix="  "))  
        return (fail.exc_info, buff.getvalue())  
  
  
  
```  
