## Summary:  
Software: cloudstack  
## Fix:  
Commit: https://github.com/apache/cloudstack/commit/bec00cce4692c02ed5395b4c4acc40624a41198c  
Fix Time (of the Last Commit): 2012-12-18  
Author: Chip Childers  
Fix Pattern: Sanitization -> Redaction -> Introduction -> Keyword/RegexBasedFiltration -> RedactionFunctionDefined  
  
  
  
Fixing-commits Count: 5  
Total Change Size: +146 -30  
  
========  
Commit: https://github.com/apache/cloudstack/commit/e4a51731990c7599f92e00cd286d6ae760a98ed4  
Change Size: +5 -1  
Time: 2012-11-30  
Author: Chip Childers  
Commit: https://github.com/apache/cloudstack/commit/82a17a413b109002a9b42f04ba49515ea4fe4e0b  
Change Size: +1 -1  
Time: 2012-12-14  
Author: Chip Childers  
Commit: https://github.com/apache/cloudstack/commit/44da7b1841446218fb363a809bd7fd7c02eec58f  
Change Size: +72 -16  
Time: 2012-12-18  
Author: Chip Childers  
Commit: https://github.com/apache/cloudstack/commit/ba30500402ec2fbfb262cf8afd6052df67fbc439  
Change Size: +3 -2  
Time: 2012-12-18  
Author: Chip Childers  
Commit: https://github.com/apache/cloudstack/commit/bec00cce4692c02ed5395b4c4acc40624a41198c  
Change Size: +65 -10  
Time: 2012-12-18  
Author: Chip Childers  
## Sample logs: Yes  
```  
2012-11-16 04:16:44,387 INFO [cloud.api.ApiServer] (ApiServer-8:null) (userId=1 accountId=1 sessionId=null) /0:0:0:0:0:0:0:1 – GET /client/api?command=createSSHKeyPair&name=testkeys2&response=json&domainid=1&zone=2&account=admin HTTP/1.0 200  
  
{  
"createsshkeypairresponse": {  
"keypair":  
  
{ "name": "testkeys2", "fingerprint": "f2:0c:b1:d9:be:73:4f:a9:0a:c0:c8:59:17:e0:67:07", "privatekey": "-----BEGIN RSA PRIVATE KEY-----\nMIICXgIBAAKBgQDD8CUiTQL26bhcDDW1kg8QqY2Pzm9EkeNwcTtglZEYkfSV7IHI\nDO7kRvB8ca4uKOpQD+jIpz0+leTQAc2JwLPzIFfTpN/mn+vwMwBviTZjYUDePkw+\nuwe97KB4Xg+RM7m0f4sPUHe9IZPshebl8nFhFpp8bL1g/FcDalJs3GhyPwIDAQAB\nAoGBAL0czVp75f6Wul/tUPF8lZnJbF5+KpqODGz8fQjNkwuZ4+3IJcMF6JTfe0FB\nH5Jh3zWDBXSVJeGAHyY8dzsbiRHRoXb4HRXUfSdMVLAlXDmH+REcE/4OY+Sd+GU2\ncrIsq9E3R2Nhr7lujP6BOO4IEzSrKFQ531lLBolCNZ/YpHThAkEA4/N1BeuB7ihI\nlzfdikjEmg3BfDn+s7FlQz42x4iAOBRBcMeO0e7ma+UWD7LUER3tuADAY3D4C/xs\nAluSbEyHdwJBANwMRK4jsmsGFf5GjH/iyVApZx/U71OR8OJx48NSdWmCzEkMdCE+\nH5Lska7j8mfAfqbOYfYqR4gwOXXHGr8XrXkCQAF9GYqMWzDe+npiVwQMLZyD8nuJ\nNWye//ZMdbcf4RZ8q2C9LOWaFc8mk9pOZKwn8eF9v8PmfPg3Ec2CI5apeUkCQQDK\nEj4TyFY07/7MZc7qNcH26j54PduVW+TgngOxv4xw2xtsTZJrYJgwHSzfdRaK7nug\nBNBy9XqA9wAdRz0plL3JAkEAiyCuxFhz6F2NhMxDX9IczJPPiJ+v6qHGwSThiBv0\n9XgwpQqrFmBdqAZ3SDjsgXkG2gAqZRuddbq55ffGSFtkpg==\n-----END RSA PRIVATE KEY-----\n" }  
}  
}  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> SSH private key; the password of an added host; the password of an added VM; reset password for VM  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（Apache Log4J）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/apache/cloudstack/blob/e4a51731990c7599f92e00cd286d6ae760a98ed4/api/src/com/cloud/api/commands/ResetVMPasswordCmd.java#L55） -> Variable Names(password)  
#### Sink 2:  
Logging call Function:  Third-party Libaries（Apache Log4J）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/apache/cloudstack/blob/e4a51731990c7599f92e00cd286d6ae760a98ed4/api/src/com/cloud/api/commands/ResetVMPasswordCmd.java#L55） -> Variable Names(password)  
#### Sink 3:  
Logging call Function:  Third-party Libaries（Apache Log4J）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/apache/cloudstack/blob/e4a51731990c7599f92e00cd286d6ae760a98ed4/api/src/com/cloud/api/commands/ResetVMPasswordCmd.java#L55） -> Variable Names(password)  
Programming Language:Java  
```Java  
  
// https://github.com/apache/cloudstack/blob/e4a51731990c7599f92e00cd286d6ae760a98ed4/server/src/com/cloud/api/ApiServer.java#L306-L474  
  
    @SuppressWarnings({ "unchecked", "rawtypes" })  
    @Override  
    public void handle(HttpRequest request, HttpResponse response, HttpContext context) throws HttpException, IOException {  
        // get some information for the access log...  
        StringBuffer sb = new StringBuffer();  
        HttpServerConnection connObj = (HttpServerConnection) context.getAttribute("http.connection");  
        if (connObj instanceof SocketHttpServerConnection) {  
            InetAddress remoteAddr = ((SocketHttpServerConnection) connObj).getRemoteAddress();  
            sb.append(remoteAddr.toString() + " -- ");  
        }  
        sb.append(request.getRequestLine()); // HERE IS THE FLOW  
  
        try {  
            String uri = request.getRequestLine().getUri();  
            int requestParamsStartIndex = uri.indexOf('?');  
            if (requestParamsStartIndex >= 0) {  
                uri = uri.substring(requestParamsStartIndex + 1);  
            }  
  
            String[] paramArray = uri.split("&");  
            if (paramArray.length < 1) {  
                s_logger.info("no parameters received for request: " + uri + ", aborting...");  
                return;  
            }  
  
            Map parameterMap = new HashMap<String, String[]>();  
  
            String responseType = BaseCmd.RESPONSE_TYPE_XML;  
            for (String paramEntry : paramArray) {  
                String[] paramValue = paramEntry.split("=");  
                if (paramValue.length != 2) {  
                    s_logger.info("malformed parameter: " + paramEntry + ", skipping");  
                    continue;  
                }  
                if ("response".equalsIgnoreCase(paramValue[0])) {  
                    responseType = paramValue[1];  
                } else {  
                    // according to the servlet spec, the parameter map should be in the form (name=String,  
                    // value=String[]), so  
                    // parameter values will be stored in an array  
                    parameterMap.put(/* name */paramValue[0], /* value */new String[] { paramValue[1] });  
                }  
            }  
            try {  
                // always trust commands from API port, user context will always be UID_SYSTEM/ACCOUNT_ID_SYSTEM  
                UserContext.registerContext(_systemUser.getId(), _systemAccount, null, true);  
                sb.insert(0, "(userId=" + User.UID_SYSTEM + " accountId=" + Account.ACCOUNT_ID_SYSTEM + " sessionId=" + null + ") ");  
                String responseText = handleRequest(parameterMap, true, responseType, sb); // HERE IS THE FLOW  
                sb.append(" 200 " + ((responseText == null) ? 0 : responseText.length()));  
  
                writeResponse(response, responseText, HttpStatus.SC_OK, responseType, null);  
            } catch (ServerApiException se) {  
                String responseText = getSerializedApiError(se.getErrorCode(), se.getDescription(), parameterMap, responseType, se);                  
                writeResponse(response, responseText, se.getErrorCode(), responseType, se.getDescription());  
                sb.append(" " + se.getErrorCode() + " " + se.getDescription());  
            } catch (RuntimeException e) {  
                // log runtime exception like NullPointerException to help identify the source easier  
                s_logger.error("Unhandled exception, ", e);  
                throw e;  
            }  
        } finally {  
            s_accessLogger.info(sb.toString()); // HERE IS THE SINK 1  
            UserContext.unregisterContext();  
        }  
    }  
  
    @SuppressWarnings("rawtypes")  
    public String handleRequest(Map params, boolean decode, String responseType, StringBuffer auditTrailSb) throws ServerApiException {  
        String response = null;  
        String[] command = null;  
        try {  
            command = (String[]) params.get("command");  
            if (command == null) {  
                s_logger.error("invalid request, no command sent");  
                if (s_logger.isTraceEnabled()) {  
                    s_logger.trace("dumping request parameters");  
                    for (Object key : params.keySet()) {  
                        String keyStr = (String) key;  
                        String[] value = (String[]) params.get(key);  
                        s_logger.trace("   key: " + keyStr + ", value: " + ((value == null) ? "'null'" : value[0]));  
                    }  
                }  
                throw new ServerApiException(BaseCmd.UNSUPPORTED_ACTION_ERROR, "Invalid request, no command sent");  
            } else {  
                Map<String, String> paramMap = new HashMap<String, String>();  
                Set keys = params.keySet();  
                Iterator keysIter = keys.iterator();  
                while (keysIter.hasNext()) {  
                    String key = (String) keysIter.next();  
                    if ("command".equalsIgnoreCase(key)) {  
                        continue;  
                    }  
                    String[] value = (String[]) params.get(key);  
  
                    String decodedValue = null;  
                    if (decode) {  
                        try {  
                            decodedValue = URLDecoder.decode(value[0], "UTF-8");  
                        } catch (UnsupportedEncodingException usex) {  
                            s_logger.warn(key + " could not be decoded, value = " + value[0]);  
                            throw new ServerApiException(BaseCmd.PARAM_ERROR, key + " could not be decoded, received value " + value[0]);  
                        } catch (IllegalArgumentException iae) {  
                            s_logger.warn(key + " could not be decoded, value = " + value[0]);  
                            throw new ServerApiException(BaseCmd.PARAM_ERROR, key + " could not be decoded, received value " + value[0] + " which contains illegal characters eg.%");  
                        }  
                    } else {  
                        decodedValue = value[0];  
                    }  
                    paramMap.put(key, decodedValue);  
                }  
                String cmdClassName = _apiCommands.getProperty(command[0]);  
                if (cmdClassName != null) {  
                    Class<?> cmdClass = Class.forName(cmdClassName);  
                    BaseCmd cmdObj = (BaseCmd) cmdClass.newInstance();  
                    cmdObj.setFullUrlParams(paramMap);  
                    cmdObj.setResponseType(responseType);  
                    // This is where the command is either serialized, or directly dispatched  
                    response = queueCommand(cmdObj, paramMap);  
                    buildAuditTrail(auditTrailSb, command[0], response); // HERE IS THE FLOW  
                } else {  
                    if (!command[0].equalsIgnoreCase("login") && !command[0].equalsIgnoreCase("logout")) {  
                        String errorString = "Unknown API command: " + ((command == null) ? "null" : command[0]);  
                        s_logger.warn(errorString);  
                        auditTrailSb.append(" " + errorString);  
                        throw new ServerApiException(BaseCmd.UNSUPPORTED_ACTION_ERROR, errorString);  
                    }  
                }  
            }  
        } catch (Exception ex) {  
            if (ex instanceof InvalidParameterValueException) {  
            	InvalidParameterValueException ref = (InvalidParameterValueException)ex;  
            	ServerApiException e = new ServerApiException(BaseCmd.PARAM_ERROR, ex.getMessage());            	  
                // copy over the IdentityProxy information as well and throw the serverapiexception.  
                ArrayList<IdentityProxy> idList = ref.getIdProxyList();  
                if (idList != null) {  
                	// Iterate through entire arraylist and copy over each proxy id.  
                	for (int i = 0 ; i < idList.size(); i++) {  
                		IdentityProxy obj = idList.get(i);  
                		e.addProxyObject(obj.getTableName(), obj.getValue(), obj.getidFieldName());  
                	}  
                }  
                // Also copy over the cserror code and the function/layer in which it was thrown.  
            	e.setCSErrorCode(ref.getCSErrorCode());  
                throw e;  
            } else if (ex instanceof PermissionDeniedException) {  
            	PermissionDeniedException ref = (PermissionDeniedException)ex;  
            	ServerApiException e = new ServerApiException(BaseCmd.ACCOUNT_ERROR, ex.getMessage());  
                // copy over the IdentityProxy information as well and throw the serverapiexception.  
            	ArrayList<IdentityProxy> idList = ref.getIdProxyList();  
                if (idList != null) {  
                	// Iterate through entire arraylist and copy over each proxy id.  
                	for (int i = 0 ; i < idList.size(); i++) {  
                		IdentityProxy obj = idList.get(i);  
                		e.addProxyObject(obj.getTableName(), obj.getValue(), obj.getidFieldName());  
                	}  
                }  
                e.setCSErrorCode(ref.getCSErrorCode());  
                throw e;  
            } else if (ex instanceof ServerApiException) {  
                throw (ServerApiException) ex;  
            } else {  
                s_logger.error("unhandled exception executing api command: " + ((command == null) ? "null" : command[0]), ex);  
                ServerApiException e = new ServerApiException(BaseCmd.INTERNAL_ERROR, "Internal server error, unable to execute request.");  
                e.setCSErrorCode(CSExceptionErrorCode.getCSErrCode("ServerApiException"));  
                throw e;  
            }  
        }  
        return response;  
    }  
  
    // https://github.com/apache/cloudstack/blob/e4a51731990c7599f92e00cd286d6ae760a98ed4/server/src/com/cloud/api/ApiServer.java#L584-L606  
  
        private void buildAuditTrail(StringBuffer auditTrailSb, String command, String result) {  
        if (result == null) {  
            return;  
        }  
        auditTrailSb.append(" " + HttpServletResponse.SC_OK + " ");  
        if (command.equals("createSSHKeyPair")){  
            auditTrailSb.append("This result was not logged because it contains sensitive data.");  
        } else {  
            auditTrailSb.append(result);  
        }  
        /*  
         * if (command.equals("queryAsyncJobResult")){ //For this command we need to also log job status and job  
         * resultcode for  
         * (Pair<String,Object> pair : resultValues){ String key = pair.first(); if (key.equals("jobstatus")){  
         * auditTrailSb.append(" "); auditTrailSb.append(key); auditTrailSb.append("=");  
         * auditTrailSb.append(pair.second());  
         * }else if (key.equals("jobresultcode")){ auditTrailSb.append(" "); auditTrailSb.append(key);  
         * auditTrailSb.append("=");  
         * auditTrailSb.append(pair.second()); } } }else { for (Pair<String,Object> pair : resultValues){ if  
         * (pair.first().equals("jobid")){ // Its an async job so report the jobid auditTrailSb.append(" ");  
         * auditTrailSb.append(pair.first()); auditTrailSb.append("="); auditTrailSb.append(pair.second()); } } }  
         */  
    }  
  
  
// https://github.com/apache/cloudstack/blob/ba30500402ec2fbfb262cf8afd6052df67fbc439/server/src/com/cloud/api/ApiServlet.java#L107-L352  
  
private void processRequest(HttpServletRequest req, HttpServletResponse resp) {  
  
/* OMIT FOR SIMPLICITY*/  
  
        // logging the request start and end in management log for easy debugging  
        String reqStr = "";  
        if (s_logger.isDebugEnabled()) {  
            reqStr = auditTrailSb.toString() + " " + req.getQueryString();  
            s_logger.debug("===START=== " + StringUtils.cleanString(reqStr)); // HERE IS THE SINK 2  
        }  
  
/* OMIT FOR SIMPLICITY*/  
  
            s_accessLogger.info(auditTrailSb.toString());  
            if (s_logger.isDebugEnabled()) {  
                s_logger.debug("===END=== " + StringUtils.cleanString(reqStr)); // HERE IS THE SINK 3  
            }  
  
```  
