## Summary:  
Software: openstack/glance  
## Fix:  
Commit: https://github.com/openstack/glance/commit/e96273112b5b5da58d970796b7cfce04c5030a89  
Change Size: +10 -12  
Author: Dan Prince  
Fix Time (of the Last Commit): 2013-01-29  
Fix Pattern: Remove -> Logging Variables  
  
Fixing-commits Count: 1  
Total Change Size: +10 -12  
## Sample logs: Yes  
```  
Request returned failure status.  
404 Not Found  
Swift could not find image at uri swift+http://admin%3Aadmin:AABBCC112233@127.0.0.1:5000/v2.0/glance/b0bd4daf-0cef-448e-b5f2-3033d0f5a73a  
    (HTTP 404)  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> Swift endpoint's user name and password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（ContextAdapter.debug）  
Sensitiveness-Identifiable Source:  Same Methods & Cross Statements（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L150） -> Variable Names（creds）  
#### Sink 2:  
Logging call Function:  User-defined（ContextAdapter.debug）  
Sensitiveness-Identifiable Source:  Same Methods & Cross Statements（紧挨，https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L150） -> Variable Names（creds）|String Literals（credentials，finally outputed to logs）  
#### Sink 3:  
Logging call Function:  User-defined（ContextAdapter.debug）  
Sensitiveness-Identifiable Source:  Same Methods & Cross Statements（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L150） -> Variable Names（creds）  
#### Sink 4:  
Logging call Function:  User-defined（ContextAdapter.error）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L112） -> Variable Names（credstring）|Method Names（_get_credstring）  
#### Sink 5:  
Logging call Function:  User-defined（ContextAdapter.debug）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L112） -> Variable Names（credstring）|Method Names（_get_credstring）  
#### Sink 6:  
Logging call Function:  User-defined（ContextAdapter.info）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L112） -> Variable Names（credstring）|Method Names（_get_credstring）  
#### Sink 7:  
Logging call Function:  User-defined（ContextAdapter.debug）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L112） -> Variable Names（credstring）|Method Names（_get_credstring）  
#### Sink 8:  
Logging call Function:  User-defined（ContextAdapter.debug）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L112） -> Variable Names（credstring）|Method Names（_get_credstring）  
#### Sink 9:  
Logging call Function:  User-defined（ContextAdapter.debug）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L112） -> Variable Names（credstring）|Method Names（_get_credstring）  
Programming Language:Python  
```Python  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/bin/glance-api#L51-L65  
  
if __name__ == '__main__':  
    try:  
        config.parse_args()   
        log.setup('glance')  
  
        glance.store.create_stores()  
        glance.store.verify_default_store()  
  
        server = wsgi.Server()  
        server.start(config.load_paste_app, default_port=9292)  
        server.wait()  
    except exception.WorkerCreationFailure, e:  
        fail(2, e)  
    except RuntimeError, e:  
        fail(1, e)  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/common/config.py#L63-L73  
CONF = cfg.CONF  
CONF.register_opts(paste_deploy_opts, group='paste_deploy')  
CONF.register_opts(common_opts)  
  
  
def parse_args(args=None, usage=None, default_config_files=None):  
    return CONF(args=args,  
                project='glance',  
                version=version.deferred_version_string(prefix="%prog "),  
                usage=usage,  
                default_config_files=default_config_files)  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/openstack/common/cfg.py#L987-L1030  
    def __call__(self,  
                 args=None,  
                 project=None,  
                 prog=None,  
                 version=None,  
                 usage=None,  
                 default_config_files=None):  
        """Parse command line arguments and config files.  
        Calling a ConfigOpts object causes the supplied command line arguments  
        and config files to be parsed, causing opt values to be made available  
        as attributes of the object.  
        The object may be called multiple times, each time causing the previous  
        set of values to be overwritten.  
        Automatically registers the --config-file option with either a supplied  
        list of default config files, or a list from find_config_files().  
        If the --config-dir option is set, any *.conf files from this  
        directory are pulled in, after all the file(s) specified by the  
        --config-file option.  
        :param args: command line arguments (defaults to sys.argv[1:])  
        :param project: the toplevel project name, used to locate config files  
        :param prog: the name of the program (defaults to sys.argv[0] basename)  
        :param version: the program version (for --version)  
        :param usage: a usage string (%prog will be expanded)  
        :param default_config_files: config files to use by default  
        :returns: the list of arguments left over after parsing options  
        :raises: SystemExit, ConfigFilesNotFoundError, ConfigFileParseError,  
                 RequiredOptError, DuplicateOptError  
        """  
        self.clear()  
  
        self._setup(project, prog, version, usage, default_config_files)  
  
        self._cli_values, leftovers = self._parse_cli_opts(args) # HERE IS THE REAL SOURCE  
  
        self._parse_config_files() # HERE IS THE REAL SOURCE  
  
        self._check_required_opts()  
  
        return leftovers  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/store/swift.py#L72-L584  
  
class StoreLocation(glance.store.location.StoreLocation):  
  
    """  
    Class describing a Swift URI. A Swift URI can look like any of  
    the following:  
        swift://user:pass@authurl.com/container/obj-id  
        swift://account:user:pass@authurl.com/container/obj-id  
        swift+http://user:pass@authurl.com/container/obj-id  
        swift+https://user:pass@authurl.com/container/obj-id  
    When using multi-tenant a URI might look like this (a storage URL):  
        swift+https://example.com/container/obj-id  
    The swift+http:// URIs indicate there is an HTTP authentication URL.  
    The default for Swift is an HTTPS authentication URL, so swift:// and  
    swift+https:// are the same...  
    """  
  
    def process_specs(self):  
        self.scheme = self.specs.get('scheme', 'swift+https')  
        self.user = self.specs.get('user')  
        self.key = self.specs.get('key')  
        self.auth_or_store_url = self.specs.get('auth_or_store_url')  
        self.container = self.specs.get('container')  
        self.obj = self.specs.get('obj')  
  
    def _get_credstring(self):  
        if self.user and self.key:  
            return '%s:%s@' % (urllib.quote(self.user), urllib.quote(self.key))  
        return ''  
  
    def get_uri(self):  
        auth_or_store_url = self.auth_or_store_url  
        if auth_or_store_url.startswith('http://'):  
            auth_or_store_url = auth_or_store_url[len('http://'):]  
        elif auth_or_store_url.startswith('https://'):  
            auth_or_store_url = auth_or_store_url[len('https://'):]  
  
        credstring = self._get_credstring()  
        auth_or_store_url = auth_or_store_url.strip('/')  
        container = self.container.strip('/')  
        obj = self.obj.strip('/')  
  
        return '%s://%s%s/%s/%s' % (self.scheme, credstring, auth_or_store_url,  
                                    container, obj)  
  
    def parse_uri(self, uri):  
        """  
        Parse URLs. This method fixes an issue where credentials specified  
        in the URL are interpreted differently in Python 2.6.1+ than prior  
        versions of Python. It also deals with the peculiarity that new-style  
        Swift URIs have where a username can contain a ':', like so:  
            swift://account:user:pass@authurl.com/container/obj  
        """  
        # Make sure that URIs that contain multiple schemes, such as:  
        # swift://user:pass@http://authurl.com/v1/container/obj  
        # are immediately rejected.  
        if uri.count('://') != 1:  
            reason = _("URI cannot contain more than one occurrence "  
                       "of a scheme. If you have specified a URI like "  
                       "swift://user:pass@http://authurl.com/v1/container/obj"  
                       ", you need to change it to use the "  
                       "swift+http:// scheme, like so: "  
                       "swift+http://user:pass@authurl.com/v1/container/obj")  
            LOG.debug(_("Invalid store uri %(uri)s: %(reason)s") % locals()) # HERE IS THE SINK 1  
            raise exception.BadStoreUri(message=reason)  
  
        pieces = urlparse.urlparse(uri)  
        assert pieces.scheme in ('swift', 'swift+http', 'swift+https')  
        self.scheme = pieces.scheme  
        netloc = pieces.netloc  
        path = pieces.path.lstrip('/')  
        if netloc != '':  
            # > Python 2.6.1  
            if '@' in netloc:  
                creds, netloc = netloc.split('@')  
            else:  
                creds = None  
        else:  
            # Python 2.6.1 compat  
            # see lp659445 and Python issue7904  
            if '@' in path:  
                creds, path = path.split('@')  
            else:  
                creds = None  
            netloc = path[0:path.find('/')].strip('/')  
            path = path[path.find('/'):].strip('/')  
        if creds:  
            cred_parts = creds.split(':')  
            if len(cred_parts) != 2:  
                reason = (_("Badly formed credentials '%(creds)s' in Swift "  
                            "URI") % locals())  
                LOG.debug(reason) # HERE IS THE SINK 2  
                raise exception.BadStoreUri()  
            user, key = cred_parts  
            self.user = urllib.unquote(user)  
            self.key = urllib.unquote(key)  
        else:  
            self.user = None  
            self.key = None  
        path_parts = path.split('/')  
        try:  
            self.obj = path_parts.pop()  
            self.container = path_parts.pop()  
            if not netloc.startswith('http'):  
                # push hostname back into the remaining to build full authurl  
                path_parts.insert(0, netloc)  
                self.auth_or_store_url = '/'.join(path_parts)  
        except IndexError:  
            reason = _("Badly formed Swift URI: %s") % uri  
            LOG.debug(reason)  # HERE IS THE SINK 3  
            raise exception.BadStoreUri()  
  
    @property  
    def swift_url(self):  
        """  
        Creates a fully-qualified auth url that the Swift client library can  
        use. The scheme for the auth_url is determined using the scheme  
        included in the `location` field.  
        HTTPS is assumed, unless 'swift+http' is specified.  
        """  
        if self.auth_or_store_url.startswith('http'):  
            return self.auth_or_store_url  
        else:  
            if self.scheme in ('swift+https', 'swift'):  
                auth_scheme = 'https://'  
            else:  
                auth_scheme = 'http://'  
  
            return ''.join([auth_scheme, self.auth_or_store_url])  
  
  
def Store(context=None, loc=None):  
    if (CONF.swift_store_multi_tenant and  
            (loc is None or loc.store_location.user is None)):  
        return MultiTenantStore(context, loc)  
    return SingleTenantStore(context, loc)  
  
  
class BaseStore(glance.store.base.Store):  
    CHUNKSIZE = 65536  
  
    def get_schemes(self):  
        return ('swift+https', 'swift', 'swift+http')  
  
    def configure(self):  
        _obj_size = self._option_get('swift_store_large_object_size')  
        self.large_object_size = _obj_size * ONE_MB  
        _chunk_size = self._option_get('swift_store_large_object_chunk_size')  
        self.large_object_chunk_size = _chunk_size * ONE_MB  
        self.admin_tenants = CONF.swift_store_admin_tenants  
        self.region = CONF.swift_store_region  
        self.service_type = CONF.swift_store_service_type  
        self.endpoint_type = CONF.swift_store_endpoint_type  
        self.snet = CONF.swift_enable_snet  
  
    def get(self, location, connection=None):  
        location = location.store_location  
        if not connection:  
            connection = self.get_connection(location)  
  
        try:  
            resp_headers, resp_body = connection.get_object(  
                    container=location.container, obj=location.obj,  
                    resp_chunk_size=self.CHUNKSIZE)  
        except swiftclient.ClientException, e:  
            if e.http_status == httplib.NOT_FOUND:  
                uri = location.get_uri()  
                raise exception.NotFound(_("Swift could not find image at "  
                                           "uri %(uri)s") % locals()) # HERE IS THE INNER SINK FOR SINK 6  
            else:  
                raise  
  
        class ResponseIndexable(glance.store.Indexable):  
            def another(self):  
                try:  
                    return self.wrapped.next()  
                except StopIteration:  
                    return ''  
  
        length = int(resp_headers.get('content-length', 0))  
        return (ResponseIndexable(resp_body, length), length)  
  
    def get_size(self, location, connection=None):  
        location = location.store_location  
        if not connection:  
            connection = self.get_connection(location)  
        try:  
            resp_headers = connection.head_object(  
                    container=location.container, obj=location.obj)  
            return int(resp_headers.get('content-length', 0))  
        except Exception:  
            return 0  
  
    def _option_get(self, param):  
        result = getattr(CONF, param)  
        if not result:  
            reason = (_("Could not find %(param)s in configuration "  
                        "options.") % locals())  
            LOG.error(reason)  
            raise exception.BadStoreConfiguration(store_name="swift",  
                                                  reason=reason)  
        return result  
  
    def add(self, image_id, image_file, image_size, connection=None):  
        location = self.create_location(image_id)  
        if not connection:  
            connection = self.get_connection(location)  
  
        self._create_container_if_missing(location.container, connection)  
  
        LOG.debug(_("Adding image object '%(obj_name)s' "  
                    "to Swift") % dict(obj_name=location.obj))  
        try:  
            if image_size > 0 and image_size < self.large_object_size:  
                # Image size is known, and is less than large_object_size.  
                # Send to Swift with regular PUT.  
                obj_etag = connection.put_object(location.container,  
                                                 location.obj, image_file,  
                                                 content_length=image_size)  
            else:  
                # Write the image into Swift in chunks.  
                chunk_id = 1  
                if image_size > 0:  
                    total_chunks = str(int(  
                        math.ceil(float(image_size) /  
                                  float(self.large_object_chunk_size))))  
                else:  
                    # image_size == 0 is when we don't know the size  
                    # of the image. This can occur with older clients  
                    # that don't inspect the payload size.  
                    LOG.debug(_("Cannot determine image size. Adding as a "  
                                "segmented object to Swift."))  
                    total_chunks = '?'  
  
                checksum = hashlib.md5()  
                combined_chunks_size = 0  
                while True:  
                    chunk_size = self.large_object_chunk_size  
                    if image_size == 0:  
                        content_length = None  
                    else:  
                        left = image_size - combined_chunks_size  
                        if left == 0:  
                            break  
                        if chunk_size > left:  
                            chunk_size = left  
                        content_length = chunk_size  
  
                    chunk_name = "%s-%05d" % (location.obj, chunk_id)  
                    reader = ChunkReader(image_file, checksum, chunk_size)  
                    chunk_etag = connection.put_object(  
                        location.container, chunk_name, reader,  
                        content_length=content_length)  
                    bytes_read = reader.bytes_read  
                    msg = _("Wrote chunk %(chunk_name)s (%(chunk_id)d/"  
                            "%(total_chunks)s) of length %(bytes_read)d "  
                            "to Swift returning MD5 of content: "  
                            "%(chunk_etag)s")  
                    LOG.debug(msg % locals())  
  
                    if bytes_read == 0:  
                        # Delete the last chunk, because it's of zero size.  
                        # This will happen if size == 0.  
                        LOG.debug(_("Deleting final zero-length chunk"))  
                        connection.delete_object(location.container,  
                                                 chunk_name)  
                        break  
  
                    chunk_id += 1  
                    combined_chunks_size += bytes_read  
  
                # In the case we have been given an unknown image size,  
                # set the size to the total size of the combined chunks.  
                if image_size == 0:  
                    image_size = combined_chunks_size  
  
                # Now we write the object manifest and return the  
                # manifest's etag...  
                manifest = "%s/%s" % (location.container, location.obj)  
                headers = {'ETag': hashlib.md5("").hexdigest(),  
                           'X-Object-Manifest': manifest}  
  
                # The ETag returned for the manifest is actually the  
                # MD5 hash of the concatenated checksums of the strings  
                # of each chunk...so we ignore this result in favour of  
                # the MD5 of the entire image file contents, so that  
                # users can verify the image file contents accordingly  
                connection.put_object(location.container, location.obj,  
                                      None, headers=headers)  
                obj_etag = checksum.hexdigest()  
  
            # NOTE: We return the user and key here! Have to because  
            # location is used by the API server to return the actual  
            # image data. We *really* should consider NOT returning  
            # the location attribute from GET /images/<ID> and  
            # GET /images/details  
  
            return (location.get_uri(), image_size, obj_etag)  
        except swiftclient.ClientException, e:  
            if e.http_status == httplib.CONFLICT:  
                raise exception.Duplicate(_("Swift already has an image at "  
                                            "location %s") %  
                                          location.get_uri())  
            msg = (_("Failed to add object to Swift.\n"  
                     "Got error from Swift: %(e)s") % locals())  
            LOG.error(msg) # HERE IS THE SINK 4  
            raise glance.store.BackendException(msg)  
  
    def delete(self, location, connection=None):  
        location = location.store_location  
        if not connection:  
            connection = self.get_connection(location)  
  
        try:  
            # We request the manifest for the object. If one exists,  
            # that means the object was uploaded in chunks/segments,  
            # and we need to delete all the chunks as well as the  
            # manifest.  
            manifest = None  
            try:  
                headers = connection.head_object(  
                        location.container, location.obj)  
                manifest = headers.get('x-object-manifest')  
            except swiftclient.ClientException, e:  
                if e.http_status != httplib.NOT_FOUND:  
                    raise  
            if manifest:  
                # Delete all the chunks before the object manifest itself  
                obj_container, obj_prefix = manifest.split('/', 1)  
                segments = connection.get_container(  
                        obj_container, prefix=obj_prefix)[1]  
                for segment in segments:  
                    # TODO(jaypipes): This would be an easy area to parallelize  
                    # since we're simply sending off parallelizable requests  
                    # to Swift to delete stuff. It's not like we're going to  
                    # be hogging up network or file I/O here...  
                    connection.delete_object(  
                            obj_container, segment['name'])  
  
            else:  
                connection.delete_object(location.container, location.obj)  
  
        except swiftclient.ClientException, e:  
            if e.http_status == httplib.NOT_FOUND:  
                uri = location.get_uri()  
                raise exception.NotFound(_("Swift could not find image at "  
                                           "uri %(uri)s") % locals())  # HERE IS THE INNER SINK FOR SINK 7  
            else:  
                raise  
  
    def _create_container_if_missing(self, container, connection):  
        """  
        Creates a missing container in Swift if the  
        ``swift_store_create_container_on_put`` option is set.  
        :param container: Name of container to create  
        :param connection: Connection to swift service  
        """  
        try:  
            connection.head_container(container)  
        except swiftclient.ClientException, e:  
            if e.http_status == httplib.NOT_FOUND:  
                if CONF.swift_store_create_container_on_put:  
                    try:  
                        connection.put_container(container)  
                    except swiftclient.ClientException, e:  
                        msg = _("Failed to add container to Swift.\n"  
                                "Got error from Swift: %(e)s") % locals()  
                        raise glance.store.BackendException(msg)  
                else:  
                    msg = (_("The container %(container)s does not exist in "  
                             "Swift. Please set the "  
                             "swift_store_create_container_on_put option"  
                             "to add container to Swift automatically.") %  
                           locals())  
                    raise glance.store.BackendException(msg)  
            else:  
                raise  
  
    def get_connection(self):  
        raise NotImplemented()  
  
    def create_location(self):  
        raise NotImplemented()  
  
  
class SingleTenantStore(BaseStore):  
    EXAMPLE_URL = "swift://<USER>:<KEY>@<AUTH_ADDRESS>/<CONTAINER>/<FILE>"  
  
    def configure(self):  
        super(SingleTenantStore, self).configure()  
        self.auth_version = self._option_get('swift_store_auth_version')  
  
    def configure_add(self):  
        self.auth_address = self._option_get('swift_store_auth_address')  
        if self.auth_address.startswith('http://'):  
            self.scheme = 'swift+http'  
        else:  
            self.scheme = 'swift+https'  
        self.container = CONF.swift_store_container  
        self.user = self._option_get('swift_store_user')  
        self.key = self._option_get('swift_store_key')  
  
    def create_location(self, image_id):  
        specs = {'scheme': self.scheme,  
                 'container': self.container,  
                 'obj': str(image_id),  
                 'auth_or_store_url': self.auth_address,  
                 'user': self.user,  
                 'key': self.key}  
        return StoreLocation(specs)  
  
    def get_connection(self, location):  
        if not location.user:  
            reason = (_("Location is missing user:password information."))  
            LOG.debug(reason)  
            raise exception.BadStoreUri(message=reason)  
  
        auth_url = location.swift_url  
        if not auth_url.endswith('/'):  
            auth_url += '/'  
  
        if self.auth_version == '2':  
            try:  
                tenant_name, user = location.user.split(':')  
            except ValueError:  
                reason = (_("Badly formed tenant:user '%(user)s' in "  
                            "Swift URI") % {'user': location.user})  
                LOG.debug(reason)  
                raise exception.BadStoreUri()  
        else:  
            tenant_name = None  
            user = location.user  
  
        os_options = {}  
        if self.region:  
            os_options['region_name'] = self.region  
        os_options['endpoint_type'] = self.endpoint_type  
        os_options['service_type'] = self.service_type  
  
        return swiftclient.Connection(  
                auth_url, user, location.key,  
                tenant_name=tenant_name, snet=self.snet,  
                auth_version=self.auth_version, os_options=os_options)  
  
  
class MultiTenantStore(BaseStore):  
    EXAMPLE_URL = "swift://<SWIFT_URL>/<CONTAINER>/<FILE>"  
  
    def configure_add(self):  
        self.container = CONF.swift_store_container  
        if self.context is None:  
            reason = _("Multi-tenant Swift storage requires a context.")  
            raise exception.BadStoreConfiguration(store_name="swift",  
                                                  reason=reason)  
        if self.context.service_catalog is None:  
            reason = _("Multi-tenant Swift storage requires "  
                       "a service catalog.")  
            raise exception.BadStoreConfiguration(store_name="swift",  
                                                  reason=reason)  
        self.storage_url = auth.get_endpoint(  
                self.context.service_catalog, service_type=self.service_type,  
                endpoint_region=self.region, endpoint_type=self.endpoint_type)  
        if self.storage_url.startswith('http://'):  
            self.scheme = 'swift+http'  
        else:  
            self.scheme = 'swift+https'  
  
    def delete(self, location, connection=None):  
        if not connection:  
            connection = self.get_connection(location.store_location)  
        super(MultiTenantStore, self).delete(location, connection)  
        connection.delete_container(location.store_location.container)  
  
    def set_acls(self, location, public=False, read_tenants=None,  
                 write_tenants=None, connection=None):  
        location = location.store_location  
        if not connection:  
            connection = self.get_connection(location)  
  
        if read_tenants is None:  
            read_tenants = []  
        if write_tenants is None:  
            write_tenants = []  
  
        headers = {}  
        if public:  
            headers['X-Container-Read'] = ".r:*"  
        elif read_tenants:  
            headers['X-Container-Read'] = ','.join(read_tenants)  
        else:  
            headers['X-Container-Read'] = ''  
  
        write_tenants.extend(self.admin_tenants)  
        if write_tenants:  
            headers['X-Container-Write'] = ','.join(write_tenants)  
        else:  
            headers['X-Container-Write'] = ''  
  
        try:  
            connection.post_container(location.container, headers=headers)  
        except swiftclient.ClientException, e:  
            if e.http_status == httplib.NOT_FOUND:  
                uri = location.get_uri()  
                raise exception.NotFound(_("Swift could not find image at "  
                                           "uri %(uri)s") % locals())  # HERE IS THE INNER SINK FOR SINK 7, 8, 9  
            else:  
                raise  
  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/api/v1/images.py#L389-L396  
            try:  
                image_data, image_size = self._get_from_store(req.context,  
                                                              copy_from)  
            except Exception as e:  
                self._safe_kill(req, image_meta['id'])  
                msg = _("Copy from external source failed: %s") % e  
                LOG.debug(msg) # HERE IS THE SINK 5  
                return  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/api/v1/images.py#L815-L835  
        try:  
            # Delete the image from the registry first, since we rely on it  
            # for authorization checks.  
            # See https://bugs.launchpad.net/glance/+bug/1065187  
            registry.update_image_metadata(req.context, id, {'status': status})  
            registry.delete_image_metadata(req.context, id)  
  
            # The image's location field may be None in the case  
            # of a saving or queued image, therefore don't ask a backend  
            # to delete the image if the backend doesn't yet store it.  
            # See https://bugs.launchpad.net/glance/+bug/747799  
            if image['location']:  
                if CONF.delayed_delete:  
                    schedule_delayed_delete_from_backend(image['location'], id)  
                else:  
                    safe_delete_from_backend(image['location'],  
                                             req.context, id)  
        except exception.NotFound, e:  
            msg = (_("Failed to find image to delete: %(e)s") % locals())  
            for line in msg.split('\n'):  
                LOG.info(line) # HERE IS THE SINK 6  
  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/api/v1/members.py#L63-L79  
    def delete(self, req, image_id, id):  
        """  
        Removes a membership from the image.  
        """  
        self._check_can_access_image_members(req.context)  
  
        try:  
            registry.delete_member(req.context, image_id, id)  
            self._update_store_acls(req, image_id)  
        except exception.NotFound, e:  
            msg = "%s" % e  
            LOG.debug(msg) # HERE IS THE SINK 7  
            raise webob.exc.HTTPNotFound(msg)  
        except exception.Forbidden, e:  
            msg = "%s" % e  
            LOG.debug(msg)  
            raise webob.exc.HTTPNotFound(msg)  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/api/v1/members.py#L88-L123  
    def update(self, req, image_id, id, body=None):  
        """  
        Adds a membership to the image, or updates an existing one.  
        If a body is present, it is a dict with the following format::  
            {"member": {  
                "can_share": [True|False]  
            }}  
        If "can_share" is provided, the member's ability to share is  
        set accordingly.  If it is not provided, existing memberships  
        remain unchanged and new memberships default to False.  
        """  
        self._check_can_access_image_members(req.context)  
  
        # Figure out can_share  
        can_share = None  
        if body and 'member' in body and 'can_share' in body['member']:  
            can_share = bool(body['member']['can_share'])  
        try:  
            registry.add_member(req.context, image_id, id, can_share)  
            self._update_store_acls(req, image_id)  
        except exception.Invalid, e:  
            msg = "%s" % e  
            LOG.debug(msg)  
            raise webob.exc.HTTPBadRequest(explanation=msg)  
        except exception.NotFound, e:  
            msg = "%s" % e  
            LOG.debug(msg) # HERE IS THE SINK 8  
            raise webob.exc.HTTPNotFound(msg)  
        except exception.Forbidden, e:  
            msg = "%s" % e  
            LOG.debug(msg)  
            raise webob.exc.HTTPNotFound(msg)  
  
        return webob.exc.HTTPNoContent()  
  
# https://github.com/openstack/glance/blob/4b768a4a847a0f5c857f4fe3f3bca720da9b3949/glance/api/v1/members.py#L126-L154  
    def update_all(self, req, image_id, body):  
        """  
        Replaces the members of the image with those specified in the  
        body.  The body is a dict with the following format::  
            {"memberships": [  
                {"member_id": <MEMBER_ID>,  
                 ["can_share": [True|False]]}, ...  
            ]}  
        """  
        self._check_can_access_image_members(req.context)  
  
        try:  
            registry.replace_members(req.context, image_id, body)  
            self._update_store_acls(req, image_id)  
        except exception.Invalid, e:  
            msg = "%s" % e  
            LOG.debug(msg)  
            raise webob.exc.HTTPBadRequest(explanation=msg)  
        except exception.NotFound, e:  
            msg = "%s" % e  
            LOG.debug(msg)  
            raise webob.exc.HTTPNotFound(msg) # HERE IS THE SINK 9  
        except exception.Forbidden, e:  
            msg = "%s" % e  
            LOG.debug(msg)  
            raise webob.exc.HTTPNotFound(msg)  
  
        return webob.exc.HTTPNoContent()  
  
```  
