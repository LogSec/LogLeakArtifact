## Summary:  
Software: yast2-rmt  
## Fix:  
Commit: https://github.com/yast/yast-rmt/commit/23dc67de3fd42c7b04de1e35edb6f23a82c0a09b  
Change Size: +31 -11  
Author: Serhii Kotov  
Fix Time (of the Last Commit): 2019-02-18  
Fix Pattern: Disable Logging in Default  
Fixing-commits Count: 1  
Total Change Size: +31 -11  
## Sample logs: Yes  
```  
2018-12-17 15:26:18 <1> rmtserversle15(11436) [Ruby] lib/cheetah.rb:206 Standard input: $PASSWORD  
2018-12-17 15:26:18 <1> rmtserversle15(11436) [Ruby] lib/cheetah.rb:206 Standard input: $PASSWORD  
2018-12-17 15:26:19 <1> rmtserversle15(11436) [Ruby] lib/cheetah.rb:206 Standard input: $PASSWORD  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（recorder.record_status）  
Sensitiveness-Identifiable Source:  Cross Projects|Cross-Libraries（https://github.com/yast/yast-rmt/blob/23dc67de3fd42c7b04de1e35edb6f23a82c0a09b/src/lib/rmt/ssl/certificate_generator.rb#L109） -> Variable Names（ca_password）  
Programming Language:Ruby  
```ruby  
  
# https://github.com/yast/yast-rmt/blob/23dc67de3fd42c7b04de1e35edb6f23a82c0a09b/src/lib/rmt/ssl/certificate_generator.rb#L105-L111  
  
      RMT::Execute.on_target!(  
        'openssl', 'req', '-x509', '-new', '-nodes', '-key', @ssl_paths[:ca_private_key],  
        '-sha256', '-days', OPENSSL_CA_VALIDITY_DAYS, '-out', @ssl_paths[:ca_certificate],  
        '-passin', 'stdin', '-config', @ssl_paths[:ca_config],  
        stdin: ca_password,  
        logger: nil # do not log in order to securely pass password  
      )  
  
# https://github.com/yast/yast-rmt/blob/23dc67de3fd42c7b04de1e35edb6f23a82c0a09b/src/lib/rmt/execute.rb#L37-L47  
  
  def self.on_target!(*args)  
    root = Yast::WFM.scr_root  
  
    if args.last.is_a? ::Hash  
      args.last[:chroot] = root  
    else  
      args.push(chroot: root)  
    end  
  
    Cheetah.run(*args) # HERE IS THE EXPLICIT SINK  
  end  
  
# https://github.com/openSUSE/cheetah/blob/fe0ebe9d292dfd1c4786a907b8540fe769fcdcd0/lib/cheetah.rb#L383-L410  
    def run(*args)  
      options = args.last.is_a?(Hash) ? args.pop : {}  
      options = BUILTIN_DEFAULT_OPTIONS.merge(@default_options).merge(options)  
  
      options[:stdin] ||= "" # allow passing nil stdin see issue gh#11  
      if !options[:allowed_exitstatus].respond_to?(:include?)  
        options[:allowed_exitstatus] = Array(options[:allowed_exitstatus])  
      end  
  
      streamed = compute_streamed(options)  
      streams  = build_streams(options, streamed)  
      commands = build_commands(args)  
      recorder = build_recorder(options)  
  
      recorder.record_commands(commands)  
  
      pid, pipes = fork_commands(commands, options)  
      select_loop(streams, pipes, recorder)  
      _pid, status = Process.wait2(pid)  
  
      begin  
        check_errors(commands, status, streams, streamed, options)  
      ensure  
        recorder.record_status(status)  
      end  
  
      build_result(streams, status, options)  
    end  
  
# https://github.com/openSUSE/cheetah/blob/fe0ebe9d292dfd1c4786a907b8540fe769fcdcd0/lib/cheetah.rb#L142-L211  
  
  # A default recorder. It uses the `Logger::INFO` level for normal messages and  
  # the `Logger::ERROR` level for messages about errors (non-zero exit status or  
  # non-empty error output). Used by {Cheetah.run} when a logger is passed.  
  class DefaultRecorder < Recorder  
    # @private  
    STREAM_INFO = {  
      stdin:  { name: "Standard input",  method: :info  },  
      stdout: { name: "Standard output", method: :info  },  
      stderr: { name: "Error output",    method: :error }  
    }  
  
    def initialize(logger)  
      @logger = logger  
  
      @stream_used   = { stdin: false, stdout: false, stderr: false }  
      @stream_buffer = { stdin: "",    stdout: "",    stderr: "" }  
    end  
  
    def record_commands(commands)  
      @logger.info "Executing #{format_commands(commands)}."  
    end  
  
    def record_stdin(stdin)  
      log_stream_increment(:stdin, stdin)  
    end  
  
    def record_stdout(stdout)  
      log_stream_increment(:stdout, stdout)  
    end  
  
    def record_stderr(stderr)  
      log_stream_increment(:stderr, stderr)  
    end  
  
    def record_status(status)  
      log_stream_remainder(:stdin)  
      log_stream_remainder(:stdout)  
      log_stream_remainder(:stderr)  
  
      @logger.send status.success? ? :info : :error,  
                   "Status: #{status.exitstatus}"  
    end  
  
    protected  
  
    def format_commands(commands)  
      '"' + commands.map { |c| Shellwords.join(c) }.join(" | ") + '"'  
    end  
  
    def log_stream_increment(stream, data)  
      @stream_buffer[stream] + data =~ /\A((?:.*\n)*)(.*)\z/  
      lines = Regexp.last_match(1)  
      rest = Regexp.last_match(2)  
  
      lines.each_line { |l| log_stream_line(stream, l) }  
  
      @stream_used[stream] = true  
      @stream_buffer[stream] = rest  
    end  
  
    def log_stream_remainder(stream)  
      return if !@stream_used[stream] || @stream_buffer[stream].empty?  
  
      log_stream_line(stream, @stream_buffer[stream])  
    end  
  
    def log_stream_line(stream, line)  
      @logger.send(  
        STREAM_INFO[stream][:method],  
        "#{STREAM_INFO[stream][:name]}: #{line.chomp}"  
      ) # HERE IS THE SINK 1  
    end  
  end  
  
```  
