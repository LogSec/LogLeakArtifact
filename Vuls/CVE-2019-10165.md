## Summary:  
Software: openshift_container_platform  
## Fix:  
Commit: https://github.com/enj/cluster-kube-apiserver-operator/commit/6b5874027b4a60019dedc9fb8803fe3d82215a2e  
Author: Mo Khan  
Fix Time (of the Last Commit): 2019-06-07  
Fix Pattern: Sanitization -> Redaction -> Reuse -> Tag/TypeBasedFiltration  
  
  
Fixing-commits Count: 2  
Total Change Size: +95 -2  
  
========  
PR: https://github.com/openshift/origin/pull/23074  
Commit: https://github.com/enj/origin/commit/85a10deed2d764b663b01a5811c53fc6056ad097  
Change Size: +85 -2  
Time: 2019-06-14  
Comment: add test  
PR: https://github.com/openshift/cluster-kube-apiserver-operator/pull/499  
Commit: https://github.com/enj/cluster-kube-apiserver-operator/commit/6b5874027b4a60019dedc9fb8803fe3d82215a2e  
Change Size: +10 -0  
Time: 2019-06-07  
Comment: main logic to fix the vulnerability  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> OAuth tokens  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（fmt.Fprint）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/openshift/oauth-apiserver/blob/cc5c2748f7bd719acbca1fbc54dd09d5919587b2/pkg/oauth/api/types.go#L7） -> Type Names（OAuthAccessToken）  
Programming Language:Go  
```Go  
  
// https://github.com/kubernetes/apiserver/blob/92392ef22153d75b3645b0ae339f89c12767fb52/plugin/pkg/audit/log/backend.go#L62-L92  
  
func (b *backend) ProcessEvents(events ...*auditinternal.Event) bool {  
	success := true  
	for _, ev := range events {  
		success = b.logEvent(ev) && success // HERE IS THE FLOW  
	}  
	return success  
}  
  
func (b *backend) logEvent(ev *auditinternal.Event) bool {  
	line := ""  
	switch b.format {  
	case FormatLegacy:  
		line = audit.EventString(ev) + "\n"  
	case FormatJson:  
		bs, err := runtime.Encode(b.encoder, ev)  
		if err != nil {  
			audit.HandlePluginError(PluginName, err, ev)  
			return false  
		}  
		line = string(bs[:])  
	default:  
		audit.HandlePluginError(PluginName, fmt.Errorf("log format %q is not in list of known formats (%s)",  
			b.format, strings.Join(AllowedFormats, ",")), ev)  
		return false  
	}  
	if _, err := fmt.Fprint(b.out, line); err != nil { // HERE IS THE SINK  
		audit.HandlePluginError(PluginName, err, ev)  
		return false  
	}  
	return true  
}  
  
// https://github.com/kubernetes/apiserver/blob/92392ef22153d75b3645b0ae339f89c12767fb52/pkg/endpoints/filters/audit.go#L149-L163  
func processAuditEvent(ctx context.Context, sink audit.Sink, ev *auditinternal.Event, omitStages []auditinternal.Stage) bool {  
	for _, stage := range omitStages {  
		if ev.Stage == stage {  
			return true  
		}  
	}  
  
	if ev.Stage == auditinternal.StageRequestReceived {  
		ev.StageTimestamp = metav1.NewMicroTime(ev.RequestReceivedTimestamp.Time)  
	} else {  
		ev.StageTimestamp = metav1.NewMicroTime(time.Now())  
	}  
	audit.ObserveEvent(ctx)  
	return sink.ProcessEvents(ev)  
}  
  
// https://github.com/kubernetes/apiserver/blob/92392ef22153d75b3645b0ae339f89c12767fb52/pkg/endpoints/filters/audit.go#L38-L113  
  
// WithAudit decorates a http.Handler with audit logging information for all the  
// requests coming to the server. Audit level is decided according to requests'  
// attributes and audit policy. Logs are emitted to the audit sink to  
// process events. If sink or audit policy is nil, no decoration takes place.  
func WithAudit(handler http.Handler, sink audit.Sink, policy policy.Checker, longRunningCheck request.LongRunningRequestCheck) http.Handler {  
	if sink == nil || policy == nil {  
		return handler  
	}  
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {  
		req, ev, omitStages, err := createAuditEventAndAttachToContext(req, policy)  
		if err != nil {  
			utilruntime.HandleError(fmt.Errorf("failed to create audit event: %v", err))  
			responsewriters.InternalError(w, req, errors.New("failed to create audit event"))  
			return  
		}  
		ctx := req.Context()  
		if ev == nil || ctx == nil {  
			handler.ServeHTTP(w, req)  
			return  
		}  
  
		ev.Stage = auditinternal.StageRequestReceived  
		if processed := processAuditEvent(ctx, sink, ev, omitStages); !processed {  
			audit.ApiserverAuditDroppedCounter.WithContext(ctx).Inc()  
			responsewriters.InternalError(w, req, errors.New("failed to store audit event"))  
			return  
		}  
  
		// intercept the status code  
		var longRunningSink audit.Sink  
		if longRunningCheck != nil {  
			ri, _ := request.RequestInfoFrom(ctx)  
			if longRunningCheck(req, ri) {  
				longRunningSink = sink  
			}  
		}  
		respWriter := decorateResponseWriter(ctx, w, ev, longRunningSink, omitStages)  
  
		// send audit event when we leave this func, either via a panic or cleanly. In the case of long  
		// running requests, this will be the second audit event.  
		defer func() {  
			if r := recover(); r != nil {  
				defer panic(r)  
				ev.Stage = auditinternal.StagePanic  
				ev.ResponseStatus = &metav1.Status{  
					Code:    http.StatusInternalServerError,  
					Status:  metav1.StatusFailure,  
					Reason:  metav1.StatusReasonInternalError,  
					Message: fmt.Sprintf("APIServer panic'd: %v", r),  
				}  
				processAuditEvent(ctx, sink, ev, omitStages)  
				return  
			}  
  
			// if no StageResponseStarted event was sent b/c neither a status code nor a body was sent, fake it here  
			// But Audit-Id http header will only be sent when http.ResponseWriter.WriteHeader is called.  
			fakedSuccessStatus := &metav1.Status{  
				Code:    http.StatusOK,  
				Status:  metav1.StatusSuccess,  
				Message: "Connection closed early",  
			}  
			if ev.ResponseStatus == nil && longRunningSink != nil {  
				ev.ResponseStatus = fakedSuccessStatus  
				ev.Stage = auditinternal.StageResponseStarted  
				processAuditEvent(ctx, longRunningSink, ev, omitStages)  
			}  
  
			ev.Stage = auditinternal.StageResponseComplete  
			if ev.ResponseStatus == nil {  
				ev.ResponseStatus = fakedSuccessStatus  
			}  
			processAuditEvent(ctx, sink, ev, omitStages)  
		}()  
		handler.ServeHTTP(respWriter, req)  
	})  
}  
  
```  
