## Summary:  
Software: wicd  
## Fix:  
Commit: https://github.com/zeph/wicd/commit/9f5db3cf5b59312aa85fb5b91c3ddeeeabe3842e  
Change Size: +7 -2  
Fix Time (of the Last Commit): 2011-12-17  
Author: David Paleino  
Fix Pattern: Sanitization -> Redaction -> Introduction -> Keyword/RegexBasedFiltration -> NoRedactionFunctionDefined  
  
Fixing-commits Count: 1  
Total Change Size: +7 -2  
  
  
========  
Backup: http://bazaar.launchpad.net/~wicd-devel/wicd/experimental/revision/682  
## Sample logs: Yes  
```  
  
2019/07/14 12:42:45 :: ifconfig wlp61s0  
2019/07/14 12:42:45 :: GetCurrentNetworkID: Returning -1, current network not found  
2019/07/14 12:42:45 :: Autoconnecting...  
2019/07/14 12:42:45 :: Starting wireless autoconnect...  
2019/07/14 12:42:45 :: No wired connection present, attempting to autoconnect to wireless network  
2019/07/14 12:42:45 :: scanning start  
2019/07/14 12:42:45 :: ifconfig wlp61s0 up  
2019/07/14 12:42:45 :: iwlist wlp61s0 scan  
2019/07/14 12:42:48 :: scanning done  
2019/07/14 12:42:48 :: found 4 networks:  
2019/07/14 12:42:48 :: Unable to autoconnect, you'll have to manually connect  
2019/07/14 12:42:50 :: ifconfig wlp61s0  
2019/07/14 12:42:50 :: GetCurrentNetworkID: Returning -1, current network not found  
2019/07/14 12:42:50 :: Autoconnecting...  
2019/07/14 12:42:50 :: Starting wireless autoconnect...  
2019/07/14 12:42:50 :: No wired connection present, attempting to autoconnect to wireless network  
2019/07/14 12:42:50 :: scanning start  
2019/07/14 12:42:50 :: ifconfig wlp61s0 up  
2019/07/14 12:42:50 :: iwlist wlp61s0 scan  
2019/07/14 12:42:53 :: scanning done  
2019/07/14 12:42:53 :: found 8 networks:  
2019/07/14 12:42:53 :: found afterscript in configuration None  
2019/07/14 12:42:53 :: found dhcphostname in configuration zira  
2019/07/14 12:42:53 :: found ip in configuration None  
2019/07/14 12:42:53 :: found dns_domain in configuration None  
2019/07/14 12:42:53 :: found gateway in configuration None  
2019/07/14 12:42:53 :: found use_global_dns in configuration False  
2019/07/14 12:42:53 :: found postdisconnectscript in configuration None  
2019/07/14 12:42:53 :: found beforescript in configuration None  
2019/07/14 12:42:53 :: found psk in configuration XXX  
2019/07/14 12:42:53 :: found netmask in configuration None  
2019/07/14 12:42:53 :: found key in configuration *****  
2019/07/14 12:42:53 :: found usedhcphostname in configuration 0  
2019/07/14 12:42:53 :: found predisconnectscript in configuration None  
2019/07/14 12:42:53 :: found bitrate in configuration auto  
2019/07/14 12:42:53 :: found enctype in configuration wpa  
2019/07/14 12:42:53 :: found allow_lower_bitrates in configuration 0  
2019/07/14 12:42:53 :: found dns3 in configuration None  
2019/07/14 12:42:53 :: found dns2 in configuration None  
2019/07/14 12:42:53 :: found dns1 in configuration None  
2019/07/14 12:42:53 :: found use_settings_globally in configuration False  
2019/07/14 12:42:53 :: found use_static_dns in configuration False  
2019/07/14 12:42:53 :: found search_domain in configuration None  
2019/07/14 12:42:53 :: Gemini WiFi has profile  
2019/07/14 12:42:53 :: Unable to autoconnect, you'll have to manually connect  
2019/07/14 12:42:55 :: ifconfig wlp61s0  
2019/07/14 12:42:55 :: GetCurrentNetworkID: Returning -1, current network not found  
2019/07/14 12:42:55 :: Autoconnecting...  
2019/07/14 12:42:55 :: Starting wireless autoconnect...  
2019/07/14 12:42:55 :: No wired connection present, attempting to autoconnect to wireless network  
2019/07/14 12:42:55 :: scanning start  
2019/07/14 12:42:55 :: ifconfig wlp61s0 up  
2019/07/14 12:42:55 :: iwlist wlp61s0 scan  
2019/07/14 12:42:58 :: scanning done  
2019/07/14 12:42:58 :: found 8 networks:  
2019/07/14 12:42:58 :: found afterscript in configuration None  
2019/07/14 12:42:58 :: found dhcphostname in configuration zira  
2019/07/14 12:42:58 :: found ip in configuration None  
2019/07/14 12:42:58 :: found dns_domain in configuration None  
2019/07/14 12:42:58 :: found gateway in configuration None  
2019/07/14 12:42:58 :: found use_global_dns in configuration False  
2019/07/14 12:42:58 :: found postdisconnectscript in configuration None  
2019/07/14 12:42:58 :: found beforescript in configuration None  
2019/07/14 12:42:58 :: found psk in configuration XXX  
2019/07/14 12:42:58 :: found netmask in configuration None  
2019/07/14 12:42:58 :: found key in configuration *****  
2019/07/14 12:42:58 :: found usedhcphostname in configuration 0  
2019/07/14 12:42:58 :: found predisconnectscript in configuration None  
2019/07/14 12:42:58 :: found bitrate in configuration auto  
2019/07/14 12:42:58 :: found enctype in configuration wpa  
2019/07/14 12:42:58 :: found allow_lower_bitrates in configuration 0  
2019/07/14 12:42:58 :: found dns3 in configuration None  
2019/07/14 12:42:58 :: found dns2 in configuration None  
2019/07/14 12:42:58 :: found dns1 in configuration None  
2019/07/14 12:42:58 :: found use_settings_globally in configuration False  
2019/07/14 12:42:58 :: found use_static_dns in configuration False  
2019/07/14 12:42:58 :: found search_domain in configuration None  
2019/07/14 12:42:58 :: Gemini WiFi has profile  
2019/07/14 12:42:58 :: Unable to autoconnect, you'll have to manually connect  
2019/07/14 12:43:00 :: ifconfig wlp61s0  
2019/07/14 12:43:00 :: GetCurrentNetworkID: Returning -1, current network not found  
2019/07/14 12:43:00 :: Autoconnecting...  
2019/07/14 12:43:00 :: Starting wireless autoconnect...  
2019/07/14 12:43:00 :: No wired connection present, attempting to autoconnect to wireless network  
2019/07/14 12:43:00 :: scanning start  
2019/07/14 12:43:00 :: ifconfig wlp61s0 up  
2019/07/14 12:43:00 :: iwlist wlp61s0 scan  
2019/07/14 12:43:03 :: scanning done  
2019/07/14 12:43:03 :: found 9 networks:  
2019/07/14 12:43:03 :: found afterscript in configuration None  
2019/07/14 12:43:03 :: found dhcphostname in configuration zira  
2019/07/14 12:43:03 :: found ip in configuration None  
2019/07/14 12:43:03 :: found dns_domain in configuration None  
2019/07/14 12:43:03 :: found gateway in configuration None  
2019/07/14 12:43:03 :: found use_global_dns in configuration False  
2019/07/14 12:43:03 :: found postdisconnectscript in configuration None  
2019/07/14 12:43:03 :: found beforescript in configuration None  
2019/07/14 12:43:03 :: found psk in configuration XXX  
2019/07/14 12:43:03 :: found netmask in configuration None  
2019/07/14 12:43:03 :: found key in configuration *****  
2019/07/14 12:43:03 :: found usedhcphostname in configuration 0  
2019/07/14 12:43:03 :: found predisconnectscript in configuration None  
2019/07/14 12:43:03 :: found bitrate in configuration auto  
2019/07/14 12:43:03 :: found enctype in configuration wpa  
2019/07/14 12:43:03 :: found allow_lower_bitrates in configuration 0  
2019/07/14 12:43:03 :: found dns3 in configuration None  
2019/07/14 12:43:03 :: found dns2 in configuration None  
2019/07/14 12:43:03 :: found dns1 in configuration None  
2019/07/14 12:43:03 :: found use_settings_globally in configuration False  
2019/07/14 12:43:03 :: found use_static_dns in configuration False  
2019/07/14 12:43:03 :: found search_domain in configuration None  
2019/07/14 12:43:03 :: Gemini WiFi has profile  
2019/07/14 12:43:03 :: Unable to autoconnect, you'll have to manually connect  
2019/07/14 12:43:05 :: ifconfig wlp61s0  
2019/07/14 12:43:10 :: ifconfig wlp61s0  
2019/07/14 12:43:15 :: ifconfig wlp61s0  
2019/07/14 12:43:20 :: ifconfig wlp61s0  
  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> passwords and other sensitive information  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（print）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/networking.py#L743，https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/networking.py#L612，https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/networking.py#L580，https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/wicd-daemon.py#L992，https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/wicd-daemon.py#L998） -> Variable Names(key)|Method Names(setKey)  
Programming Language:Python  
```python  
  
# https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/networking.py#L537-L821  
  
class Wireless(Controller):  
    """ A wrapper for common wireless interface functions. """  
  
    def __init__(self, debug=False):  
        """ Initialize the class. """  
        Controller.__init__(self, debug=debug)  
        self._wpa_driver = None  
        self._wireless_interface = None  
        self.wiface = None   
        self.should_verify_ap = True  
  
    # OMIT FOR SIMPLICITY  
  
        def Scan(self, essid=None):  
        """ Scan for available wireless networks.  
        Keyword arguments:  
        essid -- The essid of a hidden network  
        Returns:  
        A list of available networks sorted by strength.  
        """  
        def comp(x, y):  
            if 'quality' in x:  
                key = 'quality'  
            else:  
                key = 'strength'  
            return cmp(x[key], y[key])  
                  
        if not self.wiface: return []  
        wiface = self.wiface  
  
        # Prepare the interface for scanning  
        wiface.Up()  
  
        # If there is a hidden essid then set it now, so that when it is  
        # scanned it will be recognized.  
        essid = misc.Noneify(essid)  
        if essid is not None:  
            print 'Setting hidden essid' + essid  
            wiface.SetEssid(essid)  
            # sleep for a bit; scanning to fast will result in nothing  
            time.sleep(1)  
  
        aps = wiface.GetNetworks() # HERE IS THE FLOW  
        aps.sort(cmp=comp, reverse=True)  
          
        return aps  
  
    # OMIT FOR SIMPLICITY  
  
        def CreateAdHocNetwork(self, essid, channel, ip, enctype, key,  
            enc_used):  
        """ Create an ad-hoc wireless network.  
        Keyword arguments:  
        essid -- essid of the ad-hoc network  
        channel -- channel of the ad-hoc network  
        ip -- ip of the ad-hoc network  
        enctype -- unused  
        key -- key of the ad-hoc network  
        enc_used -- encrytion enabled on ad-hoc network  
        """  
        wiface = self.wiface  
        print 'Creating ad-hoc network'  
        print 'Stopping dhcp client and wpa_supplicant'  
        wiface.ReleaseDHCP()  
        wiface.StopWPA()  
        print 'Putting wireless interface down'  
        wiface.Down()  
        print 'Setting mode, channel, and essid'  
        wiface.SetMode('ad-hoc')  
        wiface.SetChannel(channel)  
        wiface.SetEssid(essid)  
        # Right now it just assumes you're using WEP  
        if enc_used:  
            print 'Setting encryption key'  
            wiface.SetKey(key) # HERE IS THE SOURCE  
        print 'Putting interface up'  
        wiface.Up()  
        print 'Setting IP address'  
        wiface.SetAddress(ip, '255.255.255.0')  
  
  
# https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/wicd-daemon.py#L961-L999  
  
    @dbus.service.method('org.wicd.daemon.wireless')  
    def Scan(self, sync=False):  
        """ Scan for wireless networks.  
        Scans for wireless networks, optionally using a (hidden) essid  
        set with SetHiddenNetworkESSID.  
        The sync keyword argument specifies whether the scan should  
        be done synchronously.  
        """  
        if self._scanning:  
            if self.debug_mode:  
                print "scan already in progress, skipping"  
            return False  
        if self.debug_mode:  
            print 'scanning start'  
        self.SendStartScanSignal()  
        if sync:  
            self._sync_scan()  
        else:  
            self._async_scan()  
        return True  
  
    @misc.threaded  
    def _async_scan(self):  
        """ Run a scan in its own thread. """  
        self._sync_scan()  
  
    def _sync_scan(self):  
        """ Run a scan and send a signal when its finished. """  
        scan = self.wifi.Scan(str(self.hidden_essid)) # HERE IS THE FLOW  
        self.LastScan = scan  
        if self.debug_mode:  
            print 'scanning done'  
            print 'found ' + str(len(scan)) + ' networks:'  
        for i, network in enumerate(scan):  
            self.ReadWirelessNetworkProfile(i) # HERE IS THE FLOW  
        self.SendEndScanSignal()  
  
# https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/wicd-daemon.py#L1194-L1222  
  
    @dbus.service.method('org.wicd.daemon.wireless')  
    def ReadWirelessNetworkProfile(self, id):  
        """ Reads in wireless profile as the active network """  
        cur_network = self.LastScan[id]  
        essid_key = "essid:%s" % cur_network["essid"]  
        bssid_key = cur_network["bssid"]  
  
        if self.config.get(essid_key, 'use_settings_globally'):  
            section = essid_key  
        elif self.config.has_section(bssid_key):  
            section = bssid_key  
        else:  
            return "500: Profile Not Found"  
  
        for x in self.config.options(section):  
            if not cur_network.has_key(x) or x.endswith("script"):  
                cur_network[x] = misc.Noneify(self.config.get(section, x)) # HERE IS THE FLOW  
        for option in ['use_static_dns', 'use_global_dns', 'encryption',  
                       'use_settings_globally']:  
            cur_network[option] = bool(cur_network.get(option))  
        # Read the essid because we need to name those hidden  
        # wireless networks now - but only read it if it is hidden.  
        if cur_network["hidden"]:  
            # check if there is an essid in the config file  
            # if there isn't, .get( will return None  
            stored_essid = self.config.get(section, 'essid')  
            if stored_essid:  
                # set the current network's ESSID to the stored one  
                cur_network['essid'] = stored_essid  
  
# https://github.com/zeph/wicd/blob/69e9e92def36eeaf6df948203212bff547466a36/wicd/configmanager.py#L48-L149  
  
class ConfigManager(RawConfigParser):  
    """ A class that can be used to manage a given configuration file. """  
    def __init__(self, path, debug=False, mark_whitespace="`'`"):  
        RawConfigParser.__init__(self)  
        self.config_file = path  
        self.debug = debug  
        self.mrk_ws = mark_whitespace  
        if os.path.exists(path):  
            sanitize_config_file(path)  
        try:  
            self.read(path)  
        except ParsingError, e:  
            self.write()  
            try:  
                self.read(path)  
            except ParsingError, p:  
                print "Could not start wicd: %s" % p.message  
                sys.exit(1)  
  
    def __repr__(self):  
        return self.config_file  
      
    def __str__(self):  
        return self.config_file  
      
    def get_config(self):  
        """ Returns the path to the loaded config file. """  
        return self.config_file  
          
    def set_option(self, section, option, value, write=False):  
        """ Wrapper around ConfigParser.set  
        Adds the option to write the config file change right away.  
        Also forces all the values being written to type str, and  
        adds the section the option should be written to if it  
        doesn't exist already.  
          
        """  
        if not self.has_section(section):  
            self.add_section(section)  
        if isinstance(value, basestring):  
            value = to_unicode(value)  
            if value.startswith(' ') or value.endswith(' '):  
                value = "%(ws)s%(value)s%(ws)s" % {"value" : value,  
                                                   "ws" : self.mrk_ws}  
        RawConfigParser.set(self, section, str(option), value)  
        if write:  
            self.write()  
  
    def set(self, *args, **kargs):  
        """ Calls the set_option method. """  
        self.set_option(*args, **kargs)  
          
    def get_option(self, section, option, default="__None__"):  
        """ Wrapper around ConfigParser.get.   
          
        Automatically adds any missing sections, adds the ability  
        to write a default value, and if one is provided prints if  
        the default or a previously saved value is returned.  
          
        """  
        if not self.has_section(section):  
            if default != "__None__":  
                self.add_section(section)  
            else:  
                return None  
      
        if self.has_option(section, option):  
            ret = RawConfigParser.get(self, section, option)  
            if (isinstance(ret, basestring) and ret.startswith(self.mrk_ws)   
                and ret.endswith(self.mrk_ws)):  
                ret = ret[3:-3]  
            ret = to_unicode(ret)  
            if default:  
                if self.debug:  
                    print ''.join(['found ', option, ' in configuration ',   
                                   str(ret)]) # HERE IS THE SINK 1  
        else:  
            if default != "__None__":  
                print 'did not find %s in configuration, setting default %s' % (option, str(default))  
                self.set(section, option, str(default), write=True)  
                ret = default  
            else:  
                ret = None  
          
        # Try to intelligently handle the type of the return value.  
        try:  
            if not ret.startswith('0') or len(ret) == 1:  
                ret = int(ret)  
        except (ValueError, TypeError, AttributeError):  
            ret = Noneify(ret)  
        # This is a workaround for a python-dbus issue on 64-bit systems.  
        if isinstance(ret, (int, long)):  
            try:  
                Int32(ret)  
            except OverflowError:  
                ret = str(ret)  
        return to_unicode(ret)  
      
    def get(self, *args, **kargs):  
        """ Calls the get_option method """  
        return self.get_option(*args, **kargs)  
  
  
  
  
```  
