## Summary:  
Software: docker  
## Fix:  
Commit: https://github.com/dweomer/docker/pull/82/commits/73db8c77bfb2d0cbdf71ce491f3d3e66c9dd5be6  
Author: Sebastiaan van Stijn  
Fix Time (of the Last Commit): 2019-07-10  
Fix Pattern: Sanitization -> Redaction -> Enhancement (Adaptive Change) -> Keyword/RegexBasedFiltration -> RedactionFunctionDefined  
  
  
Fixing-commits Count: 4  
Total Change Size: +52 -40  
  

========  
Commit: https://github.com/dweomer/docker/pull/82/commits/18dac2cf32faeaada3bd4e8e2bffa576ad4329fe  
Time: 2019-07-10  
Commit: https://github.com/dweomer/docker/pull/82/commits/ebb542b3f88d7f5551f6b6e1d8d2774a2c166409  
Time: 2019-07-10  
Commit: https://github.com/dweomer/docker/pull/82/commits/73db8c77bfb2d0cbdf71ce491f3d3e66c9dd5be6  
Time: 2019-07-10  
Commit: https://github.com/dweomer/docker/pull/82/commits/f8a0f26843bc5aff33cf9201b75bd4bdbb48a3ad  
Time: 2019-07-10  
## Sample logs: Yes  
```  
DEBU[2019-07-01T22:37:35.828819400Z] Calling POST /v1.30/secrets/w3hgvwpzl8yooq5ctnyp71v52/update?version=34  
DEBU[2019-07-01T22:37:35.829993700Z] form data: {"Data":"c2VjcmV0Cg==","Labels":{"com.docker.stack.namespace":"test"},"Name":"test_my_secret"}  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> secrets  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（logrus）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/moby/moby/blob/7b9275c0da707b030e62c96b679a976f31f929d3/api/types/swarm/secret.go#L15）-> Type Names（SecretSpec）  
Programming Language:Go  
```go  
// https://github.com/moby/moby/blob/73db8c77bfb2d0cbdf71ce491f3d3e66c9dd5be6/api/server/middleware/debug.go  
  
// DebugRequestMiddleware dumps the request to logger  
func DebugRequestMiddleware(handler func(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error) func(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error {  
	return func(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error {  
		logrus.Debugf("Calling %s %s", r.Method, r.RequestURI)  
  
		if r.Method != "POST" {  
			return handler(ctx, w, r, vars)  
		}  
		if err := httputils.CheckForJSON(r); err != nil {  
			return handler(ctx, w, r, vars)  
		}  
		maxBodySize := 4096 // 4KB  
		if r.ContentLength > int64(maxBodySize) {  
			return handler(ctx, w, r, vars)  
		}  
  
		body := r.Body  
		bufReader := bufio.NewReaderSize(body, maxBodySize)  
		r.Body = ioutils.NewReadCloserWrapper(bufReader, func() error { return body.Close() })  
  
		b, err := bufReader.Peek(maxBodySize)  
		if err != io.EOF {  
			// either there was an error reading, or the buffer is full (in which case the request is too large)  
			return handler(ctx, w, r, vars)  
		}  
  
		var postForm map[string]interface{}  
		if err := json.Unmarshal(b, &postForm); err == nil {  
			maskSecretKeys(postForm, r.RequestURI)  
			formStr, errMarshal := json.Marshal(postForm)  
			if errMarshal == nil {  
				logrus.Debugf("form data: %s", string(formStr))  
			} else {  
				logrus.Debugf("form data: %q", postForm) // HERE IS THE SINK 1  
			}  
		}  
  
		return handler(ctx, w, r, vars)  
	}  
}  
```  
