## Summary:  
Software: ansible  
## Fix:  
Commit: https://github.com/ansible/ansible/pull/67866/commits/0ff609f1bc5e391fa25710b9a0baaf669f347eb1  
Author: Toshio Kuratomi  
Fix Time (of the Last Commit): 2020-03-03  
Fix Pattern: Remove -> Entire Function  
  
  
Fixing-commits Count: 2  
Total Change Size: +103 -26  
  
 
========  
PR: https://github.com/ansible/ansible/pull/67866  
  
Commit: https://github.com/ansible/ansible/pull/67866/commits/0ff609f1bc5e391fa25710b9a0baaf669f347eb1  
Commit: https://github.com/ansible/ansible/pull/67866/commits/2f2611e16cdc867db716efd7d9b6164d41b75a2c  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> the LDAP bind password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（AnsibleModule._return_formatted）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/abadger/ansible/blob/c1e51ef486cec17b69727b47452a34a7796d5677/lib/ansible/modules/net_tools/ldap/ldap_entry.py#L101）-> Comments  
Programming Language:Python  
```Python  
  
# https://github.com/abadger/ansible/blob/c1e51ef486cec17b69727b47452a34a7796d5677/lib/ansible/modules/net_tools/ldap/ldap_entry.py#L192-L247  
  
def main():  
    module = AnsibleModule(  
        argument_spec=gen_specs(  
            attributes=dict(default={}, type='dict'),  
            objectClass=dict(type='raw'),  
            params=dict(type='dict'),  
            state=dict(default='present', choices=['present', 'absent']),  
        ),  
        supports_check_mode=True,  
    )  
  
    if not HAS_LDAP:  
        module.fail_json(msg=missing_required_lib('python-ldap'),  
                         exception=LDAP_IMP_ERR)  
  
    state = module.params['state']  
  
    # Check if objectClass is present when needed  
    if state == 'present' and module.params['objectClass'] is None:  
        module.fail_json(msg="At least one objectClass must be provided.")  
  
    # Check if objectClass is of the correct type  
    if (  
            module.params['objectClass'] is not None and not (  
                isinstance(module.params['objectClass'], string_types) or  
                isinstance(module.params['objectClass'], list))):  
        module.fail_json(msg="objectClass must be either a string or a list.")  
  
    # Update module parameters with user's parameters if defined  
    if 'params' in module.params and isinstance(module.params['params'], dict):  
        for key, val in module.params['params'].items():  
            if key in module.argument_spec:  
                module.params[key] = val  
            else:  
                module.params['attributes'][key] = val  
  
        # Remove the params  
        module.params.pop('params', None)  
  
    # Instantiate the LdapEntry object  
    ldap = LdapEntry(module)  
  
    # Get the action function  
    if state == 'present':  
        action = ldap.add()  
    elif state == 'absent':  
        action = ldap.delete()  
  
    # Perform the action  
    if action is not None and not module.check_mode:  
        try:  
            action()  
        except Exception as e:  
            module.fail_json(msg="Entry action failed.", details=to_native(e), exception=traceback.format_exc())  
  
    module.exit_json(changed=(action is not None)) # HERE IS THE FLOW  
  
  
# https://github.com/ansible/ansible/blob/b6811dfb61bee06dad08e90ef541667be7bbc950/lib/ansible/module_utils/basic.py#L1898  
      
    def exit_json(self, **kwargs):  
        ''' return from the module, without error '''  
  
        self.do_cleanup_files()  
        self._return_formatted(kwargs) # HERE IS THE SINK 1  
        sys.exit(0)  
  
  
# https://github.com/ansible/ansible/blob/b6811dfb61bee06dad08e90ef541667be7bbc950/lib/ansible/module_utils/basic.py#L1856-L1892  
  
    def _return_formatted(self, kwargs):  
  
        self.add_path_info(kwargs)  
  
        if 'invocation' not in kwargs:  
            kwargs['invocation'] = {'module_args': self.params}  
  
        if 'warnings' in kwargs:  
            if isinstance(kwargs['warnings'], list):  
                for w in kwargs['warnings']:  
                    self.warn(w)  
            else:  
                self.warn(kwargs['warnings'])  
  
        warnings = get_warning_messages()  
        if warnings:  
            kwargs['warnings'] = warnings  
  
        if 'deprecations' in kwargs:  
            if isinstance(kwargs['deprecations'], list):  
                for d in kwargs['deprecations']:  
                    if isinstance(d, SEQUENCETYPE) and len(d) == 2:  
                        self.deprecate(d[0], version=d[1])  
                    elif isinstance(d, Mapping):  
                        self.deprecate(d['msg'], version=d.get('version'), date=d.get('date'),  
                                       collection_name=d.get('collection_name'))  
                    else:  
                        self.deprecate(d)  # pylint: disable=ansible-deprecated-no-version  
            else:  
                self.deprecate(kwargs['deprecations'])  # pylint: disable=ansible-deprecated-no-version  
  
        deprecations = get_deprecation_messages()  
        if deprecations:  
            kwargs['deprecations'] = deprecations  
  
        kwargs = remove_values(kwargs, self.no_log_values)  
        print('\n%s' % self.jsonify(kwargs)) # HERE IS THE INNER SINK  
  
```  
