## Summary:  
Software: keycloak  
## Fix:  
Commit: https://github.com/keycloak/keycloak/commit/62c9e1577618470832ede22dcedd46cba15b1836  
Change Size: +1 -1  
Author: Michal Hajas  
Fix Time (of the Last Commit): 2020-02-10  
Fix Pattern: Remove -> Logging Variables  
  
Fixing-commits Count: 1  
Total Change Size: +1 -1  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> the password given as parameter  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（JBoss Logging）  
Sensitiveness-Identifiable Source:  跨方法（https://github.com/keycloak/keycloak/blob/66dfa32cd569a7416de21b4dc04db212e8fccce5/core/src/main/java/org/keycloak/representations/idm/authorization/AuthorizationRequest.java#L44） -> Type Names(AccessToken)  
Programming Language:Java  
```Java  
  
// https://github.com/keycloak/keycloak/blob/66dfa32cd569a7416de21b4dc04db212e8fccce5/adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/KeycloakAdapterPolicyEnforcer.java#L137-L182  
  
    private AccessToken requestAuthorizationToken(PathConfig pathConfig, PolicyEnforcerConfig.MethodConfig methodConfig, OIDCHttpFacade httpFacade, Map<String, List<String>> claims) {  
        if (getEnforcerConfig().getUserManagedAccess() != null) {  
            return null;  
        }  
  
        try {  
            KeycloakSecurityContext securityContext = httpFacade.getSecurityContext();  
            String accessTokenString = securityContext.getTokenString();  
            KeycloakDeployment deployment = getPolicyEnforcer().getDeployment();  
            AccessToken accessToken = securityContext.getToken();  
            AuthorizationRequest authzRequest = new AuthorizationRequest();  
  
            if (isBearerAuthorization(httpFacade) || accessToken.getAuthorization() != null) {  
                authzRequest.addPermission(pathConfig.getId(), methodConfig.getScopes());  
            }  
  
            if (!claims.isEmpty()) {  
                authzRequest.setClaimTokenFormat("urn:ietf:params:oauth:token-type:jwt");  
                authzRequest.setClaimToken(Base64.encodeBytes(JsonSerialization.writeValueAsBytes(claims)));  
            }  
  
            if (accessToken.getAuthorization() != null) {  
                authzRequest.setRpt(accessTokenString);  
            }  
  
            LOGGER.debug("Obtaining authorization for authenticated user.");  
            AuthorizationResponse authzResponse;  
  
            if (isBearerAuthorization(httpFacade)) {  
                authzRequest.setSubjectToken(accessTokenString);  
                authzResponse = getAuthzClient().authorization().authorize(authzRequest);  // HERE IS THE FLOW  
            } else {  
                authzResponse = getAuthzClient().authorization(accessTokenString).authorize(authzRequest);  // HERE IS THE FLOW  
            }  
  
            if (authzResponse != null) {  
                return AdapterTokenVerifier.verifyToken(authzResponse.getToken(), deployment);  
            }  
        } catch (AuthorizationDeniedException ignore) {  
            LOGGER.debug("Authorization denied", ignore); // HERE IS THE SINK 1  
        } catch (Exception e) {  
            LOGGER.debug("Authorization failed", e);  
        }  
  
        return null;  
    }  
  
// https://github.com/keycloak/keycloak/blob/e5935d8069154db2bc9ee83ae85c7e1ff6822324/authz/client/src/main/java/org/keycloak/authorization/client/AuthzClient.java#L148-L175  
  
    /**  
     * <p>Creates a {@link AuthorizationResource} instance which can be used to obtain permissions from the server.  
     *  
     * @return a {@link AuthorizationResource}  
     */  
    public AuthorizationResource authorization() {  
        return new AuthorizationResource(configuration, serverConfiguration, this.http, null);  
    }  
  
    /**  
     * <p>Creates a {@link AuthorizationResource} instance which can be used to obtain permissions from the server.  
     *  
     * @param accessToken the Access Token that will be used as a bearer to access the token endpoint  
     * @return a {@link AuthorizationResource}  
     */  
    public AuthorizationResource authorization(final String accessToken) {  
        return new AuthorizationResource(configuration, serverConfiguration, this.http, new TokenCallable(http, configuration, serverConfiguration) {  
            @Override  
            public String call() {  
                return accessToken;  
            }  
  
            @Override  
            protected boolean isRetry() {  
                return false;  
            }  
        });  
    }  
  
  
// https://github.com/keycloak/keycloak/blob/66dfa32cd569a7416de21b4dc04db212e8fccce5/authz/client/src/main/java/org/keycloak/authorization/client/resource/AuthorizationResource.java#L52-L100  
  
    /**  
     * Query the server for all permissions.  
     *  
     * @return an {@link AuthorizationResponse} with a RPT holding all granted permissions  
     * @throws AuthorizationDeniedException in case the request was denied by the server  
     */  
    public AuthorizationResponse authorize() throws AuthorizationDeniedException {  
        return authorize(new AuthorizationRequest());  
    }  
  
    /**  
     * Query the server for permissions given an {@link AuthorizationRequest}.  
     *  
     * @param request an {@link AuthorizationRequest} (not {@code null})  
     * @return an {@link AuthorizationResponse} with a RPT holding all granted permissions  
     * @throws AuthorizationDeniedException in case the request was denied by the server  
     */  
    public AuthorizationResponse authorize(final AuthorizationRequest request) throws AuthorizationDeniedException {  
        if (request == null) {  
            throw new IllegalArgumentException("Authorization request must not be null");  
        }  
  
        Callable<AuthorizationResponse> callable = new Callable<AuthorizationResponse>() {  
            @Override  
            public AuthorizationResponse call() throws Exception {  
                if (request.getAudience() == null) {  
                    request.setAudience(configuration.getResource());  
                }  
  
                HttpMethod<AuthorizationResponse> method = http.<AuthorizationResponse>post(serverConfiguration.getTokenEndpoint());  
  
                if (token != null) {  
                    method = method.authorizationBearer(token.call());  
                }  
  
                return method  
                        .authentication()  
                        .uma(request)  
                        .response()  
                        .json(AuthorizationResponse.class)  
                        .execute(); // HERE IS THE FLOW  
            }  
        };  
        try {  
            return callable.call();  
        } catch (Exception cause) {  
            return Throwables.retryAndWrapExceptionIfNecessary(callable, token, "Failed to obtain authorization data", cause); // HERE IS THE FLOW  
        }  
    }  
  
// https://github.com/keycloak/keycloak/blob/66dfa32cd569a7416de21b4dc04db212e8fccce5/authz/client/src/main/java/org/keycloak/authorization/client/util/Throwables.java#L94-L100  
    private static RuntimeException handleAndWrapHttpResponseException(HttpResponseException exception) {  
        if (403 == exception.getStatusCode()) {  
            throw new AuthorizationDeniedException(exception);  
        }  
  
        return new RuntimeException(exception);  
    }  
  
// https://github.com/keycloak/keycloak/blob/e5935d8069154db2bc9ee83ae85c7e1ff6822324/authz/client/src/main/java/org/keycloak/authorization/client/util/HttpMethod.java#L74-L108  
  
    public R execute(HttpResponseProcessor<R> responseProcessor) {  
        byte[] bytes = null;  
  
        try {  
            for (Map.Entry<String, String> header : this.headers.entrySet()) {  
                this.builder.setHeader(header.getKey(), header.getValue());  
            }  
  
            preExecute(this.builder);  
  
            HttpResponse response = this.httpClient.execute(this.builder.build());  
            HttpEntity entity = response.getEntity();  
  
            if (entity != null) {  
                bytes = EntityUtils.toByteArray(entity);  
            }  
  
            StatusLine statusLine = response.getStatusLine();  
            int statusCode = statusLine.getStatusCode();  
  
            if (statusCode < 200 || statusCode >= 300) {  
                throw new HttpResponseException("Unexpected response from server: " + statusCode + " / " + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);  
            }  
  
            if (bytes == null) {  
                return null;  
            }  
  
            return responseProcessor.process(bytes);  
        } catch (HttpResponseException e) {  
            throw e;  
        } catch (Exception e) {  
            throw new RuntimeException("Error executing http method [" + builder + "]. Response : " + String.valueOf(bytes), e); // HERE IS THE FLOW  
        }  
    }  
  
```  
