## Summary:  
Software: auth0  
## Fix:  
Commit: https://github.com/auth0/node-auth0/commit/62ca61b3348ec8e74d7d00358661af1a8bc98a3c  
Author: Jim Anderson  
Fix Time (of the Last Commit): 2020-07-21  
Fix Pattern: Sanitization -> Redaction -> Reuse -> Tag/TypeBasedFiltration  
  
  
Fixing-commits Count: 1  
Total Change Size: +60 -7  
  
========  
PR: https://github.com/auth0/node-auth0/pull/507  
Commit: https://github.com/auth0/node-auth0/commit/62ca61b3348ec8e74d7d00358661af1a8bc98a3c  
Change Size: +60 -7  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> bearer token  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Exception may containing sensitive information  
Sensitiveness-Identifiable Source: No  
Programming Language:JS  
```JavaScript  
// https://github.com/auth0/node-auth0/blob/62ca61b3348ec8e74d7d00358661af1a8bc98a3c/src/errors.js#L8-L60  
  
/**  
 * Given a response request error, sanitize sensitive data.  
 *  
 * @method    sanitizeErrorRequestData  
 * @memberOf  module:errors  
 */  
errors.sanitizeErrorRequestData = function(error) {  
  if (  
    !error.response ||  
    !error.response.request ||  
    (!error.response.request._data && !error.response.request._header)  
  ) {  
    return error;  
  }  
  
  sanitizeErrors(error.response.request._header);  
  sanitizeErrors(error.response.request._data);  
  
  return error;  
};  
  
var sanitizeErrors = function(collection) {  
  if (!collection) {  
    return;  
  }  
  
  Object.keys(collection).forEach(function(key) {  
    if (key.toLowerCase().match('password|secret|authorization')) {  
      collection[key] = '[SANITIZED]';  
    }  
  });  
};  
  
/**  
 * Given an Api Error, modify the original error and sanitize  
 * sensitive information using sanitizeErrorRequestData  
 *  
 * @method    SanitizedError  
 * @memberOf  module:errors  
 */  
var SanitizedError = function(name, message, status, requestInfo, originalError) {  
  this.name = name || this.constructor.name || this.constructor.prototype.name || '';  
  this.message = message || '';  
  this.statusCode = status || (originalError && originalError.code);  
  this.requestInfo = Object.assign({}, requestInfo);  
  this.originalError = errors.sanitizeErrorRequestData(originalError);  
  
  Error.captureStackTrace(this, this.constructor);  
};  
  
util.inherits(SanitizedError, Error);  
  
errors.SanitizedError = SanitizedError;  
  
  
// https://github.com/auth0/node-auth0/blob/2d67e9572f4967f41b9129d2f5a02732eac6b3fd/src/Auth0RestClient.js#L20-L25  
  options.errorCustomizer = options.errorCustomizer || SanitizedError; // HERE IS THE FLOW  
  options.errorFormatter = options.errorFormatter || { message: 'message', name: 'error' };  
  
  this.options = options;  
  this.provider = provider;  
  this.restClient = new RestClient(resourceUrl, options); // HERE IS THE FLOW  
  
// https://github.com/ngonzalvez/rest-facade/blob/f5bddd52d843d8e048d0a6d016c5abd5ca5a780a/src/Client.js#L258-L414  
/**  
 * Perform a request of the given method, to the given URL.  
 *  
 * @method  
 * @param   {Object}    options             Request options object.  
 * @param   {String}    options.url         The URL to be requested.  
 * @param   {String}    options.method      The type of request to be done.  
 * @param   {Function}  [callback]  Callback function.  
 * @return  {Promise}               Resolves to response body.  
 */  
Client.prototype.request = function (options, params, callback) {  
  var headers = this.options.headers || {};  
  var errorFormatter = this.options.errorFormatter || {};  
  var errorConstructor = this.options.errorCustomizer || APIError;  
  var paramsCase = this.options.query.convertCase;  
  var bodyCase = this.options.request.body.convertCase;  
  var responseCase = this.options.response.body.convertCase;  
  var queryParams = {};  
  var convertCaseParams = paramsCase ? changeCase[paramsCase] : null;  
  var convertCaseBody = bodyCase ? changeCase[bodyCase] : null;  
  var convertCaseRes = responseCase ? changeCase[responseCase] : null;  
  var reqCustomizer = this.options.request.customizer;  
  var proxy = this.options.proxy;  
  var newKey = null;  
  var value = null;  
  
  for (var prevKey in params) {  
    value = params[prevKey];  
  
    if (isFunction(value)) {  
      continue;  
    }  
  
    // If the user specified a convertion case (e.g. 'snakeCase') convert the  
    // query string params names to the given case.  
    newKey = convertCaseParams ? convertCaseParams(prevKey) : prevKey;  
  
  
    // If the repeatParams flag is set to false, encode arrays in  
    // the querystring as comma separated values.  
    // e.g. ?a=1,2,3  
    if (Array.isArray(value) && !this.options.query.repeatParams) {  
      value = value.join(',');  
    }  
  
    queryParams[newKey] = value;  
  }  
  
  if (convertCaseBody) {  
    for (var key in options.data) {  
      if (options.data.hasOwnProperty(key)) {  
        options.data[convertCaseBody(key)] = options.data[key];  
        delete options.data[key];  
      }  
    }  
  }  
  
  var promise = new Promise(function (resolve, reject) {  
    var method = options.method.toLowerCase();  
  
    // Set methods and attach the body of the request (if this is a POST request).  
    var req = request[method](options.url);  
  
    if (proxy) {  
      req = req.proxy(proxy);  
    }  
  
    req = req.send(options.data);  
  
    // Add request headers.  
    for (var header in headers) {  
      req = req.set(header, headers[header]);  
    }  
  
    // Add all the given parameters to the querystring.  
    req = req.query(queryParams);  
  
    // Run request customizer (from constructor options)  
    if (isFunction(reqCustomizer)) {  
      if (reqCustomizer.length === 3) { // check if callback has been defined  
        reqCustomizer(req, params, runParamsRequestCustomizer);  
      } else {  
        // if no callback (run synchronously)  
        reqCustomizer(req, params);  
        runParamsRequestCustomizer();  
      }  
    } else {  
      runParamsRequestCustomizer();  
    }  
  
    // Run request customizer (from request params)  
    function runParamsRequestCustomizer(err) {  
      if (err) {  
        return reject(err);  
      }  
  
      if (isFunction(params._requestCustomizer)) {  
        if (params._requestCustomizer.length === 3) { // check if callback has been defined  
          params._requestCustomizer(req, params, sendRequest);  
        } else {  
          // if no callback (run synchronously)  
          params._requestCustomizer(req, params);  
          sendRequest();  
        }  
      } else {  
        sendRequest();  
      }  
    }  
  
    // send the request  
    function sendRequest(err) {  
      if (err) {  
        return reject(err);  
      }  
  
      // Send the request.  
      req  
        .set('Accept', 'application/json')  
        .end(function (err, res) {  
          if (err) {  
            var reqinfo = { method : method, url : options.url };  
            var response = err.response || {};  
            var data = response.body;  
            var status = err.status;  
            var error;  
    
            var name = resolveAPIErrorArg(errorFormatter.name, data, 'APIError');  
            var message = resolveAPIErrorArg(errorFormatter.message, data, [data, err.message]);  
    
            return reject(new errorConstructor(name, message, status, reqinfo, err)); // HERE IS THE SINK  
          }  
  
          // If case conversion is enabled for the body of the response, convert  
          // the properties of the body to the specified case.  
          if (convertCaseRes) {  
            for (var key in res.body) {  
              if (res.body.hasOwnProperty(key)) {  
                res.body[convertCaseRes(key)] = res.body[key];  
  
                if (key !== convertCaseRes(key)) {  
                  delete res.body[key];  
                }  
              }  
            }  
          }  
  
          resolve(res.body, res.header);  
        });  
      }  
    });  
  
  if (!callback) return promise;  
  
  promise  
    .then(callback.bind(null, null))  
    .catch(callback);  
};  
  
```  
