## Summary:  
Software: wimax_network_service  
## Fix:  
Fix Time (of the Last Commit): Unfixed  
Fix Pattern: Unfixed  
  
Fixing-commits Count: 0  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（OSALTRACE）  
Sensitiveness-Identifiable Source:  Logging Statements -> Variable Names（password）|String Literals（pwd，finally outputed to logs）  
Programming Language:C/C++  
```C++  
// https://github.com/ago/wimax-ns/blob/6718941c330928490b69461eb2c13b94bea34be4/InfraStack/OSDependent/Linux/OSAL/Services/wimax_osal_crypt_services.c#L661-L722  
  
/// <summary>  
/// Sets the encrypted password into the right possition in the NSP  
/// and generate new file (its name is going to be saved as the password name) that contain the encrypted password  
/// </summary>  
BOOL OSAL_Crypt_SetEncryptedPassword(char *password, char *passwordToEncrypt)  
{  
	int done=FALSE, encryptedFileNumber;  
	CHAR encryptedFileName[OSAL_DEFUALT_STR_LEN];  
	FILE *file = NULL;  
	CHAR path[OSAL_DEFUALT_STR_LEN];  
	static unsigned addToSead=0;  
  
	OSALTRACE(OSAL_ERROR, ("Enter with - existing pwd file: %s, pwd to encrypt: %s", password, (char *)passwordToEncrypt)); // HERE IS THE SINK 1  
  
	//delete the file of the old password (if exist)and then continue to Add new one  
	OSAL_BuildFullPath(password, path, OSAL_DEFUALT_STR_LEN);  
	remove(path);  
  
	//create random file name to save the password in  
	do{  
		srand( addToSead + (unsigned)time( NULL ) );  
		addToSead++;  
		encryptedFileNumber = rand();  
		if(encryptedFileNumber)  
		{  
			OSAL_itoa_s(encryptedFileNumber, encryptedFileName, OSAL_DEFUALT_STR_LEN, 10);  
			OSAL_BuildFullPath(encryptedFileName, path, OSAL_DEFUALT_STR_LEN);  
  
			if( ( file = fopen( path, "r" )) == NULL )  
			{  
				done = TRUE;  
			}  
			else   
			{  
				//the file exist and was open - need to close it   
				fclose(file);  
			}  
		}  
	}while(!done);  
  
	OSALTRACE(OSAL_ERROR, ("New password file: %s", encryptedFileName));  
  
	if( ( file = fopen( path, "w" )) == NULL )  
	{  
		TRACE(TR_MOD_NDNS_AGENT, TR_SEV_ERR,"Crypt_SetEncryptedPassword: unable to open new file for the encrypted password");  
		memset(passwordToEncrypt, strnlen(passwordToEncrypt, OSAL_DEFUALT_STR_LEN), 0);  
		return FALSE;  
	}  
	TRACE(TR_MOD_NDNS_AGENT, TR_SEV_INFO,"The file holding the encrypted password is %s\n",encryptedFileName);  
  
	// NOTE: On Linux we dont encrypt the password   
  
	fwrite(passwordToEncrypt, 1, strlen(passwordToEncrypt)+1, file) ;  
	fclose(file);  
  
  
	OSAL_strcpy_s(password ,OSAL_DEFUALT_STR_LEN,encryptedFileName);  
  
	OSALTRACE(OSAL_ERROR, ("Returning success"));  
  
	return TRUE;  
}  
  
  
  
// https://github.com/ago/wimax-ns/blob/6718941c330928490b69461eb2c13b94bea34be4/InfraStack/OSAgnostic/WiMax/Agents/NDnS/L4_db/NDnSAgent_DB_Restore.c#L1238-L1380  
  
///<summary>  
/// restores an EAP node from a file  
///</summary>  
wmx_Status_t l4db_RestoreEapParamsFromFile(pXmlElement pXml, pEAP_t pEap)  
{  
	pXmlElement		xmlNextData, xmlEnumerationData, xmlCertData;  
	pXmlElement		xmlSrvRealmData;  
  
// OMIT FOR SIMPLICITY  
  
		//password  
		else if(FALSE == l4db_CompareString(str,L4DB_XML_TOKEN_PASSWORD))  
		{  
			if('\0' != xmlNextData->data.value[0])  
			{  
				//add only if the password is filled  
				strValue = FindAttribute(xmlNextData, L4DB_XML_TOKEN_IS_ENCRYPTED_PASSWORD);  
				if(FALSE == l4db_CompareString(strValue, L4DB_XML_TRUE_STR))  
				{  
					//the password is already encrypted  
					err = OSAL_strncpy_s(pEap->Password, MAX_EAP_PASSWORD_SIZE, (char *)GetElementInnerText(xmlNextData), MAX_STR_LEN - 1);  
					if(err)  
					{  
						return WMX_ST_FAIL;  
					}  
				}  
				else  
				{  
					OSAL_Crypt_SetEncryptedPassword(pEap->Password, xmlNextData->data.value);  
				}  
  
```  
