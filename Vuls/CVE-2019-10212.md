## Summary:  
Software: undertow  
## Fix:  
Commit: https://github.com/Paramvir-JIndal/undertow/commit/8b63e258502f9f55b33b2e0b02a2e24cf5d2f1c1  
Author: Paramvir Jindal  
Fix Time (of the Last Commit): 2019-10-11  
  
Fix Pattern: Remove -> Logging Variables  
  
Fixing-commits Count: 1  
Total Change Size: +2 -2  
  
========  
PR: https://github.com/undertow-io/undertow/pull/817  
Commit: https://github.com/Paramvir-JIndal/undertow/commit/8b63e258502f9f55b33b2e0b02a2e24cf5d2f1c1  
Change Size: +2 -2  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> user's credentials  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（JBoss Logging）  
Sensitiveness-Identifiable Source:  Logging Statements -> String Literals（auth header，finally outputed to logs）  
#### Sink 2:  
Logging call Function:  Third-party Libaries（JBoss Logging）  
Sensitiveness-Identifiable Source:  Logging Statements -> String Literals（auth header，finally outputed to logs）  
Programming Language:Java  
```Java  
  
// https://github.com/Paramvir-JIndal/undertow/blob/7a5900ff4ce702ce1451f6440eb56c3eb6a36d24/core/src/main/java/io/undertow/security/impl/BasicAuthenticationMechanism.java#L128-L190  
  
    public AuthenticationMechanismOutcome authenticate(HttpServerExchange exchange, SecurityContext securityContext) {  
  
        List<String> authHeaders = exchange.getRequestHeaders().get(AUTHORIZATION);  
        if (authHeaders != null) {  
            for (String current : authHeaders) {  
                if (current.toLowerCase(Locale.ENGLISH).startsWith(LOWERCASE_BASIC_PREFIX)) {  
  
                    String base64Challenge = current.substring(PREFIX_LENGTH);  
                    String plainChallenge = null;  
                    try {  
                        ByteBuffer decode = FlexBase64.decode(base64Challenge);  
  
                        Charset charset = this.charset;  
                        if(!userAgentCharsets.isEmpty()) {  
                            String ua = exchange.getRequestHeaders().getFirst(Headers.USER_AGENT);  
                            if(ua != null) {  
                                for (Map.Entry<Pattern, Charset> entry : userAgentCharsets.entrySet()) {  
                                    if(entry.getKey().matcher(ua).find()) {  
                                        charset = entry.getValue();  
                                        break;  
                                    }  
                                }  
                            }  
                        }  
  
                        plainChallenge = new String(decode.array(), decode.arrayOffset(), decode.limit(), charset);  
                        UndertowLogger.SECURITY_LOGGER.debugf("Found basic auth header %s (decoded using charset %s) in %s", plainChallenge, charset, exchange); // HERE IS THE SINK 1  
                    } catch (IOException e) {  
                        UndertowLogger.SECURITY_LOGGER.debugf(e, "Failed to decode basic auth header %s in %s", base64Challenge, exchange); // HERE IS THE SINK 2  
                    }  
                    int colonPos;  
                    if (plainChallenge != null && (colonPos = plainChallenge.indexOf(COLON)) > -1) {  
                        String userName = plainChallenge.substring(0, colonPos);  
                        char[] password = plainChallenge.substring(colonPos + 1).toCharArray();  
  
                        IdentityManager idm = getIdentityManager(securityContext);  
                        PasswordCredential credential = new PasswordCredential(password);  
                        try {  
                            final AuthenticationMechanismOutcome result;  
                            Account account = idm.verify(userName, credential);  
                            if (account != null) {  
                                securityContext.authenticationComplete(account, name, false);  
                                result = AuthenticationMechanismOutcome.AUTHENTICATED;  
                            } else {  
                                securityContext.authenticationFailed(MESSAGES.authenticationFailed(userName), name);  
                                result = AuthenticationMechanismOutcome.NOT_AUTHENTICATED;  
                            }  
                            return result;  
                        } finally {  
                            clear(password);  
                        }  
                    }  
  
                    // By this point we had a header we should have been able to verify but for some reason  
                    // it was not correctly structured.  
                    return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;  
                }  
            }  
        }  
  
        // No suitable header has been found in this request,  
        return AuthenticationMechanismOutcome.NOT_ATTEMPTED;  
    }  
  
```  
