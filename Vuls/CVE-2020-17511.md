## Summary:  
Software: airflow  
## Fix:  
Commit: https://github.com/apache/airflow/pull/11468/commits/78fb0dc20c38770bf0c1d2eea14ea4be5d4e570d  
Author: Kaxil Naik  
Fix Time (of the Last Commit): 2020-10-12  
Fix Pattern: Sanitization -> Redaction -> Introduction  
  
  
Fixing-commits Count: 4  
Total Change Size: +60 -2  
  

========  
PR: https://github.com/apache/airflow/pull/11468  
  
Commit: https://github.com/apache/airflow/pull/11468/commits/78fb0dc20c38770bf0c1d2eea14ea4be5d4e570d  
Commit: https://github.com/apache/airflow/pull/11468/commits/40b1c0438857926bf7c1b32c70dba73a806edf24  
Commit: https://github.com/apache/airflow/pull/11468/commits/3e1ce0eb8c6299156f0a475e3ef3f745ea14b98c  
Commit: https://github.com/apache/airflow/pull/11468/commits/35b10b7a0f1bc45e784eb7da632f6f42490cd0f5  
## Sample logs: Yes  
```  
{"host_name": "3f239f9fb74c", "full_command": "['/usr/local/bin/airflow', 'create_user', '-u', 'admin', '-p', 'admin', '-f', 'Thor', '-l', 'Adminstra', '-r', 'Admin', '-e', 'dummy@dummy.email']"}  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（action_logging）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/astronomer/airflow/blob/35b10b7a0f1bc45e784eb7da632f6f42490cd0f5/airflow/cli/commands/user_command.py#L56） -> Variable Names（password）  
Programming Language:Python  
```Python  
  
# https://github.com/astronomer/airflow/blob/35b10b7a0f1bc45e784eb7da632f6f42490cd0f5/airflow/__main__.py#L31-L44  
def main():  
    """Main executable function"""  
    if conf.get("core", "security") == 'kerberos':  
        os.environ['KRB5CCNAME'] = conf.get('kerberos', 'ccache')  
        os.environ['KRB5_KTNAME'] = conf.get('kerberos', 'keytab')  
  
    parser = cli_parser.get_parser()  
    argcomplete.autocomplete(parser)  
    args = parser.parse_args() # HERE IS THE SOURCE  
    args.func(args)  
  
  
if __name__ == '__main__':  
    main()  
  
  
# https://github.com/astronomer/airflow/blob/35b10b7a0f1bc45e784eb7da632f6f42490cd0f5/airflow/cli/cli_parser.py#L1167-L1186  
  
    ActionCommand(  
        name='create',  
        help='Create a user',  
        func=lazy_load_command('airflow.cli.commands.user_command.users_create'),  
        args=(  
            ARG_ROLE, ARG_USERNAME, ARG_EMAIL, ARG_FIRSTNAME, ARG_LASTNAME, ARG_PASSWORD,  
            ARG_USE_RANDOM_PASSWORD  
        ),  
        epilog=(  
            'examples:\n'  
            'To create an user with "Admin" role and username equals to "admin", run:\n'  
            '\n'  
            '    $ airflow users create \\\n'  
            '          --username admin \\\n'  
            '          --firstname FIRST_NAME \\\n'  
            '          --lastname LAST_NAME \\\n'  
            '          --role Admin \\\n'  
            '          --email admin@example.org'  
        )  
    ),  
  
# https://github.com/astronomer/airflow/blob/35b10b7a0f1bc45e784eb7da632f6f42490cd0f5/airflow/cli/commands/user_command.py#L44-L71  
@cli_utils.action_logging # HERE IS THE SINK 1  
def users_create(args):  
    """Creates new user in the DB"""  
    appbuilder = cached_app().appbuilder  # pylint: disable=no-member  
    role = appbuilder.sm.find_role(args.role)  
    if not role:  
        valid_roles = appbuilder.sm.get_all_roles()  
        raise SystemExit('{} is not a valid role. Valid roles are: {}'.format(args.role, valid_roles))  
  
    if args.use_random_password:  
        password = ''.join(random.choice(string.printable) for _ in range(16))  
    elif args.password:  
        password = args.password  
    else:  
        password = getpass.getpass('Password:')  
        password_confirmation = getpass.getpass('Repeat for confirmation:')  
        if password != password_confirmation:  
            raise SystemExit('Passwords did not match!')  
  
    if appbuilder.sm.find_user(args.username):  
        print('{} already exist in the db'.format(args.username))  
        return  
    user = appbuilder.sm.add_user(args.username, args.firstname, args.lastname,  
                                  args.email, role, password)  
    if user:  
        print('{} user {} created.'.format(args.role, args.username))  
    else:  
        raise SystemExit('Failed to create user.')  
  
  
# https://github.com/astronomer/airflow/blob/35b10b7a0f1bc45e784eb7da632f6f42490cd0f5/airflow/utils/cli.py#L47-L142  
  
def action_logging(f: T) -> T:  
    """  
    Decorates function to execute function at the same time submitting action_logging  
    but in CLI context. It will call action logger callbacks twice,  
    one for pre-execution and the other one for post-execution.  
    Action logger will be called with below keyword parameters:  
        sub_command : name of sub-command  
        start_datetime : start datetime instance by utc  
        end_datetime : end datetime instance by utc  
        full_command : full command line arguments  
        user : current user  
        log : airflow.models.log.Log ORM instance  
        dag_id : dag id (optional)  
        task_id : task_id (optional)  
        execution_date : execution date (optional)  
        error : exception instance if there's an exception  
    :param f: function instance  
    :return: wrapped function  
    """  
    @functools.wraps(f)  
    def wrapper(*args, **kwargs):  
        """  
        An wrapper for cli functions. It assumes to have Namespace instance  
        at 1st positional argument  
        :param args: Positional argument. It assumes to have Namespace instance  
            at 1st positional argument  
        :param kwargs: A passthrough keyword argument  
        """  
        if not args:  
            raise ValueError("Args should be set")  
        if not isinstance(args[0], Namespace):  
            raise ValueError("1st positional argument should be argparse.Namespace instance,"  
                             f"but is {type(args[0])}")  
        metrics = _build_metrics(f.__name__, args[0])  
        cli_action_loggers.on_pre_execution(**metrics)  
        try:  
            return f(*args, **kwargs)  
        except Exception as e:  
            metrics['error'] = e  
            raise  
        finally:  
            metrics['end_datetime'] = datetime.utcnow()  
            cli_action_loggers.on_post_execution(**metrics)  
  
    return cast(T, wrapper)  
  
  
def _build_metrics(func_name, namespace):  
    """  
    Builds metrics dict from function args  
    It assumes that function arguments is from airflow.bin.cli module's function  
    and has Namespace instance where it optionally contains "dag_id", "task_id",  
    and "execution_date".  
    :param func_name: name of function  
    :param namespace: Namespace instance from argparse  
    :return: dict with metrics  
    """  
    sensitive_fields = {'-p', '--password', '--conn-password'}  
    full_command = list(sys.argv)  
    for idx, command in enumerate(full_command):  # pylint: disable=too-many-nested-blocks  
        if command in sensitive_fields:  
            # For cases when password is passed as "--password xyz" (with space between key and value)  
            full_command[idx + 1] = "*" * 8  
        else:  
            # For cases when password is passed as "--password=xyz" (with '=' between key and value)  
            for sensitive_field in sensitive_fields:  
                if command.startswith(f'{sensitive_field}='):  
                    full_command[idx] = f'{sensitive_field}={"*" * 8}'  
  
    metrics = {'sub_command': func_name, 'start_datetime': datetime.utcnow(),  
               'full_command': '{}'.format(full_command), 'user': getpass.getuser()}  
  
    if not isinstance(namespace, Namespace):  
        raise ValueError("namespace argument should be argparse.Namespace instance,"  
                         f"but is {type(namespace)}")  
    tmp_dic = vars(namespace)  
    metrics['dag_id'] = tmp_dic.get('dag_id')  
    metrics['task_id'] = tmp_dic.get('task_id')  
    metrics['execution_date'] = tmp_dic.get('execution_date')  
    metrics['host_name'] = socket.gethostname()  
  
    extra = json.dumps({k: metrics[k] for k in ('host_name', 'full_command')})  
    log = Log(  
        event='cli_{}'.format(func_name),  
        task_instance=None,  
        owner=metrics['user'],  
        extra=extra,  
        task_id=metrics.get('task_id'),  
        dag_id=metrics.get('dag_id'),  
        execution_date=metrics.get('execution_date'))  
    metrics['log'] = log  
    return metrics  
  
```  
