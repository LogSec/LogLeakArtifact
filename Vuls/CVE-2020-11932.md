## Summary:  
Software: subiquity  
## Fix:  
Commit: https://github.com/CanonicalLtd/subiquity/commit/7db70650feaf513d7fb6f1ca07f2d670a0890613  
Change Size: +11 -0  
Author: Michael Hudson-Doyle  
Fix Time (of the Last Commit): 2020-05-12  
Fix Pattern: Other -> Sending data with more secure channel  
  
Fixing-commits Count: 1  
Total Change Size: +11 0  
## Sample logs: Yes  
```  
get_path_to_storage_volume for volume dm_crypt-0({'volumel: 'partition-2', 'key': T0pS3cr3tP4ssw0rd, 'preserve': False, 'type': 'dm_crypt', 'id': 'dm_crypt-0'})  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> LUKS full disk encryption password  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Cross Projects|Cross-Libraries（https://github.com/canonical/curtin/blob/8818498e0105d8f395e622540c679d7384dc071c/curtin/storage_config.py#L1035） -> String Literals（key）  
Programming Language:Python  
```python  
# https://github.com/canonical/curtin/blob/8818498e0105d8f395e622540c679d7384dc071c/curtin/commands/block_meta.py#L417-L530  
  
def get_path_to_storage_volume(volume, storage_config):  
    # Get path to block device for volume. Volume param should refer to id of  
    # volume in storage config  
  
    devsync_vol = None  
    vol = storage_config.get(volume)  
    LOG.debug('get_path_to_storage_volume for volume %s(%s)', volume, vol) # HERE IS THE SINK 1  
    if not vol:  
        raise ValueError("volume with id '%s' not found" % volume)  
  
    # Find path to block device  
    if vol.get('type') == "partition":  
        partnumber = determine_partition_number(vol.get('id'), storage_config)  
        disk_block_path = get_path_to_storage_volume(vol.get('device'),  
                                                     storage_config)  
        if disk_block_path.startswith('/dev/mapper/mpath'):  
            volume_path = disk_block_path + '-part%s' % partnumber  
        else:  
            disk_kname = block.path_to_kname(disk_block_path)  
            partition_kname = block.partition_kname(disk_kname, partnumber)  
            volume_path = block.kname_to_path(partition_kname)  
        devsync_vol = os.path.join(disk_block_path)  
  
    elif vol.get('type') == "disk":  
        # Get path to block device for disk. Device_id param should refer  
        # to id of device in storage config  
        volume_path = None  
        for disk_key in ['wwn', 'serial', 'device_id', 'path']:  
            vol_value = vol.get(disk_key)  
            try:  
                if not vol_value:  
                    continue  
                if disk_key in ['wwn', 'serial']:  
                    volume_path = block.lookup_disk(vol_value)  
                elif disk_key == 'path':  
                    if vol_value.startswith('iscsi:'):  
                        i = iscsi.ensure_disk_connected(vol_value)  
                        volume_path = os.path.realpath(i.devdisk_path)  
                    else:  
                        # resolve any symlinks to the dev_kname so  
                        # sys/class/block access is valid.  ie, there are no  
                        # udev generated values in sysfs  
                        volume_path = os.path.realpath(vol_value)  
                    # convert /dev/sdX to /dev/mapper/mpathX value  
                    if multipath.is_mpath_member(volume_path):  
                        volume_path = '/dev/mapper/' + (  
                            multipath.get_mpath_id_from_device(volume_path))  
                elif disk_key == 'device_id':  
                    dasd_device = dasd.DasdDevice(vol_value)  
                    volume_path = dasd_device.devname  
            except ValueError:  
                continue  
            # verify path exists otherwise try the next key  
            if os.path.exists(volume_path):  
                break  
            else:  
                volume_path = None  
  
        if volume_path is None:  
            raise ValueError("Failed to find storage volume id='%s' config: %s"  
                             % (vol['id'], vol))  
  
    elif vol.get('type') == "lvm_partition":  
        # For lvm partitions, a directory in /dev/ should be present with the  
        # name of the volgroup the partition belongs to. We can simply append  
        # the id of the lvm partition to the path of that directory  
        volgroup = storage_config.get(vol.get('volgroup'))  
        if not volgroup:  
            raise ValueError("lvm volume group '%s' could not be found"  
                             % vol.get('volgroup'))  
        volume_path = os.path.join("/dev/", volgroup.get('name'),  
                                   vol.get('name'))  
  
    elif vol.get('type') == "dm_crypt":  
        # For dm_crypted partitions, unencrypted block device is at  
        # /dev/mapper/<dm_name>  
        dm_name = vol.get('dm_name')  
        if not dm_name:  
            dm_name = vol.get('id')  
        volume_path = os.path.join("/dev", "mapper", dm_name)  
  
    elif vol.get('type') == "raid":  
        # For raid partitions, block device is at /dev/mdX  
        name = vol.get('name')  
        volume_path = block.md_path(name)  
  
    elif vol.get('type') == "bcache":  
        # For bcache setups, the only reliable way to determine the name of the  
        # block device is to look in all /sys/block/bcacheX/ dirs and see what  
        # block devs are in the slaves dir there. Then, those blockdevs can be  
        # checked against the kname of the devs in the config for the desired  
        # bcache device. This is not very elegant though  
        backing_device_path = get_path_to_storage_volume(  
            vol.get('backing_device'), storage_config)  
        backing_device_kname = block.path_to_kname(backing_device_path)  
        sys_path = list(filter(lambda x: backing_device_kname in x,  
                               glob.glob("/sys/block/bcache*/slaves/*")))[0]  
        while "bcache" not in os.path.split(sys_path)[-1]:  
            sys_path = os.path.split(sys_path)[0]  
        bcache_kname = block.path_to_kname(sys_path)  
        volume_path = block.kname_to_path(bcache_kname)  
        LOG.debug('got bcache volume path %s', volume_path)  
  
    else:  
        raise NotImplementedError("cannot determine the path to storage \  
            volume '%s' with type '%s'" % (volume, vol.get('type')))  
  
    # sync devices  
    if not devsync_vol:  
        devsync_vol = volume_path  
    devsync(devsync_vol)  
  
    LOG.debug('return volume path %s', volume_path)  
    return volume_path  
  
```  
