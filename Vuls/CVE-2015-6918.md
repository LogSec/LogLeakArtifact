## Summary:  
Software: salt  
## Fix:  
Commit: https://github.com/thusoy/salt/commit/528916548726976dcc75626dc6f6641ceb206ee3  
Fix Time (of the Last Commit): 2015-08-20  
Author: Tarjei Husøy  
Fix Pattern: Sanitization -> Redaction -> Introduction -> Keyword/RegexBasedFiltration -> RedactionFunctionDefined  
  
  
Fixing-commits Count: 1  
Total Change Size: +32 -3  
  
==========  
PR: https://github.com/saltstack/salt/pull/26486  
Commit: https://github.com/thusoy/salt/commit/528916548726976dcc75626dc6f6641ceb206ee3  
Change Size: +32 -3  
Time: 2015-08-20  
Author: Tarjei Husøy  
## Sample logs: Yes  
```  
Salt Version:  
           Salt: 2015.8.0  
   
Dependency Versions:  
         Jinja2: 2.10  
       M2Crypto: Not Installed  
           Mako: Not Installed  
         PyYAML: 5.4.1  
          PyZMQ: 14.0.1  
         Python: 2.7.12 (default, Mar  1 2021, 11:38:31)  
           RAET: Not Installed  
        Tornado: 4.2.1  
            ZMQ: 2.2.0  
          ioflo: Not Installed  
        libnacl: Not Installed  
   msgpack-pure: Not Installed  
 msgpack-python: 0.5.6  
       pycrypto: 2.6.1  
   
System Versions:  
           dist: Ubuntu 16.04 xenial  
        machine: x86_64  
        release: 4.4.0-210-generic  
         system: Ubuntu 16.04 xenial  
  
```  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> git usernames and passwords  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/git.py#L233） -> Variable Names(https_pass)  
#### Sink 2:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  跨方法-同文件（https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/git.py#L233） -> Variable Names(https_pass)  
#### Sink 3:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Cross Projects|Cross-System（https://github.com/git/git/blob/master/http.c#L1220，https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/git.py#L233） -> Method Names(credential_from_url)  
#### Sink 4:  
Logging call Function:  Standard Libraries（sys.stderr.write）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/git.py#L233） -> Variable Names(https_pass)  
#### Sink 5:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/git.py#L233） -> Variable Names(https_pass)  
Programming Language:Python  
```Python  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/git.py#L191-L242  
def clone(cwd, repository, opts=None, user=None, identity=None,  
          https_user=None, https_pass=None):  
    '''  
    Clone a new repository  
    cwd  
        The path to the Git repository  
    repository  
        The git URI of the repository  
    opts : None  
        Any additional options to add to the command line  
    user : None  
        Run git as a user other than what the minion runs as  
    identity : None  
        A path to a private key to use over SSH  
    https_user : None  
        HTTP Basic Auth username for HTTPS (only) clones  
        .. versionadded:: 20515.5.0  
    https_pass : None  
        HTTP Basic Auth password for HTTPS (only) clones  
        .. versionadded:: 2015.5.0  
    CLI Example:  
    .. code-block:: bash  
        salt '*' git.clone /path/to/repo git://github.com/saltstack/salt.git  
        salt '*' git.clone /path/to/repo.git\\  
                git://github.com/saltstack/salt.git '--bare --origin github'  
    '''  
    _check_git()  
  
    repository = _add_http_basic_auth(repository, https_user, https_pass)  
  
    if not opts:  
        opts = ''  
    if utils.is_windows():  
        cmd = 'git clone {0} {1} {2}'.format(repository, cwd, opts)  
    else:  
        cmd = 'git clone {0} {1!r} {2}'.format(repository, cwd, opts)  
  
    return _git_run(cmd, runas=user, identity=identity)  
  
  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/git.py#L131-L145  
  
def _add_http_basic_auth(repository, https_user=None, https_pass=None):  
    if https_user is None and https_pass is None:  
        return repository  
    else:  
        urltuple = _urlparse(repository)  
        if urltuple.scheme == 'https':  
            if https_pass:  
                auth_string = "{0}:{1}".format(https_user, https_pass)  
            else:  
                auth_string = https_user  
            netloc = "{0}@{1}".format(auth_string, urltuple.netloc)  
            urltuple = urltuple._replace(netloc=netloc)  
            return _urlunparse(urltuple)  
        else:  
            raise ValueError('Basic Auth only supported for HTTPS scheme')  
  
  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/git.py#L26-L106  
  
def _git_run(cmd, cwd=None, runas=None, identity=None, **kwargs):  
    '''  
    simple, throw an exception with the error message on an error return code.  
    this function may be moved to the command module, spliced with  
    'cmd.run_all', and used as an alternative to 'cmd.run_all'. Some  
    commands don't return proper retcodes, so this can't replace 'cmd.run_all'.  
    '''  
    env = {}  
  
    if identity:  
        stderrs = []  
  
        # if the statefile provides multiple identities, they need to be tried  
        # (but also allow a string instead of a list)  
        if not isinstance(identity, list):  
            # force it into a list  
            identity = [identity]  
  
        # try each of the identities, independently  
        for id_file in identity:  
            env = {  
                'GIT_IDENTITY': id_file  
            }  
  
            # copy wrapper to area accessible by ``runas`` user  
            # currently no suppport in windows for wrapping git ssh  
            if not utils.is_windows():  
                ssh_id_wrapper = os.path.join(utils.templates.TEMPLATE_DIRNAME,  
                                              'git/ssh-id-wrapper')  
                tmp_file = utils.mkstemp()  
                utils.files.copyfile(ssh_id_wrapper, tmp_file)  
                os.chmod(tmp_file, 0o500)  
                os.chown(tmp_file, __salt__['file.user_to_uid'](runas), -1)  
                env['GIT_SSH'] = tmp_file  
  
            try:  
                result = __salt__['cmd.run_all'](cmd,  
                                                 cwd=cwd,  
                                                 runas=runas,  
                                                 output_loglevel='quiet',  
                                                 env=env,  
                                                 python_shell=False,  
                                                 **kwargs)  
            finally:  
                if 'GIT_SSH' in env:  
                    os.remove(env['GIT_SSH'])  
  
            # if the command was successful, no need to try additional IDs  
            if result['retcode'] == 0:  
                return result['stdout']  
            else:  
                stderr = _remove_sensitive_data(result['stderr'])  
                stderrs.append(stderr)  
  
        # we've tried all IDs and still haven't passed, so error out  
        raise CommandExecutionError("\n\n".join(stderrs)) # HERE IS THE INNER SINK 1 FOR SINK 4,5  
  
    else:  
        result = __salt__['cmd.run_all'](cmd,  
                                         cwd=cwd,  
                                         runas=runas,  
                                         output_loglevel='quiet',  
                                         env=env,  
                                         python_shell=False,  
                                         **kwargs) # HERE IS THE FLOW  
        retcode = result['retcode']  
  
        if retcode == 0:  
            return result['stdout']  
        else:  
            stderr = _remove_sensitive_data(result['stderr'])  
            raise CommandExecutionError(  
                'Command {0!r} failed. Stderr: {1!r}'.format(cmd, stderr)) # HERE IS THE INNER SINK 2 FOR SINK 4,5  
  
  
def _remove_sensitive_data(sensitive_output):  
    '''  
        Remove HTTP user and password.  
    '''  
    return re.sub('(https?)://.*@', r'\1://<redacted>@', sensitive_output)  
  
  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/loader.py#L34-L36  
__salt__ = {  
    'cmd.run': salt.modules.cmdmod._run_quiet  
}  
  
  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/cmdmod.py#L988-L1071  
def run_all(cmd,  
            cwd=None,  
            stdin=None,  
            runas=None,  
            shell=DEFAULT_SHELL,  
            python_shell=None,  
            env=None,  
            clean_env=False,  
            template=None,  
            rstrip=True,  
            umask=None,  
            output_loglevel='debug',  
            timeout=None,  
            reset_system_locale=True,  
            ignore_retcode=False,  
            saltenv='base',  
            use_vt=False,  
            **kwargs):  
    '''  
    Execute the passed command and return a dict of return data  
    Note that ``env`` represents the environment variables for the command, and  
    should be formatted as a dict, or a YAML string which resolves to a dict.  
    CLI Example:  
    .. code-block:: bash  
        salt '*' cmd.run_all "ls -l | awk '/foo/{print \\$2}'"  
    The template arg can be set to 'jinja' or another supported template  
    engine to render the command arguments before execution.  
    For example:  
    .. code-block:: bash  
        salt '*' cmd.run_all template=jinja "ls -l /tmp/{{grains.id}} | awk '/foo/{print \\$2}'"  
    A string of standard input can be specified for the command to be run using  
    the ``stdin`` parameter. This can be useful in cases where sensitive  
    information must be read from standard input.:  
    .. code-block:: bash  
        salt '*' cmd.run_all "grep f" stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'  
    '''  
    python_shell = _python_shell_default(python_shell,  
                                         kwargs.get('__pub_jid', ''))  
    ret = _run(cmd,  
               runas=runas,  
               cwd=cwd,  
               stdin=stdin,  
               shell=shell,  
               python_shell=python_shell,  
               env=env,  
               clean_env=clean_env,  
               template=template,  
               rstrip=rstrip,  
               umask=umask,  
               output_loglevel=output_loglevel,  
               timeout=timeout,  
               reset_system_locale=reset_system_locale,  
               ignore_retcode=ignore_retcode,  
               saltenv=saltenv,  
               pillarenv=kwargs.get('pillarenv'),  
               pillar_override=kwargs.get('pillar'),  
               use_vt=use_vt)  
  
    lvl = _check_loglevel(output_loglevel)  
    if lvl is not None:  
        if not ignore_retcode and ret['retcode'] != 0:  
            if lvl < LOG_LEVELS['error']:  
                lvl = LOG_LEVELS['error']  
            log.error(  
                'Command {0!r} failed with return code: {1}'  
                .format(cmd, ret['retcode'])  
            )  
        if ret['stdout']:  
            log.log(lvl, 'stdout: {0}'.format(ret['stdout']))  
        if ret['stderr']:  
            log.log(lvl, 'stderr: {0}'.format(ret['stderr'])) # HERE IS THE UNFIXED SINK 1  
        if ret['retcode']:  
            log.log(lvl, 'retcode: {0}'.format(ret['retcode']))  
    return ret  
  
  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/cmdmod.py#L197-L552  
  
def _run(cmd,  
         cwd=None,  
         stdin=None,  
         stdout=subprocess.PIPE,  
         stderr=subprocess.PIPE,  
         output_loglevel='debug',  
         runas=None,  
         shell=DEFAULT_SHELL,  
         python_shell=False,  
         env=None,  
         clean_env=False,  
         rstrip=True,  
         template=None,  
         umask=None,  
         timeout=None,  
         with_communicate=True,  
         reset_system_locale=True,  
         ignore_retcode=False,  
         saltenv='base',  
         pillarenv=None,  
         pillar_override=None,  
         use_vt=False):  
    '''  
    Do the DRY thing and only call subprocess.Popen() once  
    '''  
    if _is_valid_shell(shell) is False:  
        log.warning(  
            'Attempt to run a shell command with what may be an invalid shell! '  
            'Check to ensure that the shell <{0}> is valid for this user.'  
            .format(shell))  
  
    # Set the default working directory to the home directory of the user  
    # salt-minion is running as. Defaults to home directory of user under which  
    # the minion is running.  
    if not cwd:  
        cwd = os.path.expanduser('~{0}'.format('' if not runas else runas))  
  
        # make sure we can access the cwd  
        # when run from sudo or another environment where the euid is  
        # changed ~ will expand to the home of the original uid and  
        # the euid might not have access to it. See issue #1844  
        if not os.access(cwd, os.R_OK):  
            cwd = '/'  
            if salt.utils.is_windows():  
                cwd = os.tempnam()[:3]  
    else:  
        # Handle edge cases where numeric/other input is entered, and would be  
        # yaml-ified into non-string types  
        cwd = str(cwd)  
  
    if not salt.utils.is_windows():  
        if not os.path.isfile(shell) or not os.access(shell, os.X_OK):  
            msg = 'The shell {0} is not available'.format(shell)  
            raise CommandExecutionError(msg)  
    if salt.utils.is_windows() and use_vt:  # Memozation so not much overhead  
        raise CommandExecutionError('VT not available on windows')  
  
    if shell.lower().strip() == 'powershell':  
        # If we were called by script(), then fakeout the Windows  
        # shell to run a Powershell script.  
        # Else just run a Powershell command.  
        stack = traceback.extract_stack(limit=2)  
  
        # extract_stack() returns a list of tuples.  
        # The last item in the list [-1] is the current method.  
        # The third item[2] in each tuple is the name of that method.  
        if stack[-2][2] == 'script':  
            cmd = 'Powershell -NonInteractive -ExecutionPolicy Bypass -File ' + cmd  
        else:  
            cmd = 'Powershell -NonInteractive "{0}"'.format(cmd.replace('"', '\\"'))  
  
    # munge the cmd and cwd through the template  
    (cmd, cwd) = _render_cmd(cmd, cwd, template, saltenv, pillarenv, pillar_override)  
  
    ret = {}  
  
    env = _parse_env(env)  
  
    for bad_env_key in (x for x, y in six.iteritems(env) if y is None):  
        log.error('Environment variable {0!r} passed without a value. '  
                  'Setting value to an empty string'.format(bad_env_key))  
        env[bad_env_key] = ''  
  
    if runas and salt.utils.is_windows():  
        # TODO: Figure out the proper way to do this in windows  
        msg = 'Sorry, {0} does not support runas functionality'  
        raise CommandExecutionError(msg.format(__grains__['os']))  
  
    if runas:  
        # Save the original command before munging it  
        try:  
            pwd.getpwnam(runas)  
        except KeyError:  
            raise CommandExecutionError(  
                'User {0!r} is not available'.format(runas)  
            )  
        try:  
            # Getting the environment for the runas user  
            # There must be a better way to do this.  
            py_code = (  
                'import sys, os, itertools; '  
                'sys.stdout.write(\"\\0\".join(itertools.chain(*os.environ.items())))'  
            )  
            if __grains__['os'] in ['MacOS', 'Darwin']:  
                env_cmd = ('sudo', '-i', '-u', runas, '--',  
                           sys.executable)  
            elif __grains__['os'] in ['FreeBSD']:  
                env_cmd = ('su', '-', runas, '-c',  
                           "{0} -c {1}".format(shell, sys.executable))  
            else:  
                env_cmd = ('su', '-s', shell, '-', runas, '-c', sys.executable)  
            env_encoded = subprocess.Popen(  
                env_cmd,  
                stdin=subprocess.PIPE,  
                stdout=subprocess.PIPE  
            ).communicate(py_code)[0]  
            import itertools  
            env_runas = dict(itertools.izip(*[iter(env_encoded.split(b'\0'))]*2))  
            env_runas.update(env)  
            env = env_runas  
            # Encode unicode kwargs to filesystem encoding to avoid a  
            # UnicodeEncodeError when the subprocess is invoked.  
            fse = sys.getfilesystemencoding()  
            for key, val in six.iteritems(env):  
                if isinstance(val, six.text_type):  
                    env[key] = val.encode(fse)  
        except ValueError:  
            raise CommandExecutionError(  
                'Environment could not be retrieved for User {0!r}'.format(  
                    runas  
                )  
            )  
  
    if _check_loglevel(output_loglevel) is not None:  
        # Always log the shell commands at INFO unless quiet logging is  
        # requested. The command output is what will be controlled by the  
        # 'loglevel' parameter.  
        log.info(  
            'Executing command {0!r} {1}in directory {2!r}'.format(  
                cmd, 'as user {0!r} '.format(runas) if runas else '', cwd  
            )  
        ) # HERE IS THE SINK 1  
  
    if reset_system_locale is True:  
        if not salt.utils.is_windows():  
            # Default to C!  
            # Salt only knows how to parse English words  
            # Don't override if the user has passed LC_ALL  
            env.setdefault('LC_ALL', 'C')  
        else:  
            # On Windows set the codepage to US English.  
            if python_shell:  
                cmd = 'chcp 437 > nul & ' + cmd  
  
    if clean_env:  
        run_env = env  
  
    else:  
        run_env = os.environ.copy()  
        run_env.update(env)  
  
    if python_shell is None:  
        python_shell = False  
  
    kwargs = {'cwd': cwd,  
              'shell': python_shell,  
              'env': run_env,  
              'stdin': str(stdin) if stdin is not None else stdin,  
              'stdout': stdout,  
              'stderr': stderr,  
              'with_communicate': with_communicate}  
  
    if umask is not None:  
        _umask = str(umask).lstrip('0')  
  
        if _umask == '':  
            msg = 'Zero umask is not allowed.'  
            raise CommandExecutionError(msg)  
  
        try:  
            _umask = int(_umask, 8)  
        except ValueError:  
            msg = 'Invalid umask: \'{0}\''.format(umask)  
            raise CommandExecutionError(msg)  
    else:  
        _umask = None  
  
    if runas or umask:  
        kwargs['preexec_fn'] = functools.partial(  
            salt.utils.chugid_and_umask,  
            runas,  
            _umask)  
  
    if not salt.utils.is_windows():  
        # close_fds is not supported on Windows platforms if you redirect  
        # stdin/stdout/stderr  
        if kwargs['shell'] is True:  
            kwargs['executable'] = shell  
        kwargs['close_fds'] = True  
  
    if not os.path.isabs(cwd) or not os.path.isdir(cwd):  
        raise CommandExecutionError(  
            'Specified cwd {0!r} either not absolute or does not exist'  
            .format(cwd)  
        )  
  
    if python_shell is not True and not isinstance(cmd, list):  
        posix = True  
        if salt.utils.is_windows():  
            posix = False  
        cmd = shlex.split(cmd, posix=posix)  
    if not use_vt:  
        # This is where the magic happens  
        try:  
            proc = salt.utils.timed_subprocess.TimedProc(cmd, **kwargs) # HERE IS THE FLOW  
        except (OSError, IOError) as exc:  
            raise CommandExecutionError(  
                'Unable to run command {0!r} with the context {1!r}, reason: {2}'  
                .format(cmd, kwargs, exc)  
            )  
  
        try:  
            proc.wait(timeout)  
        except TimedProcTimeoutError as exc:  
            ret['stdout'] = str(exc)  
            ret['stderr'] = ''  
            ret['retcode'] = None  
            ret['pid'] = proc.process.pid  
            # ok return code for timeouts?  
            ret['retcode'] = 1  
            return ret  
  
        out, err = proc.stdout, proc.stderr  
  
        if rstrip:  
            if out is not None:  
                out = out.rstrip()  
            if err is not None:  
                err = err.rstrip()  
        ret['pid'] = proc.process.pid  
        ret['retcode'] = proc.process.returncode  
        ret['stdout'] = out  
        ret['stderr'] = err  
    else:  
        to = ''  
        if timeout:  
            to = ' (timeout: {0}s)'.format(timeout)  
        if _check_loglevel(output_loglevel) is not None:  
            log.debug('Running {0} in VT{1}'.format(cmd, to))  
        stdout, stderr = '', ''  
        now = time.time()  
        if timeout:  
            will_timeout = now + timeout  
        else:  
            will_timeout = -1  
        try:  
            proc = vt.Terminal(cmd,  
                               shell=True,  
                               log_stdout=True,  
                               log_stderr=True,  
                               cwd=cwd,  
                               preexec_fn=kwargs.get('preexec_fn', None),  
                               env=run_env,  
                               log_stdin_level=output_loglevel,  
                               log_stdout_level=output_loglevel,  
                               log_stderr_level=output_loglevel,  
                               stream_stdout=True,  
                               stream_stderr=True) # HERE IS THE FLOW  
            ret['pid'] = proc.pid  
            while proc.has_unread_data:  
                try:  
                    try:  
                        time.sleep(0.5)  
                        try:  
                            cstdout, cstderr = proc.recv()  
                        except IOError:  
                            cstdout, cstderr = '', ''  
                        if cstdout:  
                            stdout += cstdout  
                        else:  
                            cstdout = ''  
                        if cstderr:  
                            stderr += cstderr  
                        else:  
                            cstderr = ''  
                        if timeout and (time.time() > will_timeout):  
                            ret['stderr'] = (  
                                'SALT: Timeout after {0}s\n{1}').format(  
                                    timeout, stderr)  
                            ret['retcode'] = None  
                            break  
                    except KeyboardInterrupt:  
                        ret['stderr'] = 'SALT: User break\n{0}'.format(stderr)  
                        ret['retcode'] = 1  
                        break  
                except vt.TerminalException as exc:  
                    log.error(  
                        'VT: {0}'.format(exc),  
                        exc_info_on_loglevel=logging.DEBUG)  
                    ret = {'retcode': 1, 'pid': '2'}  
                    break  
                # only set stdout on success as we already mangled in other  
                # cases  
                ret['stdout'] = stdout  
                if not proc.isalive():  
                    # Process terminated, i.e., not canceled by the user or by  
                    # the timeout  
                    ret['stderr'] = stderr  
                    ret['retcode'] = proc.exitstatus  
                ret['pid'] = proc.pid  
        finally:  
            proc.close(terminate=True, kill=True)  
    try:  
        if ignore_retcode:  
            __context__['retcode'] = 0  
        else:  
            __context__['retcode'] = ret['retcode']  
    except NameError:  
        # Ignore the context error during grain generation  
        pass  
    return ret  
  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/modules/cmdmod.py#L988-L1071  
def run_all(cmd,  
            cwd=None,  
            stdin=None,  
            runas=None,  
            shell=DEFAULT_SHELL,  
            python_shell=None,  
            env=None,  
            clean_env=False,  
            template=None,  
            rstrip=True,  
            umask=None,  
            output_loglevel='debug',  
            timeout=None,  
            reset_system_locale=True,  
            ignore_retcode=False,  
            saltenv='base',  
            use_vt=False,  
            **kwargs):  
    '''  
    Execute the passed command and return a dict of return data  
    Note that ``env`` represents the environment variables for the command, and  
    should be formatted as a dict, or a YAML string which resolves to a dict.  
    CLI Example:  
    .. code-block:: bash  
        salt '*' cmd.run_all "ls -l | awk '/foo/{print \\$2}'"  
    The template arg can be set to 'jinja' or another supported template  
    engine to render the command arguments before execution.  
    For example:  
    .. code-block:: bash  
        salt '*' cmd.run_all template=jinja "ls -l /tmp/{{grains.id}} | awk '/foo/{print \\$2}'"  
    A string of standard input can be specified for the command to be run using  
    the ``stdin`` parameter. This can be useful in cases where sensitive  
    information must be read from standard input.:  
    .. code-block:: bash  
        salt '*' cmd.run_all "grep f" stdin='one\\ntwo\\nthree\\nfour\\nfive\\n'  
    '''  
    python_shell = _python_shell_default(python_shell,  
                                         kwargs.get('__pub_jid', ''))  
    ret = _run(cmd,  
               runas=runas,  
               cwd=cwd,  
               stdin=stdin,  
               shell=shell,  
               python_shell=python_shell,  
               env=env,  
               clean_env=clean_env,  
               template=template,  
               rstrip=rstrip,  
               umask=umask,  
               output_loglevel=output_loglevel,  
               timeout=timeout,  
               reset_system_locale=reset_system_locale,  
               ignore_retcode=ignore_retcode,  
               saltenv=saltenv,  
               pillarenv=kwargs.get('pillarenv'),  
               pillar_override=kwargs.get('pillar'),  
               use_vt=use_vt)  
  
    lvl = _check_loglevel(output_loglevel)  
    if lvl is not None:  
        if not ignore_retcode and ret['retcode'] != 0:  
            if lvl < LOG_LEVELS['error']:  
                lvl = LOG_LEVELS['error']  
            log.error(  
                'Command {0!r} failed with return code: {1}'  
                .format(cmd, ret['retcode'])  
            ) # HERE IS THE SINK 2  
        if ret['stdout']:  
            log.log(lvl, 'stdout: {0}'.format(ret['stdout']))  
        if ret['stderr']:  
            log.log(lvl, 'stderr: {0}'.format(ret['stderr'])) # HERE IS THE SINK 3  
        if ret['retcode']:  
            log.log(lvl, 'retcode: {0}'.format(ret['retcode']))  
    return ret  
  
  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/cli/caller.py#L96-L199  
    def call(self):  
        '''  
        Call the module  
        '''  
        ret = {}  
        fun = self.opts['fun']  
        ret['jid'] = '{0:%Y%m%d%H%M%S%f}'.format(datetime.datetime.now())  
        proc_fn = os.path.join(  
            salt.minion.get_proc_dir(self.opts['cachedir']),  
            ret['jid']  
        )  
        if fun not in self.minion.functions:  
            sys.stderr.write(self.minion.functions.missing_fun_string(fun))  
            mod_name = fun.split('.')[0]  
            if mod_name in self.minion.function_errors:  
                sys.stderr.write(' Possible reasons: {0}\n'.format(self.minion.function_errors[mod_name]))  
            else:  
                sys.stderr.write('\n')  
            sys.exit(-1)  
        try:  
            sdata = {  
                'fun': fun,  
                'pid': os.getpid(),  
                'jid': ret['jid'],  
                'tgt': 'salt-call'}  
            args, kwargs = salt.minion.load_args_and_kwargs(  
                self.minion.functions[fun],  
                salt.utils.args.parse_input(self.opts['arg']),  
                data=sdata)  
            try:  
                with salt.utils.fopen(proc_fn, 'w+b') as fp_:  
                    fp_.write(self.serial.dumps(sdata))  
            except NameError:  
                # Don't require msgpack with local  
                pass  
            except IOError:  
                sys.stderr.write(  
                    'Cannot write to process directory. '  
                    'Do you have permissions to '  
                    'write to {0} ?\n'.format(proc_fn))  
            func = self.minion.functions[fun]  
            try:  
                ret['return'] = func(*args, **kwargs)  
            except TypeError as exc:  
                trace = traceback.format_exc()  
                sys.stderr.write('Passed invalid arguments: {0}\n'.format(exc))  
                active_level = LOG_LEVELS.get(  
                    self.opts['log_level'].lower(), logging.ERROR)  
                if active_level <= logging.DEBUG:  
                    sys.stderr.write(trace)  
                sys.exit(salt.defaults.exitcodes.EX_GENERIC)  
            try:  
                ret['retcode'] = sys.modules[  
                    func.__module__].__context__.get('retcode', 0)  
            except AttributeError:  
                ret['retcode'] = 1  
        except (CommandExecutionError) as exc:  
            msg = 'Error running \'{0}\': {1}\n'  
            active_level = LOG_LEVELS.get(  
                self.opts['log_level'].lower(), logging.ERROR)  
            if active_level <= logging.DEBUG:  
                sys.stderr.write(traceback.format_exc())  
            sys.stderr.write(msg.format(fun, str(exc))) # HERE IS THE SINK 4  
            sys.exit(salt.defaults.exitcodes.EX_GENERIC)  
        except CommandNotFoundError as exc:  
            msg = 'Command required for \'{0}\' not found: {1}\n'  
            sys.stderr.write(msg.format(fun, str(exc)))  
            sys.exit(salt.defaults.exitcodes.EX_GENERIC)  
        try:  
            os.remove(proc_fn)  
        except (IOError, OSError):  
            pass  
        if hasattr(self.minion.functions[fun], '__outputter__'):  
            oput = self.minion.functions[fun].__outputter__  
            if isinstance(oput, string_types):  
                ret['out'] = oput  
        is_local = self.opts['local'] or self.opts.get(  
            'file_client', False) == 'local'  
        returners = self.opts.get('return', '').split(',')  
        if (not is_local) or returners:  
            ret['id'] = self.opts['id']  
            ret['fun'] = fun  
            ret['fun_args'] = self.opts['arg']  
  
        for returner in returners:  
            if not returner:  # if we got an empty returner somehow, skip  
                continue  
            try:  
                ret['success'] = True  
                self.minion.returners['{0}.returner'.format(returner)](ret)  
            except Exception:  
                pass  
  
        # return the job infos back up to the respective minion's master  
  
        if not is_local:  
            try:  
                mret = ret.copy()  
                mret['jid'] = 'req'  
                self.return_pub(mret)  
            except Exception:  
                pass  
        # close raet channel here  
        return ret  
  
# https://github.com/thusoy/salt/blob/528916548726976dcc75626dc6f6641ceb206ee3/salt/minion.py#L1134-L1273  
    def _thread_return(cls, minion_instance, opts, data):  
        '''  
        This method should be used as a threading target, start the actual  
        minion side execution.  
        '''  
        # this seems awkward at first, but it's a workaround for Windows  
        # multiprocessing communication.  
        if not minion_instance:  
            minion_instance = cls(opts)  
        fn_ = os.path.join(minion_instance.proc_dir, data['jid'])  
        if opts['multiprocessing']:  
            salt.utils.daemonize_if(opts)  
  
        salt.utils.appendproctitle(data['jid'])  
  
        sdata = {'pid': os.getpid()}  
        sdata.update(data)  
        log.info('Starting a new job with PID {0}'.format(sdata['pid']))  
        with salt.utils.fopen(fn_, 'w+b') as fp_:  
            fp_.write(minion_instance.serial.dumps(sdata))  
        ret = {'success': False}  
        function_name = data['fun']  
        if function_name in minion_instance.functions:  
            try:  
                func = minion_instance.functions[data['fun']]  
                args, kwargs = load_args_and_kwargs(  
                    func,  
                    data['arg'],  
                    data)  
                minion_instance.functions.pack['__context__']['retcode'] = 0  
                if opts.get('sudo_user', ''):  
                    sudo_runas = opts.get('sudo_user')  
                    if 'sudo.salt_call' in minion_instance.functions:  
                        return_data = minion_instance.functions['sudo.salt_call'](  
                                sudo_runas,  
                                data['fun'],  
                                *args,  
                                **kwargs)  
                else:  
                    return_data = func(*args, **kwargs)  
                if isinstance(return_data, types.GeneratorType):  
                    ind = 0  
                    iret = {}  
                    for single in return_data:  
                        if isinstance(single, dict) and isinstance(iret, dict):  
                            iret.update(single)  
                        else:  
                            if not iret:  
                                iret = []  
                            iret.append(single)  
                        tag = tagify([data['jid'], 'prog', opts['id'], str(ind)], 'job')  
                        event_data = {'return': single}  
                        minion_instance._fire_master(event_data, tag)  
                        ind += 1  
                    ret['return'] = iret  
                else:  
                    ret['return'] = return_data  
                ret['retcode'] = minion_instance.functions.pack['__context__'].get(  
                    'retcode',  
                    0  
                )  
                ret['success'] = True  
            except CommandNotFoundError as exc:  
                msg = 'Command required for {0!r} not found'.format(  
                    function_name  
                )  
                log.debug(msg, exc_info=True)  
                ret['return'] = '{0}: {1}'.format(msg, exc)  
                ret['out'] = 'nested'  
            except CommandExecutionError as exc:  
                log.error(  
                    'A command in {0!r} had a problem: {1}'.format(  
                        function_name,  
                        exc  
                    ),  
                    exc_info_on_loglevel=logging.DEBUG  
                ) # HERE IS THE SINK 5  
                ret['return'] = 'ERROR: {0}'.format(exc)  
                ret['out'] = 'nested'  
            except SaltInvocationError as exc:  
                log.error(  
                    'Problem executing {0!r}: {1}'.format(  
                        function_name,  
                        exc  
                    ),  
                    exc_info_on_loglevel=logging.DEBUG  
                )  
                ret['return'] = 'ERROR executing {0!r}: {1}'.format(  
                    function_name, exc  
                )  
                ret['out'] = 'nested'  
            except TypeError as exc:  
                msg = ('TypeError encountered executing {0}: {1}. See '  
                       'debug log for more info.').format(function_name, exc)  
                log.warning(msg, exc_info_on_loglevel=logging.DEBUG)  
                ret['return'] = msg  
                ret['out'] = 'nested'  
            except Exception:  
                msg = 'The minion function caused an exception'  
                log.warning(msg, exc_info_on_loglevel=logging.DEBUG)  
                salt.utils.error.fire_exception(salt.exceptions.MinionError(msg), opts, job=data)  
                ret['return'] = '{0}: {1}'.format(msg, traceback.format_exc())  
                ret['out'] = 'nested'  
        else:  
            ret['return'] = minion_instance.functions.missing_fun_string(function_name)  
            mod_name = function_name.split('.')[0]  
            if mod_name in minion_instance.function_errors:  
                ret['return'] += ' Possible reasons: {0!r}'.format(minion_instance.function_errors[mod_name])  
            ret['success'] = False  
            ret['retcode'] = 254  
            ret['out'] = 'nested'  
  
        ret['jid'] = data['jid']  
        ret['fun'] = data['fun']  
        ret['fun_args'] = data['arg']  
        if 'master_id' in data:  
            ret['master_id'] = data['master_id']  
        if 'metadata' in data:  
            if isinstance(data['metadata'], dict):  
                ret['metadata'] = data['metadata']  
            else:  
                log.warning('The metadata parameter must be a dictionary.  Ignoring.')  
        minion_instance._return_pub(ret)  
        if data['ret']:  
            if 'ret_config' in data:  
                ret['ret_config'] = data['ret_config']  
            ret['id'] = opts['id']  
            for returner in set(data['ret'].split(',')):  
                try:  
                    minion_instance.returners['{0}.returner'.format(  
                        returner  
                    )](ret)  
                except Exception as exc:  
                    log.error(  
                        'The return failed for job {0} {1}'.format(  
                        data['jid'],  
                        exc  
                        )  
                    )  
                    log.error(traceback.format_exc())  
  
  
```  
