## Summary:  
Software: cloud_foundry/log_cache  
## Fix:  
Commit: https://github.com/cloudfoundry/log-cache/commit/0a6fb8eb269513259ac01aeb365ee82694e68bcb  
Fix Time (of the Last Commit): 2018-05-02  
Author: Brady Love  
  
Fix Pattern: Sanitization -> Redaction -> Enhancement (Corrective Change) -> Tag/TypeBasedFiltration  
  
Fixing-commits Count: 4  
Total Change Size: +1 -1  
  
========  
https://github.com/cloudfoundry/go-envstruct/commit/202a7e2bbf85bbcd7c54107eab3fb58eb0e416ff  
https://github.com/cloudfoundry/go-envstruct/commit/96ad3dfe55ebd6736f0ce5725c94a6a7b17e3dd0  
https://github.com/cloudfoundry/go-envstruct/commit/b0b90ab30302943773321ec3c0bde04262d9a414  
https://github.com/cloudfoundry/log-cache/commit/0a6fb8eb269513259ac01aeb365ee82694e68bcb  
Change Size: +1 -1  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> UAA client secret on startup as part of its envstruct report  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（writeReport）  
Sensitiveness-Identifiable Source:  Same Modules & Cross Files（https://github.com/cloudfoundry/log-cache/blob/526a0fd20d0308de00e5a3018047219428e31653/cmd/cf-auth-proxy/config.go#L17） -> Variable Names（ClientSecret）  
Programming Language:Go  
```Go  
// https://github.com/cloudfoundry/log-cache/blob/526a0fd20d0308de00e5a3018047219428e31653/cmd/cf-auth-proxy/main.go#L25-L36  
func main() {  
	log.SetFlags(log.LstdFlags | log.Lmicroseconds)  
  
	loggr := log.New(os.Stderr, "", log.LstdFlags)  
	loggr.Print("Starting Log Cache CF Auth Reverse Proxy...")  
	defer loggr.Print("Closing Log Cache CF Auth Reverse Proxy.")  
  
	cfg, err := LoadConfig()  
	if err != nil {  
		loggr.Fatalf("failed to load config: %s", err)  
	}  
	envstruct.WriteReport(cfg) // HERE IS THE SINK 1  
  
  
// https://github.com/cloudfoundry/log-cache/blob/526a0fd20d0308de00e5a3018047219428e31653/cmd/cf-auth-proxy/config.go#L15-L56  
  
type UAA struct {  
	ClientID     string `env:"UAA_CLIENT_ID,     required"`  
	ClientSecret string `env:"UAA_CLIENT_SECRET, required"`  
	Addr         string `env:"UAA_ADDR,          required, report"`  
	CAPath       string `env:"UAA_CA_PATH,       required, report"`  
}  
  
type Config struct {  
	LogCacheGatewayAddr     string        `env:"LOG_CACHE_GATEWAY_ADDR, required, report"`  
	Addr                    string        `env:"ADDR, required, report"`  
	InternalIP              string        `env:"INTERNAL_IP, report"`  
	HealthPort              int           `env:"HEALTH_PORT, report"`  
	CertPath                string        `env:"EXTERNAL_CERT, required, report"`  
	KeyPath                 string        `env:"EXTERNAL_KEY, required, report"`  
	SkipCertVerify          bool          `env:"SKIP_CERT_VERIFY, report"`  
	ProxyCAPath             string        `env:"PROXY_CA_PATH, required, report"`  
	SecurityEventLog        string        `env:"SECURITY_EVENT_LOG, report"`  
	TokenPruningInterval    time.Duration `env:"TOKEN_PRUNING_INTERVAL, report"`  
	CacheExpirationInterval time.Duration `env:"CACHE_EXPIRATION_INTERVAL, report"`  
  
	CAPI CAPI  
	UAA  UAA  
}  
  
func LoadConfig() (*Config, error) {  
	cfg := Config{  
		SkipCertVerify:          false,  
		Addr:                    ":8083",  
		InternalIP:              "0.0.0.0",  
		HealthPort:              6065,  
		LogCacheGatewayAddr:     "localhost:8081",  
		TokenPruningInterval:    time.Minute,  
		CacheExpirationInterval: time.Minute,  
	}  
  
	err := envstruct.Load(&cfg)  
	if err != nil {  
		return nil, err  
	}  
  
	return &cfg, nil  
}  
  
  
// https://github.com/cloudfoundry/go-envstruct/blob/202a7e2bbf85bbcd7c54107eab3fb58eb0e416ff/report.go#L33-L83  
  
func writeReport(t interface{}, w io.Writer) error {  
	name := reflect.TypeOf(t).Elem().Name()  
	val := reflect.ValueOf(t).Elem()  
  
	for i := 0; i < val.NumField(); i++ {  
		valueField := val.Field(i)  
		typeField := val.Type().Field(i)  
		tag := typeField.Tag  
  
		// If field does not have the `env` tag, check to see if it is a struct,  
		// if it is not, then continue to next field, otherwise write the report  
		// for the sub struct.  
		if tag.Get("env") == "" {  
			if valueField.Kind() == reflect.Struct {  
				if err := writeReport(valueField.Addr().Interface(), w); err != nil {  
					return err  
  
				}  
			}  
  
			if valueField.Kind() == reflect.Ptr {  
				if err := writeReport(valueField.Interface(), w); err != nil {  
					return err  
  
				}  
			}  
  
			continue  
		}  
  
		tagProperties := separateOnComma(tag.Get("env"))  
		envVar := strings.ToUpper(tagProperties[indexEnvVar])  
		isRequired := tagPropertiesContains(tagProperties, tagRequired)  
  
		displayedValue := "(OMITTED)"  
		if tagPropertiesContains(tagProperties, tagReport) {  
			displayedValue = fmt.Sprint(valueField)  
		}  
  
		fmt.Fprintln(w, fmt.Sprintf(  
			"%s.%v\t%v\t%v\t%t\t%v",  
			name,  
			typeField.Name,  
			valueField.Type(),  
			envVar,  
			isRequired,  
			displayedValue))  
	}  
  
	return nil  
}  
  
```  
