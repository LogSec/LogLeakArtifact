## Summary:  
Software: django-anymail  
## Fix:  
Commit: https://github.com/anymail/django-anymail/commit/1a6086f2b58478d71f89bf27eb034ed81aefe5ef  
Change Size: +99 -29  
Author:   
Fix Time (of the Last Commit): 2018-02-09  
  
Fix Pattern: Sanitization -> Redaction -> Enhancement (Adaptive Change) -> Keyword/RegexBasedFiltration -> RedactionFunctionDefined  
Fixing-commits Count: 1  
Total Change Size: +99 -29  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> WEBHOOK_AUTHORIZATION  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（log_response）  
Sensitiveness-Identifiable Source:  Cross Projects|Cross-Libraries（https://github.com/anymail/django-anymail/blob/db586ede1fbb41dce21310ea28ae15a1cf1286c5/anymail/webhooks/base.py#L27）-> String Literals（webhook_authorization）  
Programming Language:Python  
```Python  
  
# https://github.com/django/django/blob/8c7ff7b8cff4a62423512efc3c4fe7955edfeed5/django/core/handlers/exception.py#L54-L122  
def response_for_exception(request, exc):  
    if isinstance(exc, Http404):  
        if settings.DEBUG:  
            response = debug.technical_404_response(request, exc)  
        else:  
            response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)  
  
    elif isinstance(exc, PermissionDenied):  
        response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)  
        log_response(  
            'Forbidden (Permission denied): %s', request.path,  
            response=response,  
            request=request,  
            exc_info=sys.exc_info(),  
        )  
  
    elif isinstance(exc, MultiPartParserError):  
        response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)  
        log_response(  
            'Bad request (Unable to parse request body): %s', request.path,  
            response=response,  
            request=request,  
            exc_info=sys.exc_info(),  
        )  
  
    elif isinstance(exc, BadRequest):  
        if settings.DEBUG:  
            response = debug.technical_500_response(request, *sys.exc_info(), status_code=400) # HERE IS THE FLOW  
        else:  
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)  
        log_response(  
            '%s: %s', str(exc), request.path,  
            response=response,  
            request=request,  
            exc_info=sys.exc_info(),  
        ) # HERE IS THE FLOW  
    elif isinstance(exc, SuspiciousOperation):  
        if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):  
            # POST data can't be accessed again, otherwise the original  
            # exception would be raised.  
            request._mark_post_parse_error()  
  
        # The request logger receives events for any problematic request  
        # The security logger receives events for all SuspiciousOperations  
        security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)  
        security_logger.error(  
            str(exc),  
            extra={'status_code': 400, 'request': request},  
        )  
        if settings.DEBUG:  
            response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)  
        else:  
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)  
  
    else:  
        signals.got_request_exception.send(sender=None, request=request)  
        response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info()) # HERE IS THE FLOW  
        log_response(  
            '%s: %s', response.reason_phrase, request.path,  
            response=response,  
            request=request,  
            exc_info=sys.exc_info(),  
        ) # HERE IS THE SINK 1  
  
    # Force a TemplateResponse to be rendered.  
    if not getattr(response, 'is_rendered', True) and callable(getattr(response, 'render', None)):  
        response = response.render()  
  
    return response  
  
# https://github.com/django/django/blob/8c7ff7b8cff4a62423512efc3c4fe7955edfeed5/django/core/handlers/exception.py#L136-L149  
def handle_uncaught_exception(request, resolver, exc_info):  
    """  
    Processing for any otherwise uncaught exceptions (those that will  
    generate HTTP 500 responses).  
    """  
    if settings.DEBUG_PROPAGATE_EXCEPTIONS:  
        raise  
  
    if settings.DEBUG:  
        return debug.technical_500_response(request, *exc_info) # HERE IS THE FLOW  
  
    # Return an HttpResponse that displays a friendly error message.  
    callback = resolver.resolve_error_handler(500)  
    return callback(request)  
  
  
  
# https://github.com/django/django/blob/4cd77f97a2d30d58841041a73d277ec4bfb7b530/django/views/debug.py#L50-L61  
  
def technical_500_response(request, exc_type, exc_value, tb, status_code=500):  
    """  
    Create a technical server error response. The last three arguments are  
    the values returned from sys.exc_info() and friends.  
    """  
    reporter = get_exception_reporter_class(request)(request, exc_type, exc_value, tb)  
    if request.accepts('text/html'):  
        html = reporter.get_traceback_html()  
        return HttpResponse(html, status=status_code, content_type='text/html')  
    else:  
        text = reporter.get_traceback_text()  
        return HttpResponse(text, status=status_code, content_type='text/plain; charset=utf-8')  
  
# https://github.com/django/django/blob/4cd77f97a2d30d58841041a73d277ec4bfb7b530/django/views/debug.py#L70-L243  
def get_exception_reporter_filter(request):  
    default_filter = get_default_exception_reporter_filter()  
    return getattr(request, 'exception_reporter_filter', default_filter)  
  
  
def get_exception_reporter_class(request):  
    default_exception_reporter_class = import_string(settings.DEFAULT_EXCEPTION_REPORTER)  
    return getattr(request, 'exception_reporter_class', default_exception_reporter_class)  
  
  
class SafeExceptionReporterFilter:  
    """  
    Use annotations made by the sensitive_post_parameters and  
    sensitive_variables decorators to filter out sensitive information.  
    """  
    cleansed_substitute = '********************'  
    hidden_settings = _lazy_re_compile('API|TOKEN|KEY|SECRET|PASS|SIGNATURE', flags=re.I)  
  
    def cleanse_setting(self, key, value):  
        """  
        Cleanse an individual setting key/value of sensitive content. If the  
        value is a dictionary, recursively cleanse the keys in that dictionary.  
        """  
        try:  
            is_sensitive = self.hidden_settings.search(key)  
        except TypeError:  
            is_sensitive = False  
  
        if is_sensitive:  
            cleansed = self.cleansed_substitute  
        elif isinstance(value, dict):  
            cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}  
        elif isinstance(value, list):  
            cleansed = [self.cleanse_setting('', v) for v in value]  
        elif isinstance(value, tuple):  
            cleansed = tuple([self.cleanse_setting('', v) for v in value])  
        else:  
            cleansed = value  
  
        if callable(cleansed):  
            cleansed = CallableSettingWrapper(cleansed)  
  
        return cleansed  
  
    def get_safe_settings(self):  
        """  
        Return a dictionary of the settings module with values of sensitive  
        settings replaced with stars (*********).  
        """  
        settings_dict = {}  
        for k in dir(settings):  
            if k.isupper():  
                settings_dict[k] = self.cleanse_setting(k, getattr(settings, k))  
        return settings_dict  
  
    def get_safe_request_meta(self, request):  
        """  
        Return a dictionary of request.META with sensitive values redacted.  
        """  
        if not hasattr(request, 'META'):  
            return {}  
        return {k: self.cleanse_setting(k, v) for k, v in request.META.items()}  
  
    def is_active(self, request):  
        """  
        This filter is to add safety in production environments (i.e. DEBUG  
        is False). If DEBUG is True then your site is not safe anyway.  
        This hook is provided as a convenience to easily activate or  
        deactivate the filter on a per request basis.  
        """  
        return settings.DEBUG is False  
  
    def get_cleansed_multivaluedict(self, request, multivaluedict):  
        """  
        Replace the keys in a MultiValueDict marked as sensitive with stars.  
        This mitigates leaking sensitive POST parameters if something like  
        request.POST['nonexistent_key'] throws an exception (#21098).  
        """  
        sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])  
        if self.is_active(request) and sensitive_post_parameters:  
            multivaluedict = multivaluedict.copy()  
            for param in sensitive_post_parameters:  
                if param in multivaluedict:  
                    multivaluedict[param] = self.cleansed_substitute  
        return multivaluedict  
  
    def get_post_parameters(self, request):  
        """  
        Replace the values of POST parameters marked as sensitive with  
        stars (*********).  
        """  
        if request is None:  
            return {}  
        else:  
            sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])  
            if self.is_active(request) and sensitive_post_parameters:  
                cleansed = request.POST.copy()  
                if sensitive_post_parameters == '__ALL__':  
                    # Cleanse all parameters.  
                    for k in cleansed:  
                        cleansed[k] = self.cleansed_substitute  
                    return cleansed  
                else:  
                    # Cleanse only the specified parameters.  
                    for param in sensitive_post_parameters:  
                        if param in cleansed:  
                            cleansed[param] = self.cleansed_substitute  
                    return cleansed  
            else:  
                return request.POST  
  
    def cleanse_special_types(self, request, value):  
        try:  
            # If value is lazy or a complex object of another kind, this check  
            # might raise an exception. isinstance checks that lazy  
            # MultiValueDicts will have a return value.  
            is_multivalue_dict = isinstance(value, MultiValueDict)  
        except Exception as e:  
            return '{!r} while evaluating {!r}'.format(e, value)  
  
        if is_multivalue_dict:  
            # Cleanse MultiValueDicts (request.POST is the one we usually care about)  
            value = self.get_cleansed_multivaluedict(request, value)  
        return value  
  
    def get_traceback_frame_variables(self, request, tb_frame):  
        """  
        Replace the values of variables marked as sensitive with  
        stars (*********).  
        """  
        # Loop through the frame's callers to see if the sensitive_variables  
        # decorator was used.  
        current_frame = tb_frame.f_back  
        sensitive_variables = None  
        while current_frame is not None:  
            if (current_frame.f_code.co_name == 'sensitive_variables_wrapper' and  
                    'sensitive_variables_wrapper' in current_frame.f_locals):  
                # The sensitive_variables decorator was used, so we take note  
                # of the sensitive variables' names.  
                wrapper = current_frame.f_locals['sensitive_variables_wrapper']  
                sensitive_variables = getattr(wrapper, 'sensitive_variables', None)  
                break  
            current_frame = current_frame.f_back  
  
        cleansed = {}  
        if self.is_active(request) and sensitive_variables:  
            if sensitive_variables == '__ALL__':  
                # Cleanse all variables  
                for name in tb_frame.f_locals:  
                    cleansed[name] = self.cleansed_substitute  
            else:  
                # Cleanse specified variables  
                for name, value in tb_frame.f_locals.items():  
                    if name in sensitive_variables:  
                        value = self.cleansed_substitute  
                    else:  
                        value = self.cleanse_special_types(request, value)  
                    cleansed[name] = value  
        else:  
            # Potentially cleanse the request and any MultiValueDicts if they  
            # are one of the frame variables.  
            for name, value in tb_frame.f_locals.items():  
                cleansed[name] = self.cleanse_special_types(request, value)  
  
        if (tb_frame.f_code.co_name == 'sensitive_variables_wrapper' and  
                'sensitive_variables_wrapper' in tb_frame.f_locals):  
            # For good measure, obfuscate the decorated function's arguments in  
            # the sensitive_variables decorator's frame, in case the variables  
            # associated with those arguments were meant to be obfuscated from  
            # the decorated function's frame.  
            cleansed['func_args'] = self.cleansed_substitute  
            cleansed['func_kwargs'] = self.cleansed_substitute  
  
        return cleansed.items()  
  
```  
