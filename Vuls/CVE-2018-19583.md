## Summary:  
Software: gitlab  
## Fix:  
Commit: https://gitlab.com/gitlab-org/gitlab-workhorse/-/commit/9f201d12876847dda78fc4fd8ffb0518ad1e572f  
Change Size: +98 -7  
Author: Mark Chao  
Fix Time (of the Last Commit): 2018-10-22  
Fix Pattern: Sanitization -> Redaction -> Enhancement (Adaptive Change) -> Keyword/RegexBasedFiltration -> RedactionFunctionDefined  
  
Fixing-commits Count: 1  
Total Change Size: +98 -7  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> access tokens  
### Sink labels:  
#### Sink 1:  
Logging call Function:  User-defined（helper.LogError）  
Sensitiveness-Identifiable Source:  No  
Programming Language:Go  
```Go  
  
// https://gitlab.com/gitlab-org/gitlab-workhorse/-/blob/9f201d12876847dda78fc4fd8ffb0518ad1e572f/internal/api/api.go#L300-325  
  
func passResponseBack(httpResponse *http.Response, w http.ResponseWriter, r *http.Request) {  
	// NGINX response buffering is disabled on this path (with  
	// X-Accel-Buffering: no) but we still want to free up the Unicorn worker  
	// that generated httpResponse as fast as possible. To do this we buffer  
	// the entire response body in memory before sending it on.  
	responseBody, err := bufferResponse(httpResponse.Body)  
	if err != nil {  
		helper.Fail500(w, r, err)  
		return  
	}  
	httpResponse.Body.Close() // Free up the Unicorn worker  
	bytesTotal.Add(float64(responseBody.Len()))  
  
	for k, v := range httpResponse.Header {  
		// Accomodate broken clients that do case-sensitive header lookup  
		if k == "Www-Authenticate" {  
			w.Header()["WWW-Authenticate"] = v  
		} else {  
			w.Header()[k] = v  
		}  
	}  
	w.WriteHeader(httpResponse.StatusCode)  
	if _, err := io.Copy(w, responseBody); err != nil {  
		helper.LogError(r, err) // HERE IS THE SINK 1  
	}  
}  
  
  
// https://gitlab.com/gitlab-org/gitlab-workhorse/-/blob/9f201d12876847dda78fc4fd8ffb0518ad1e572f/internal/helper/helpers.go#L31-37  
  
func LogError(r *http.Request, err error) {  
	if err != nil {  
		captureRavenError(r, err)  
	}  
  
	printError(r, err)  
}  
  
  
// https://gitlab.com/gitlab-org/gitlab-workhorse/-/blob/9f201d12876847dda78fc4fd8ffb0518ad1e572f/internal/helper/helpers.go#L45-54  
  
func printError(r *http.Request, err error) {  
	if r != nil {  
		log.WithFields(r.Context(), log.Fields{  
			"method": r.Method,  
			"uri":    ScrubURLParams(r.RequestURI),  
		}).WithError(err).Error("error")  
	} else {  
		log.NoContext().WithError(err).Error("unknown error")  
	}  
}  
  
  
  
// https://gitlab.com/gitlab-org/gitlab-workhorse/-/blob/9f201d12876847dda78fc4fd8ffb0518ad1e572f/internal/helper/helpers.go#L197-230  
  
// Based on https://stackoverflow.com/a/52965552/474597  
// ScrubURLParams replaces the content of any sensitive query string parameters  
// in an URL with `[FILTERED]`  
func ScrubURLParams(originalURL string) string {  
	u, err := url.Parse(originalURL)  
	if err != nil {  
		return "<invalid URL>"  
	}  
  
	buf := bytes.NewBuffer(make([]byte, 0, len(originalURL)))  
  
	for i, queryPart := range bytes.Split([]byte(u.RawQuery), []byte("&")) {  
		if i != 0 {  
			buf.WriteByte(byte('&'))  
		}  
  
		splitParam := bytes.SplitN(queryPart, []byte("="), 2)  
  
		if len(splitParam) == 2 {  
			buf.Write(splitParam[0])  
			buf.WriteByte(byte('='))  
  
			if isParamSensitive(splitParam[0]) {  
				buf.Write([]byte("[FILTERED]"))  
			} else {  
				buf.Write(splitParam[1])  
			}  
		} else {  
			buf.Write(queryPart)  
		}  
	}  
	u.RawQuery = buf.String()  
	return u.String()  
}  
  
  
```  
