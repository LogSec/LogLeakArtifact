## Summary:  
Software: openstack/keystone  
## Fix:  
Commit: https://github.com/openstack/keystone/commit/f9db1a65bd4d83d12c572ba4d5807845996ef410  
Change Size: +1 -1  
Author: Eric Brown  
Fix Time (of the Last Commit): 2015-04-14  
Fix Pattern: Sanitization -> Redaction -> Reuse -> TagBasedFiltration  
  
Fixing-commits Count: 1  
Total Change Size: +1 -1  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> passwords and other sensitive backend information  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Third-party Libaries（OpenStack ConfigOpts.log_opt_values）  
Sensitiveness-Identifiable Source:  Same Projects & Cross Modules（https://github.com/openstack/keystone/blob/f9db1a65bd4d83d12c572ba4d5807845996ef410/keystone/common/config.py#L27） -> String Literals（admin_token，finally outputed to logs）  
Programming Language:Python  
```python  
  
# https://github.com/openstack/keystone/blob/d43e2a51a1ed7adbed3c5ddf001d46bc4a824ae8/bin/keystone-all#L73-L123  
  
if __name__ == '__main__':  
    dev_conf = os.path.join(possible_topdir,  
                            'etc',  
                            'keystone.conf')  
    config_files = None  
    if os.path.exists(dev_conf):  
        config_files = [dev_conf]  
  
    CONF(project='keystone',  
         version=version.VersionInfo('keystone').version_string(),  
         default_config_files=config_files)  
  
    config.setup_logging(CONF)  
  
    # Log the options used when starting if we're in debug mode...  
    if CONF.debug:  
        CONF.log_opt_values(logging.getLogger(CONF.prog), logging.DEBUG) # HERE IS THE SINK 1  
  
    if CONF.config_file:  
        paste_config = CONF.config_file[0]  
    else:  
        paste_config = CONF.find_file('keystone.conf')  
        if not paste_config:  
            print ("The keystone.conf file could not be found in the "  
                   "configuration directories.")  
            CONF.print_help()  
            sys.exit(1)  
  
    monkeypatch_thread = not CONF.standard_threads  
    pydev_debug_url = utils.setup_remote_pydev_debug()  
    if pydev_debug_url:  
        # in order to work around errors caused by monkey patching we have to  
        # set the thread to False.  An explanation is here:  
        # http://lists.openstack.org/pipermail/openstack-dev/2012-August/  
        # 000794.html  
        monkeypatch_thread = False  
    eventlet.patcher.monkey_patch(all=False, socket=True, time=True,  
                                  thread=monkeypatch_thread)  
  
    options = deploy.appconfig('config:%s' % paste_config)  
  
    servers = []  
    servers.append(create_server(paste_config,  
                                 'admin',  
                                 CONF.bind_host,  
                                 int(CONF.admin_port)))  
    servers.append(create_server(paste_config,  
                                 'main',  
                                 CONF.bind_host,  
                                 int(CONF.public_port)))  
    serve(*servers)  
  
  
# https://github.com/openstack/keystone/blob/f9db1a65bd4d83d12c572ba4d5807845996ef410/keystone/common/config.py#L1097-L1116  
def configure(conf=None):  
    if conf is None:  
        conf = CONF  
  
    conf.register_cli_opt(  
        cfg.BoolOpt('standard-threads', default=False,  
                    help='Do not monkey-patch threading system modules.'))  
    conf.register_cli_opt(  
        cfg.StrOpt('pydev-debug-host',  
                   help='Host to connect to for remote debugger.'))  
    conf.register_cli_opt(  
        cfg.IntOpt('pydev-debug-port',  
                   help='Port to connect to for remote debugger.'))  
  
    for section in FILE_OPTIONS:  
        for option in FILE_OPTIONS[section]:  
            if section:  
                conf.register_opt(option, group=section)  
            else:  
                conf.register_opt(option)  
  
# https://github.com/openstack/keystone/blob/f9db1a65bd4d83d12c572ba4d5807845996ef410/keystone/common/config.py#L25-L34  
  
FILE_OPTIONS = {  
    None: [  
        cfg.StrOpt('admin_token', secret=True, default='ADMIN',  
                   help='A "shared secret" that can be used to bootstrap '  
                        'Keystone. This "token" does not represent a user, '  
                        'and carries no explicit authorization. To disable '  
                        'in production (highly recommended), remove '  
                        'AdminTokenAuthMiddleware from your paste '  
                        'application pipelines (for example, in '  
                        'keystone-paste.ini).'),  
  
```  
```python  
# https://github.com/openstack/oslo.config/blob/445f1c42d90a5c36403c5420aeca797c7a666325/oslo_config/cfg.py#L2556-L2591  
  
    def log_opt_values(self, logger, lvl):  
        """Log the value of all registered opts.  
        It's often useful for an app to log its configuration to a log file at  
        startup for debugging. This method dumps to the entire config state to  
        the supplied logger at a given log level.  
        :param logger: a logging.Logger object  
        :param lvl: the log level (for example logging.DEBUG) arg to  
                    logger.log()  
        """  
        logger.log(lvl, "*" * 80)  
        logger.log(lvl, "Configuration options gathered from:")  
        logger.log(lvl, "command line args: %s", self._args)  
        logger.log(lvl, "config files: %s",  
                   hasattr(self, 'config_file') and self.config_file or [])  
        logger.log(lvl, "=" * 80)  
  
        def _sanitize(opt, value):  
            """Obfuscate values of options declared secret."""  
            return value if not opt.secret else '*' * 4  
  
        for opt_name in sorted(self._opts):  
            opt = self._get_opt_info(opt_name)['opt']  
            logger.log(lvl, "%-30s = %s", opt_name,  
                       _sanitize(opt, getattr(self, opt_name)))  
  
        for group_name in list(self._groups):  
            group_attr = self.GroupAttr(self, self._get_group(group_name))  
            for opt_name in sorted(self._groups[group_name]._opts):  
                opt = self._get_opt_info(opt_name, group_name)['opt']  
                logger.log(lvl, "%-30s = %s",  
                           "%s.%s" % (group_name, opt_name),  
                           _sanitize(opt, getattr(group_attr, opt_name)))  
  
        logger.log(lvl, "*" * 80)  
  
```  
