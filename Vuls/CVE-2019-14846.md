## Summary:  
Software: ansible  
## Fix:  
Commit: https://github.com/abadger/ansible/commit/cb0d1d86f8cec98b93da5df7f680f6c6a1d9cb73  
Author: Toshio Kuratomi  
Fix Time (of the Last Commit): 2019-10-11  
  
Fix Pattern: Disable Logging in Default  
  
Fixing-commits Count: 1  
Total Change Size: +11 -1  
  
========  
PR: https://github.com/ansible/ansible/pull/63366  
Commit: https://github.com/abadger/ansible/commit/cb0d1d86f8cec98b93da5df7f680f6c6a1d9cb73  
Change Size: +11 -1  
## Sample logs: No  
## Logging statements:  
### Source labels:  
Type of Sensitive Information:authentication data -> credentials  
### Sink labels:  
#### Sink 1:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Cross Projects|Cross-Libraries（https://github.com/ansible/ansible/blob/33d0d36eaa90ea484606bb11dd8b76f40402f7a4/lib/ansible/plugins/lookup/aws_secret.py#L79） -> Variable Names（credentials）  
#### Sink 2:  
Logging call Function:  Standard Libraries（logging）  
Sensitiveness-Identifiable Source:  Cross Projects|Cross-Libraries（https://github.com/ansible/ansible/blob/33d0d36eaa90ea484606bb11dd8b76f40402f7a4/lib/ansible/plugins/lookup/aws_secret.py#L79） -> Variable Names（credentials）  
Programming Language:Python  
```Python  
  
# https://github.com/ansible/ansible/blob/33d0d36eaa90ea484606bb11dd8b76f40402f7a4/lib/ansible/plugins/lookup/aws_secret.py#L75-L88  
def _boto3_conn(region, credentials):  
    boto_profile = credentials.pop('aws_profile', None)  
  
    try:  
        connection = boto3.session.Session(profile_name=boto_profile).client('secretsmanager', region, **credentials) # HERE IS THE EXPLICIT SINK 1  
    except (botocore.exceptions.ProfileNotFound, botocore.exceptions.PartialCredentialsError) as e:  
        if boto_profile:  
            try:  
                connection = boto3.session.Session(profile_name=boto_profile).client('secretsmanager', region)  
            except (botocore.exceptions.ProfileNotFound, botocore.exceptions.PartialCredentialsError) as e:  
                raise AnsibleError("Insufficient credentials found.")  
        else:  
            raise AnsibleError("Insufficient credentials found.")  
    return connection  
  
# https://github.com/ansible/ansible/blob/d961f676c01023a6a21503df16ba551a550e515b/lib/ansible/plugins/lookup/aws_ssm.py#L121-L138  
  
def _boto3_conn(region, credentials):  
    if 'boto_profile' in credentials:  
        boto_profile = credentials.pop('boto_profile')  
    else:  
        boto_profile = None  
  
    try:  
        connection = boto3.session.Session(profile_name=boto_profile).client('ssm', region, **credentials) # HERE IS THE EXPLICIT SINK 2  
    except (botocore.exceptions.ProfileNotFound, botocore.exceptions.PartialCredentialsError):  
        if boto_profile:  
            try:  
                connection = boto3.session.Session(profile_name=boto_profile).client('ssm', region)  
            # FIXME: we should probably do better passing on of the error information  
            except (botocore.exceptions.ProfileNotFound, botocore.exceptions.PartialCredentialsError):  
                raise AnsibleError("Insufficient credentials found.")  
        else:  
            raise AnsibleError("Insufficient credentials found.")  
    return connection  
  
# https://github.com/ansible/ansible/blob/d961f676c01023a6a21503df16ba551a550e515b/lib/ansible/plugins/inventory/aws_ec2.py#L280-L300  
  
    def _boto3_conn(self, regions):  
        '''  
            :param regions: A list of regions to create a boto3 client  
            Generator that yields a boto3 client and the region  
        '''  
  
        credentials = self._get_credentials()  
  
        for region in regions:  
            try:  
                connection = boto3.session.Session(profile_name=self.boto_profile).client('ec2', region, **credentials) # HERE IS THE EXPLICIT SINK 3  
            except (botocore.exceptions.ProfileNotFound, botocore.exceptions.PartialCredentialsError) as e:  
                if self.boto_profile:  
                    try:  
                        connection = boto3.session.Session(profile_name=self.boto_profile).client('ec2', region)  
                    except (botocore.exceptions.ProfileNotFound, botocore.exceptions.PartialCredentialsError) as e:  
                        raise AnsibleError("Insufficient credentials found: %s" % to_native(e))  
                else:  
                    raise AnsibleError("Insufficient credentials found: %s" % to_native(e))  
            yield connection, region  
  
# https://github.com/ansible/ansible/blob/d961f676c01023a6a21503df16ba551a550e515b/lib/ansible/plugins/lookup/aws_account_attribute.py#L70-L83  
  
def _boto3_conn(region, credentials):  
    boto_profile = credentials.pop('aws_profile', None)  
  
    try:  
        connection = boto3.session.Session(profile_name=boto_profile).client('ec2', region, **credentials)  # HERE IS THE EXPLICIT SINK 4  
    except (botocore.exceptions.ProfileNotFound, botocore.exceptions.PartialCredentialsError) as e:  
        if boto_profile:  
            try:  
                connection = boto3.session.Session(profile_name=boto_profile).client('ec2', region)  
            except (botocore.exceptions.ProfileNotFound, botocore.exceptions.PartialCredentialsError) as e:  
                raise AnsibleError("Insufficient credentials found.")  
        else:  
            raise AnsibleError("Insufficient credentials found.")  
    return connection  
  
  
# https://github.com/boto/boto3/blob/9736bea/boto3/session.py#L185-L263  
def client(self, service_name, region_name=None, api_version=None,  
               use_ssl=True, verify=None, endpoint_url=None,  
               aws_access_key_id=None, aws_secret_access_key=None,  
               aws_session_token=None, config=None):  
          
        # OMIT FOR SIMPLICITY  
          
        return self._session.create_client(  
            service_name, region_name=region_name, api_version=api_version,  
            use_ssl=use_ssl, verify=verify, endpoint_url=endpoint_url,  
            aws_access_key_id=aws_access_key_id,  
            aws_secret_access_key=aws_secret_access_key,  
            aws_session_token=aws_session_token, config=config) # HERE IS THE FLOW  
  
# https://github.com/boto/botocore/blob/23ee17f5446c78167ff442302471f9928c3b4b7c/botocore/client.py#L72-L117  
    def create_client(self, service_name, region_name, is_secure=True,  
                      endpoint_url=None, verify=None,  
                      credentials=None, scoped_config=None,  
                      api_version=None,  
                      client_config=None):  
        responses = self._event_emitter.emit(  
            'choose-service-name', service_name=service_name)  
        service_name = first_non_none_response(responses, default=service_name)  
        service_model = self._load_service_model(service_name, api_version)  
        cls = self._create_client_class(service_name, service_model) # HERE IS THE FLOW  
        endpoint_bridge = ClientEndpointBridge(  
            self._endpoint_resolver, scoped_config, client_config,  
            service_signing_name=service_model.metadata.get('signingName'))  
        client_args = self._get_client_args(  
            service_model, region_name, is_secure, endpoint_url,  
            verify, credentials, scoped_config, client_config, endpoint_bridge)  
        service_client = cls(**client_args)  
        self._register_retries(service_client)  
        self._register_s3_events(  
            service_client, endpoint_bridge, endpoint_url, client_config,  
            scoped_config)  
        self._register_s3_control_events(  
            service_client, endpoint_bridge, endpoint_url, client_config,  
            scoped_config)  
        self._register_endpoint_discovery(  
            service_client, endpoint_url, client_config  
        )  
        return service_client  
          
    def create_client_class(self, service_name, api_version=None):  
        service_model = self._load_service_model(service_name, api_version)  
        return self._create_client_class(service_name, service_model) # HERE IS THE FLOW  
  
    def _create_client_class(self, service_name, service_model):  
        class_attributes = self._create_methods(service_model)  # HERE IS THE FLOW  
        py_name_to_operation_name = self._create_name_mapping(service_model)  
        class_attributes['_PY_TO_OP_NAME'] = py_name_to_operation_name  
        bases = [BaseClient]  
        service_id = service_model.service_id.hyphenize()  
        self._event_emitter.emit(  
            'creating-client-class.%s' % service_id,  
            class_attributes=class_attributes,  
            base_classes=bases)  
        class_name = get_service_module_name(service_model)  
        cls = type(str(class_name), tuple(bases), class_attributes)  
        return cls  
  
# https://github.com/boto/botocore/blob/23ee17f5446c78167ff442302471f9928c3b4b7c/botocore/client.py#L330-L336  
    def _create_methods(self, service_model):  
        op_dict = {}  
        for operation_name in service_model.operation_names:  
            py_operation_name = xform_name(operation_name)  
            op_dict[py_operation_name] = self._create_api_method(  
                py_operation_name, operation_name, service_model)   # HERE IS THE FLOW  
        return op_dict  
  
# https://github.com/boto/botocore/blob/23ee17f5446c78167ff442302471f9928c3b4b7c/botocore/client.py#L347-L372  
  
    def _create_api_method(self, py_operation_name, operation_name,  
                           service_model):  
        def _api_call(self, *args, **kwargs):  
            # We're accepting *args so that we can give a more helpful  
            # error message than TypeError: _api_call takes exactly  
            # 1 argument.  
            if args:  
                raise TypeError(  
                    "%s() only accepts keyword arguments." % py_operation_name)  
            # The "self" in this scope is referring to the BaseClient.  
            return self._make_api_call(operation_name, kwargs)  # HERE IS THE FLOW  
  
        _api_call.__name__ = str(py_operation_name)  
  
        # Add the docstring to the client method  
        operation_model = service_model.operation_model(operation_name)  
        docstring = ClientMethodDocstring(  
            operation_model=operation_model,  
            method_name=operation_name,  
            event_emitter=self._event_emitter,  
            method_description=operation_model.documentation,  
            example_prefix='response = client.%s' % py_operation_name,  
            include_signature=False  
        )  
        _api_call.__doc__ = docstring  
        return _api_call  
  
# https://github.com/boto/botocore/blob/23ee17f5446c78167ff442302471f9928c3b4b7c/botocore/client.py#L631-L678  
    def _make_api_call(self, operation_name, api_params):  
        operation_model = self._service_model.operation_model(operation_name)  
        service_name = self._service_model.service_name  
        history_recorder.record('API_CALL', {  
            'service': service_name,  
            'operation': operation_name,  
            'params': api_params,  
        })  
        if operation_model.deprecated:  
            logger.debug('Warning: %s.%s() is deprecated',  
                         service_name, operation_name)  
        request_context = {  
            'client_region': self.meta.region_name,  
            'client_config': self.meta.config,  
            'has_streaming_input': operation_model.has_streaming_input,  
            'auth_type': operation_model.auth_type,  
        }  
        request_dict = self._convert_to_request_dict(  
            api_params, operation_model, context=request_context)  
  
        service_id = self._service_model.service_id.hyphenize()  
        handler, event_response = self.meta.events.emit_until_response(  
            'before-call.{service_id}.{operation_name}'.format(  
                service_id=service_id,  
                operation_name=operation_name),  
            model=operation_model, params=request_dict,  
            request_signer=self._request_signer, context=request_context)  
  
        if event_response is not None:  
            http, parsed_response = event_response  
        else:  
            http, parsed_response = self._make_request(  
                operation_model, request_dict, request_context)  # HERE IS THE FLOW  
  
        self.meta.events.emit(  
            'after-call.{service_id}.{operation_name}'.format(  
                service_id=service_id,  
                operation_name=operation_name),  
            http_response=http, parsed=parsed_response,  
            model=operation_model, context=request_context  
        )  
  
        if http.status_code >= 300:  
            error_code = parsed_response.get("Error", {}).get("Code")  
            error_class = self.exceptions.from_code(error_code)  
            raise error_class(parsed_response, operation_name)  
        else:  
            return parsed_response  
  
# https://github.com/boto/botocore/blob/23ee17f5446c78167ff442302471f9928c3b4b7c/botocore/client.py#L680-L690  
    def _make_request(self, operation_model, request_dict, request_context):  
        try:  
            return self._endpoint.make_request(operation_model, request_dict)  # HERE IS THE FLOW  
        except Exception as e:  
            self.meta.events.emit(  
                'after-call-error.{service_id}.{operation_name}'.format(  
                    service_id=self._service_model.service_id.hyphenize(),  
                    operation_name=operation_model.name),  
                exception=e, context=request_context  
            )  
            raise  
  
# https://github.com/boto/botocore/blob/23ee17f5446c78167ff442302471f9928c3b4b7c/botocore/endpoint.py#L99-L102  
    def make_request(self, operation_model, request_dict):  
        logger.debug("Making request for %s with params: %s",  
                     operation_model, request_dict)   # HERE IS THE SINK 1  
        return self._send_request(request_dict, operation_model)  # HERE IS THE FLOW  
  
# https://github.com/boto/botocore/blob/23ee17f5446c78167ff442302471f9928c3b4b7c/botocore/endpoint.py#L130-L230  
    def _send_request(self, request_dict, operation_model):  
        attempts = 1  
        request = self.create_request(request_dict, operation_model)  
        context = request_dict['context']  
        success_response, exception = self._get_response(  
            request, operation_model, context)  
        while self._needs_retry(attempts, operation_model, request_dict,  
                                success_response, exception):  
            attempts += 1  
            # If there is a stream associated with the request, we need  
            # to reset it before attempting to send the request again.  
            # This will ensure that we resend the entire contents of the  
            # body.  
            request.reset_stream()  
            # Create a new request when retried (including a new signature).  
            request = self.create_request(  
                request_dict, operation_model)  
            success_response, exception = self._get_response(  
                request, operation_model, context)   # HERE IS THE FLOW  
        if success_response is not None and \  
                'ResponseMetadata' in success_response[1]:  
            # We want to share num retries, not num attempts.  
            total_retries = attempts - 1  
            success_response[1]['ResponseMetadata']['RetryAttempts'] = \  
                    total_retries  
        if exception is not None:  
            raise exception  
        else:  
            return success_response  
  
    def _get_response(self, request, operation_model, context):  
        # This will return a tuple of (success_response, exception)  
        # and success_response is itself a tuple of  
        # (http_response, parsed_dict).  
        # If an exception occurs then the success_response is None.  
        # If no exception occurs then exception is None.  
        success_response, exception = self._do_get_response(  
            request, operation_model)   # HERE IS THE FLOW  
        kwargs_to_emit = {  
            'response_dict': None,  
            'parsed_response': None,  
            'context': context,  
            'exception': exception,  
        }  
        if success_response is not None:  
            http_response, parsed_response = success_response  
            kwargs_to_emit['parsed_response'] = parsed_response  
            kwargs_to_emit['response_dict'] = convert_to_response_dict(  
                http_response, operation_model)  
        service_id = operation_model.service_model.service_id.hyphenize()  
        self._event_emitter.emit(  
            'response-received.%s.%s' % (  
                service_id, operation_model.name), **kwargs_to_emit)  
        return success_response, exception  
  
    def _do_get_response(self, request, operation_model):  
        try:  
            logger.debug("Sending http request: %s", request)  # HERE IS THE SINK 2  
            history_recorder.record('HTTP_REQUEST', {  
                'method': request.method,  
                'headers': request.headers,  
                'streaming': operation_model.has_streaming_input,  
                'url': request.url,  
                'body': request.body  
            })  
            service_id = operation_model.service_model.service_id.hyphenize()  
            event_name = 'before-send.%s.%s' % (service_id, operation_model.name)  
            responses = self._event_emitter.emit(event_name, request=request)  
            http_response = first_non_none_response(responses)  
            if http_response is None:  
                http_response = self._send(request)  
        except HTTPClientError as e:  
            return (None, e)  
        except Exception as e:  
            logger.debug("Exception received when sending HTTP request.",  
                         exc_info=True)  
            return (None, e)  
        # This returns the http_response and the parsed_data.  
        response_dict = convert_to_response_dict(http_response, operation_model)  
  
        http_response_record_dict = response_dict.copy()  
        http_response_record_dict['streaming'] = \  
            operation_model.has_streaming_output  
        history_recorder.record('HTTP_RESPONSE', http_response_record_dict)  
  
        protocol = operation_model.metadata['protocol']  
        parser = self._response_parser_factory.create_parser(protocol)  
        parsed_response = parser.parse(  
            response_dict, operation_model.output_shape)  
        # Do a second parsing pass to pick up on any modeled error fields  
        # NOTE: Ideally, we would push this down into the parser classes but  
        # they currently have no reference to the operation or service model  
        # The parsers should probably take the operation model instead of  
        # output shape but we can't change that now  
        if http_response.status_code >= 300:  
            self._add_modeled_error_fields(  
                response_dict, parsed_response,  
                operation_model, parser,  
            )  
        history_recorder.record('PARSED_RESPONSE', parsed_response)  
        return (http_response, parsed_response), None  
  
```  
